{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar base58 = require('bs58');\n\nvar assert = require('assert');\n\nvar randomBytes = require('randombytes');\n\nvar hash = require('./hash');\n\nmodule.exports = {\n  random32ByteBuffer: random32ByteBuffer,\n  addEntropy: addEntropy,\n  cpuEntropy: cpuEntropy,\n  entropyCount: function entropyCount() {\n    return _entropyCount;\n  },\n  checkDecode: checkDecode,\n  checkEncode: checkEncode\n};\nvar entropyPos = 0,\n    _entropyCount = 0;\nvar externalEntropyArray = randomBytes(101);\n/**\n    Additional forms of entropy are used.  A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.\n\n    @arg {number} [cpuEntropyBits = 0] generate entropy on the fly.  This is\n    not required, entropy can be added in advanced via addEntropy or initialize().\n\n    @arg {boolean} [safe = true] false for testing, otherwise this will be\n    true to ensure initialize() was called.\n\n    @return a random buffer obtained from the secure random number generator.  Additional entropy is used.\n*/\n\nfunction random32ByteBuffer() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$cpuEntropyBits = _ref.cpuEntropyBits,\n      cpuEntropyBits = _ref$cpuEntropyBits === undefined ? 0 : _ref$cpuEntropyBits,\n      _ref$safe = _ref.safe,\n      safe = _ref$safe === undefined ? true : _ref$safe;\n\n  assert.equal(typeof cpuEntropyBits === 'undefined' ? 'undefined' : _typeof(cpuEntropyBits), 'number', 'cpuEntropyBits');\n  assert.equal(typeof safe === 'undefined' ? 'undefined' : _typeof(safe), 'boolean', 'boolean');\n\n  if (safe) {\n    assert(_entropyCount >= 128, 'Call initialize() to add entropy');\n  } // if(entropyCount > 0) {\n  //     console.log(`Additional private key entropy: ${entropyCount} events`)\n  // }\n\n\n  var hash_array = [];\n  hash_array.push(randomBytes(32));\n  hash_array.push(Buffer.from(cpuEntropy(cpuEntropyBits)));\n  hash_array.push(externalEntropyArray);\n  hash_array.push(browserEntropy());\n  return hash.sha256(Buffer.concat(hash_array));\n}\n/**\n    Adds entropy.  This may be called many times while the amount of data saved\n    is accumulatively reduced to 101 integers.  Data is retained in RAM for the\n    life of this module.\n\n    @example React <code>\n    componentDidMount() {\n        this.refs.MyComponent.addEventListener(\"mousemove\", this.onEntropyEvent, {capture: false, passive: true})\n    }\n    componentWillUnmount() {\n        this.refs.MyComponent.removeEventListener(\"mousemove\", this.onEntropyEvent);\n    }\n    onEntropyEvent = (e) => {\n        if(e.type === 'mousemove')\n            key_utils.addEntropy(e.pageX, e.pageY, e.screenX, e.screenY)\n        else\n            console.log('onEntropyEvent Unknown', e.type, e)\n    }\n    </code>\n*/\n\n\nfunction addEntropy() {\n  assert.equal(externalEntropyArray.length, 101, 'externalEntropyArray');\n\n  for (var _len = arguments.length, ints = Array(_len), _key = 0; _key < _len; _key++) {\n    ints[_key] = arguments[_key];\n  }\n\n  _entropyCount += ints.length;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = ints[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var i = _step.value;\n      var pos = entropyPos++ % 101;\n      var i2 = externalEntropyArray[pos] += i;\n      if (i2 > 9007199254740991) externalEntropyArray[pos] = 0;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n/**\n    This runs in just under 1 second and ensures a minimum of cpuEntropyBits\n    bits of entropy are gathered.\n\n    Based on more-entropy. @see https://github.com/keybase/more-entropy/blob/master/src/generator.iced\n\n    @arg {number} [cpuEntropyBits = 128]\n    @return {array} counts gathered by measuring variations in the CPU speed during floating point operations.\n*/\n\n\nfunction cpuEntropy() {\n  var cpuEntropyBits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;\n  var collected = [];\n  var lastCount = null;\n  var lowEntropySamples = 0;\n\n  while (collected.length < cpuEntropyBits) {\n    var count = floatingPointCount();\n\n    if (lastCount != null) {\n      var delta = count - lastCount;\n\n      if (Math.abs(delta) < 1) {\n        lowEntropySamples++;\n        continue;\n      } // how many bits of entropy were in this sample\n\n\n      var bits = Math.floor(log2(Math.abs(delta)) + 1);\n\n      if (bits < 4) {\n        if (bits < 2) {\n          lowEntropySamples++;\n        }\n\n        continue;\n      }\n\n      collected.push(delta);\n    }\n\n    lastCount = count;\n  }\n\n  if (lowEntropySamples > 10) {\n    var pct = Number(lowEntropySamples / cpuEntropyBits * 100).toFixed(2); // Is this algorithm getting inefficient?\n\n    console.warn('WARN: ' + pct + '% low CPU entropy re-sampled');\n  }\n\n  return collected;\n}\n/**\n    @private\n    Count while performing floating point operations during a fixed time\n    (7 ms for example).  Using a fixed time makes this algorithm\n    predictable in runtime.\n*/\n\n\nfunction floatingPointCount() {\n  var workMinMs = 7;\n  var d = Date.now();\n  var i = 0,\n      x = 0;\n\n  while (Date.now() < d + workMinMs + 1) {\n    x = Math.sin(Math.sqrt(Math.log(++i + x)));\n  }\n\n  return i;\n}\n\nvar log2 = function log2(x) {\n  return Math.log(x) / Math.LN2;\n};\n/**\n    @private\n    Attempt to gather and hash information from the browser's window, history, and supported mime types.  For non-browser environments this simply includes secure random data.  In any event, the information is re-hashed in a loop for 25 milliseconds seconds.\n\n    @return {Buffer} 32 bytes\n*/\n\n\nfunction browserEntropy() {\n  var entropyStr = Array(randomBytes(101)).join();\n\n  try {\n    entropyStr += new Date().toString() + \" \" + window.screen.height + \" \" + window.screen.width + \" \" + window.screen.colorDepth + \" \" + \" \" + window.screen.availHeight + \" \" + window.screen.availWidth + \" \" + window.screen.pixelDepth + navigator.language + \" \" + window.location + \" \" + window.history.length;\n\n    for (var i = 0, mimeType; i < navigator.mimeTypes.length; i++) {\n      mimeType = navigator.mimeTypes[i];\n      entropyStr += mimeType.description + \" \" + mimeType.type + \" \" + mimeType.suffixes + \" \";\n    }\n  } catch (error) {\n    //nodejs:ReferenceError: window is not defined\n    entropyStr += hash.sha256(new Date().toString());\n  }\n\n  var b = new Buffer(entropyStr);\n  entropyStr += b.toString('binary') + \" \" + new Date().toString();\n  var entropy = entropyStr;\n  var start_t = Date.now();\n\n  while (Date.now() - start_t < 25) {\n    entropy = hash.sha256(entropy);\n  }\n\n  return entropy;\n}\n/**\n  @arg {Buffer} keyBuffer data\n  @arg {string} keyType = sha256x2, K1, etc\n  @return {string} checksum encoded base58 string\n*/\n\n\nfunction checkEncode(keyBuffer) {\n  var keyType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  assert(Buffer.isBuffer(keyBuffer), 'expecting keyBuffer<Buffer>');\n\n  if (keyType === 'sha256x2') {\n    // legacy\n    var checksum = hash.sha256(hash.sha256(keyBuffer)).slice(0, 4);\n    return base58.encode(Buffer.concat([keyBuffer, checksum]));\n  } else {\n    var check = [keyBuffer];\n\n    if (keyType) {\n      check.push(Buffer.from(keyType));\n    }\n\n    var _checksum = hash.ripemd160(Buffer.concat(check)).slice(0, 4);\n\n    return base58.encode(Buffer.concat([keyBuffer, _checksum]));\n  }\n}\n/**\n  @arg {Buffer} keyString data\n  @arg {string} keyType = sha256x2, K1, etc\n  @return {string} checksum encoded base58 string\n*/\n\n\nfunction checkDecode(keyString) {\n  var keyType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  assert(keyString != null, 'private key expected');\n  var buffer = new Buffer(base58.decode(keyString));\n  var checksum = buffer.slice(-4);\n  var key = buffer.slice(0, -4);\n  var newCheck = void 0;\n\n  if (keyType === 'sha256x2') {\n    // legacy\n    newCheck = hash.sha256(hash.sha256(key)).slice(0, 4); // WIF (legacy)\n  } else {\n    var check = [key];\n\n    if (keyType) {\n      check.push(Buffer.from(keyType));\n    }\n\n    newCheck = hash.ripemd160(Buffer.concat(check)).slice(0, 4); //PVT\n  }\n\n  if (checksum.toString() !== newCheck.toString()) {\n    throw new Error('Invalid checksum, ' + (checksum.toString('hex') + ' != ' + newCheck.toString('hex')));\n  }\n\n  return key;\n}","map":null,"metadata":{},"sourceType":"script"}