{"ast":null,"code":"\"use strict\";\n/**\n * @module Serialize\n */\n// copyright defined in eosjs/LICENSE.txt\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numeric = require(\"./eosjs-numeric\");\n/** State for serialize() and deserialize() */\n\n\nvar SerializerState =\n/** @class */\nfunction () {\n  function SerializerState(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    /** Have any binary extensions been skipped? */\n\n\n    this.skippedBinaryExtension = false;\n    this.options = options;\n  }\n\n  return SerializerState;\n}();\n\nexports.SerializerState = SerializerState;\n/** Serialize and deserialize data */\n\nvar SerialBuffer =\n/** @class */\nfunction () {\n  /**\n   * @param __namedParameters\n   *    * `array`: `null` if serializing, or binary data to deserialize\n   *    * `textEncoder`: `TextEncoder` instance to use. Pass in `null` if running in a browser\n   *    * `textDecoder`: `TextDecider` instance to use. Pass in `null` if running in a browser\n   */\n  function SerialBuffer(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        textEncoder = _b.textEncoder,\n        textDecoder = _b.textDecoder,\n        array = _b.array;\n    /** Current position while reading (deserializing) */\n\n\n    this.readPos = 0;\n    this.array = array || new Uint8Array(1024);\n    this.length = array ? array.length : 0;\n    this.textEncoder = textEncoder || new TextEncoder();\n    this.textDecoder = textDecoder || new TextDecoder('utf-8', {\n      fatal: true\n    });\n  }\n  /** Resize `array` if needed to have at least `size` bytes free */\n\n\n  SerialBuffer.prototype.reserve = function (size) {\n    if (this.length + size <= this.array.length) {\n      return;\n    }\n\n    var l = this.array.length;\n\n    while (this.length + size > l) {\n      l = Math.ceil(l * 1.5);\n    }\n\n    var newArray = new Uint8Array(l);\n    newArray.set(this.array);\n    this.array = newArray;\n  };\n  /** Is there data available to read? */\n\n\n  SerialBuffer.prototype.haveReadData = function () {\n    return this.readPos < this.length;\n  };\n  /** Restart reading from the beginning */\n\n\n  SerialBuffer.prototype.restartRead = function () {\n    this.readPos = 0;\n  };\n  /** Return data with excess storage trimmed away */\n\n\n  SerialBuffer.prototype.asUint8Array = function () {\n    return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);\n  };\n  /** Append bytes */\n\n\n  SerialBuffer.prototype.pushArray = function (v) {\n    this.reserve(v.length);\n    this.array.set(v, this.length);\n    this.length += v.length;\n  };\n  /** Append bytes */\n\n\n  SerialBuffer.prototype.push = function () {\n    var v = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      v[_i] = arguments[_i];\n    }\n\n    this.pushArray(v);\n  };\n  /** Get a single byte */\n\n\n  SerialBuffer.prototype.get = function () {\n    if (this.readPos < this.length) {\n      return this.array[this.readPos++];\n    }\n\n    throw new Error('Read past end of buffer');\n  };\n  /** Append bytes in `v`. Throws if `len` doesn't match `v.length` */\n\n\n  SerialBuffer.prototype.pushUint8ArrayChecked = function (v, len) {\n    if (v.length !== len) {\n      throw new Error('Binary data has incorrect size');\n    }\n\n    this.pushArray(v);\n  };\n  /** Get `len` bytes */\n\n\n  SerialBuffer.prototype.getUint8Array = function (len) {\n    if (this.readPos + len > this.length) {\n      throw new Error('Read past end of buffer');\n    }\n\n    var result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);\n    this.readPos += len;\n    return result;\n  };\n  /** Append a `uint16` */\n\n\n  SerialBuffer.prototype.pushUint16 = function (v) {\n    this.push(v >> 0 & 0xff, v >> 8 & 0xff);\n  };\n  /** Get a `uint16` */\n\n\n  SerialBuffer.prototype.getUint16 = function () {\n    var v = 0;\n    v |= this.get() << 0;\n    v |= this.get() << 8;\n    return v;\n  };\n  /** Append a `uint32` */\n\n\n  SerialBuffer.prototype.pushUint32 = function (v) {\n    this.push(v >> 0 & 0xff, v >> 8 & 0xff, v >> 16 & 0xff, v >> 24 & 0xff);\n  };\n  /** Get a `uint32` */\n\n\n  SerialBuffer.prototype.getUint32 = function () {\n    var v = 0;\n    v |= this.get() << 0;\n    v |= this.get() << 8;\n    v |= this.get() << 16;\n    v |= this.get() << 24;\n    return v >>> 0;\n  };\n  /** Append a `uint64`. *Caution*: `number` only has 53 bits of precision */\n\n\n  SerialBuffer.prototype.pushNumberAsUint64 = function (v) {\n    this.pushUint32(v >>> 0);\n    this.pushUint32(Math.floor(v / 4294967296) >>> 0);\n  };\n  /**\n   * Get a `uint64` as a `number`. *Caution*: `number` only has 53 bits of precision; some values will change.\n   * `numeric.binaryToDecimal(serialBuffer.getUint8Array(8))` recommended instead\n   */\n\n\n  SerialBuffer.prototype.getUint64AsNumber = function () {\n    var low = this.getUint32();\n    var high = this.getUint32();\n    return (high >>> 0) * 4294967296 + (low >>> 0);\n  };\n  /** Append a `varuint32` */\n\n\n  SerialBuffer.prototype.pushVaruint32 = function (v) {\n    while (true) {\n      if (v >>> 7) {\n        this.push(0x80 | v & 0x7f);\n        v = v >>> 7;\n      } else {\n        this.push(v);\n        break;\n      }\n    }\n  };\n  /** Get a `varuint32` */\n\n\n  SerialBuffer.prototype.getVaruint32 = function () {\n    var v = 0;\n    var bit = 0;\n\n    while (true) {\n      var b = this.get();\n      v |= (b & 0x7f) << bit;\n      bit += 7;\n\n      if (!(b & 0x80)) {\n        break;\n      }\n    }\n\n    return v >>> 0;\n  };\n  /** Append a `varint32` */\n\n\n  SerialBuffer.prototype.pushVarint32 = function (v) {\n    this.pushVaruint32(v << 1 ^ v >> 31);\n  };\n  /** Get a `varint32` */\n\n\n  SerialBuffer.prototype.getVarint32 = function () {\n    var v = this.getVaruint32();\n\n    if (v & 1) {\n      return ~v >> 1 | 2147483648;\n    } else {\n      return v >>> 1;\n    }\n  };\n  /** Append a `float32` */\n\n\n  SerialBuffer.prototype.pushFloat32 = function (v) {\n    this.pushArray(new Uint8Array(new Float32Array([v]).buffer));\n  };\n  /** Get a `float32` */\n\n\n  SerialBuffer.prototype.getFloat32 = function () {\n    return new Float32Array(this.getUint8Array(4).slice().buffer)[0];\n  };\n  /** Append a `float64` */\n\n\n  SerialBuffer.prototype.pushFloat64 = function (v) {\n    this.pushArray(new Uint8Array(new Float64Array([v]).buffer));\n  };\n  /** Get a `float64` */\n\n\n  SerialBuffer.prototype.getFloat64 = function () {\n    return new Float64Array(this.getUint8Array(8).slice().buffer)[0];\n  };\n  /** Append a `name` */\n\n\n  SerialBuffer.prototype.pushName = function (s) {\n    if (typeof s !== 'string') {\n      throw new Error('Expected string containing name');\n    }\n\n    function charToSymbol(c) {\n      if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {\n        return c - 'a'.charCodeAt(0) + 6;\n      }\n\n      if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {\n        return c - '1'.charCodeAt(0) + 1;\n      }\n\n      return 0;\n    }\n\n    var a = new Uint8Array(8);\n    var bit = 63;\n\n    for (var i = 0; i < s.length; ++i) {\n      var c = charToSymbol(s.charCodeAt(i));\n\n      if (bit < 5) {\n        c = c << 1;\n      }\n\n      for (var j = 4; j >= 0; --j) {\n        if (bit >= 0) {\n          a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;\n          --bit;\n        }\n      }\n    }\n\n    this.pushArray(a);\n  };\n  /** Get a `name` */\n\n\n  SerialBuffer.prototype.getName = function () {\n    var a = this.getUint8Array(8);\n    var result = '';\n\n    for (var bit = 63; bit >= 0;) {\n      var c = 0;\n\n      for (var i = 0; i < 5; ++i) {\n        if (bit >= 0) {\n          c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;\n          --bit;\n        }\n      }\n\n      if (c >= 6) {\n        result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);\n      } else if (c >= 1) {\n        result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);\n      } else {\n        result += '.';\n      }\n    }\n\n    while (result.endsWith('.')) {\n      result = result.substr(0, result.length - 1);\n    }\n\n    return result;\n  };\n  /** Append length-prefixed binary data */\n\n\n  SerialBuffer.prototype.pushBytes = function (v) {\n    this.pushVaruint32(v.length);\n    this.pushArray(v);\n  };\n  /** Get length-prefixed binary data */\n\n\n  SerialBuffer.prototype.getBytes = function () {\n    return this.getUint8Array(this.getVaruint32());\n  };\n  /** Append a string */\n\n\n  SerialBuffer.prototype.pushString = function (v) {\n    this.pushBytes(this.textEncoder.encode(v));\n  };\n  /** Get a string */\n\n\n  SerialBuffer.prototype.getString = function () {\n    return this.textDecoder.decode(this.getBytes());\n  };\n  /** Append a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */\n\n\n  SerialBuffer.prototype.pushSymbolCode = function (name) {\n    if (typeof name !== 'string') {\n      throw new Error('Expected string containing symbol_code');\n    }\n\n    var a = [];\n    a.push.apply(a, __spread(this.textEncoder.encode(name)));\n\n    while (a.length < 8) {\n      a.push(0);\n    }\n\n    this.pushArray(a.slice(0, 8));\n  };\n  /** Get a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */\n\n\n  SerialBuffer.prototype.getSymbolCode = function () {\n    var a = this.getUint8Array(8);\n    var len;\n\n    for (len = 0; len < a.length; ++len) {\n      if (!a[len]) {\n        break;\n      }\n    }\n\n    var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));\n    return name;\n  };\n  /** Append a `symbol` */\n\n\n  SerialBuffer.prototype.pushSymbol = function (_a) {\n    var name = _a.name,\n        precision = _a.precision;\n    var a = [precision & 0xff];\n    a.push.apply(a, __spread(this.textEncoder.encode(name)));\n\n    while (a.length < 8) {\n      a.push(0);\n    }\n\n    this.pushArray(a.slice(0, 8));\n  };\n  /** Get a `symbol` */\n\n\n  SerialBuffer.prototype.getSymbol = function () {\n    var precision = this.get();\n    var a = this.getUint8Array(7);\n    var len;\n\n    for (len = 0; len < a.length; ++len) {\n      if (!a[len]) {\n        break;\n      }\n    }\n\n    var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));\n    return {\n      name: name,\n      precision: precision\n    };\n  };\n  /** Append an asset */\n\n\n  SerialBuffer.prototype.pushAsset = function (s) {\n    if (typeof s !== 'string') {\n      throw new Error('Expected string containing asset');\n    }\n\n    s = s.trim();\n    var pos = 0;\n    var amount = '';\n    var precision = 0;\n\n    if (s[pos] === '-') {\n      amount += '-';\n      ++pos;\n    }\n\n    var foundDigit = false;\n\n    while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {\n      foundDigit = true;\n      amount += s[pos];\n      ++pos;\n    }\n\n    if (!foundDigit) {\n      throw new Error('Asset must begin with a number');\n    }\n\n    if (s[pos] === '.') {\n      ++pos;\n\n      while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {\n        amount += s[pos];\n        ++precision;\n        ++pos;\n      }\n    }\n\n    var name = s.substr(pos).trim();\n    this.pushArray(numeric.signedDecimalToBinary(8, amount));\n    this.pushSymbol({\n      name: name,\n      precision: precision\n    });\n  };\n  /** Get an asset */\n\n\n  SerialBuffer.prototype.getAsset = function () {\n    var amount = this.getUint8Array(8);\n\n    var _a = this.getSymbol(),\n        name = _a.name,\n        precision = _a.precision;\n\n    var s = numeric.signedBinaryToDecimal(amount, precision + 1);\n\n    if (precision) {\n      s = s.substr(0, s.length - precision) + '.' + s.substr(s.length - precision);\n    }\n\n    return s + ' ' + name;\n  };\n  /** Append a public key */\n\n\n  SerialBuffer.prototype.pushPublicKey = function (s) {\n    var key = numeric.stringToPublicKey(s);\n    this.push(key.type);\n    this.pushArray(key.data);\n  };\n  /** Get a public key */\n\n\n  SerialBuffer.prototype.getPublicKey = function () {\n    var type = this.get();\n    var data = this.getUint8Array(numeric.publicKeyDataSize);\n    return numeric.publicKeyToString({\n      type: type,\n      data: data\n    });\n  };\n  /** Append a private key */\n\n\n  SerialBuffer.prototype.pushPrivateKey = function (s) {\n    var key = numeric.stringToPrivateKey(s);\n    this.push(key.type);\n    this.pushArray(key.data);\n  };\n  /** Get a private key */\n\n\n  SerialBuffer.prototype.getPrivateKey = function () {\n    var type = this.get();\n    var data = this.getUint8Array(numeric.privateKeyDataSize);\n    return numeric.privateKeyToString({\n      type: type,\n      data: data\n    });\n  };\n  /** Append a signature */\n\n\n  SerialBuffer.prototype.pushSignature = function (s) {\n    var key = numeric.stringToSignature(s);\n    this.push(key.type);\n    this.pushArray(key.data);\n  };\n  /** Get a signature */\n\n\n  SerialBuffer.prototype.getSignature = function () {\n    var type = this.get();\n    var data = this.getUint8Array(numeric.signatureDataSize);\n    return numeric.signatureToString({\n      type: type,\n      data: data\n    });\n  };\n\n  return SerialBuffer;\n}(); // SerialBuffer\n\n\nexports.SerialBuffer = SerialBuffer;\n/** Is this a supported ABI version? */\n\nfunction supportedAbiVersion(version) {\n  return version.startsWith('eosio::abi/1.');\n}\n\nexports.supportedAbiVersion = supportedAbiVersion;\n\nfunction checkDateParse(date) {\n  var result = Date.parse(date);\n\n  if (Number.isNaN(result)) {\n    throw new Error('Invalid time format');\n  }\n\n  return result;\n}\n/** Convert date in ISO format to `time_point` (miliseconds since epoch) */\n\n\nfunction dateToTimePoint(date) {\n  return Math.round(checkDateParse(date + 'Z') * 1000);\n}\n\nexports.dateToTimePoint = dateToTimePoint;\n/** Convert `time_point` (miliseconds since epoch) to date in ISO format */\n\nfunction timePointToDate(us) {\n  var s = new Date(us / 1000).toISOString();\n  return s.substr(0, s.length - 1);\n}\n\nexports.timePointToDate = timePointToDate;\n/** Convert date in ISO format to `time_point_sec` (seconds since epoch) */\n\nfunction dateToTimePointSec(date) {\n  return Math.round(checkDateParse(date + 'Z') / 1000);\n}\n\nexports.dateToTimePointSec = dateToTimePointSec;\n/** Convert `time_point_sec` (seconds since epoch) to to date in ISO format */\n\nfunction timePointSecToDate(sec) {\n  var s = new Date(sec * 1000).toISOString();\n  return s.substr(0, s.length - 1);\n}\n\nexports.timePointSecToDate = timePointSecToDate;\n/** Convert date in ISO format to `block_timestamp_type` (half-seconds since a different epoch) */\n\nfunction dateToBlockTimestamp(date) {\n  return Math.round((checkDateParse(date + 'Z') - 946684800000) / 500);\n}\n\nexports.dateToBlockTimestamp = dateToBlockTimestamp;\n/** Convert `block_timestamp_type` (half-seconds since a different epoch) to to date in ISO format */\n\nfunction blockTimestampToDate(slot) {\n  var s = new Date(slot * 500 + 946684800000).toISOString();\n  return s.substr(0, s.length - 1);\n}\n\nexports.blockTimestampToDate = blockTimestampToDate;\n/** Convert `string` to `Symbol`. format: `precision,NAME`. */\n\nfunction stringToSymbol(s) {\n  if (typeof s !== 'string') {\n    throw new Error('Expected string containing symbol');\n  }\n\n  var m = s.match(/^([0-9]+),([A-Z]+)$/);\n\n  if (!m) {\n    throw new Error('Invalid symbol');\n  }\n\n  return {\n    name: m[2],\n    precision: +m[1]\n  };\n}\n\nexports.stringToSymbol = stringToSymbol;\n/** Convert `Symbol` to `string`. format: `precision,NAME`. */\n\nfunction symbolToString(_a) {\n  var name = _a.name,\n      precision = _a.precision;\n  return precision + ',' + name;\n}\n\nexports.symbolToString = symbolToString;\n/** Convert binary data to hex */\n\nfunction arrayToHex(data) {\n  var e_1, _a;\n\n  var result = '';\n\n  try {\n    for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {\n      var x = data_1_1.value;\n      result += ('00' + x.toString(16)).slice(-2);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return result.toUpperCase();\n}\n\nexports.arrayToHex = arrayToHex;\n/** Convert hex to binary data */\n\nfunction hexToUint8Array(hex) {\n  if (typeof hex !== 'string') {\n    throw new Error('Expected string containing hex digits');\n  }\n\n  if (hex.length % 2) {\n    throw new Error('Odd number of hex digits');\n  }\n\n  var l = hex.length / 2;\n  var result = new Uint8Array(l);\n\n  for (var i = 0; i < l; ++i) {\n    var x = parseInt(hex.substr(i * 2, 2), 16);\n\n    if (Number.isNaN(x)) {\n      throw new Error('Expected hex string');\n    }\n\n    result[i] = x;\n  }\n\n  return result;\n}\n\nexports.hexToUint8Array = hexToUint8Array;\n\nfunction serializeUnknown(buffer, data) {\n  throw new Error('Don\\'t know how to serialize ' + this.name);\n}\n\nfunction deserializeUnknown(buffer) {\n  throw new Error('Don\\'t know how to deserialize ' + this.name);\n}\n\nfunction serializeStruct(buffer, data, state, allowExtensions) {\n  if (state === void 0) {\n    state = new SerializerState();\n  }\n\n  if (allowExtensions === void 0) {\n    allowExtensions = true;\n  }\n\n  var e_2, _a;\n\n  if (typeof data !== 'object') {\n    throw new Error('expected object containing data: ' + JSON.stringify(data));\n  }\n\n  if (this.base) {\n    this.base.serialize(buffer, data, state, allowExtensions);\n  }\n\n  try {\n    for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var field = _c.value;\n\n      if (field.name in data) {\n        if (state.skippedBinaryExtension) {\n          throw new Error('unexpected ' + this.name + '.' + field.name);\n        }\n\n        field.type.serialize(buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);\n      } else {\n        if (allowExtensions && field.type.extensionOf) {\n          state.skippedBinaryExtension = true;\n        } else {\n          throw new Error('missing ' + this.name + '.' + field.name + ' (type=' + field.type.name + ')');\n        }\n      }\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n}\n\nfunction deserializeStruct(buffer, state, allowExtensions) {\n  if (state === void 0) {\n    state = new SerializerState();\n  }\n\n  if (allowExtensions === void 0) {\n    allowExtensions = true;\n  }\n\n  var e_3, _a;\n\n  var result;\n\n  if (this.base) {\n    result = this.base.deserialize(buffer, state, allowExtensions);\n  } else {\n    result = {};\n  }\n\n  try {\n    for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var field = _c.value;\n\n      if (allowExtensions && field.type.extensionOf && !buffer.haveReadData()) {\n        state.skippedBinaryExtension = true;\n      } else {\n        result[field.name] = field.type.deserialize(buffer, state, allowExtensions);\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return result;\n}\n\nfunction serializeVariant(buffer, data, state, allowExtensions) {\n  if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== 'string') {\n    throw new Error('expected variant: [\"type\", value]');\n  }\n\n  var i = this.fields.findIndex(function (field) {\n    return field.name === data[0];\n  });\n\n  if (i < 0) {\n    throw new Error(\"type \\\"\" + data[0] + \"\\\" is not valid for variant\");\n  }\n\n  buffer.pushVaruint32(i);\n  this.fields[i].type.serialize(buffer, data[1], state, allowExtensions);\n}\n\nfunction deserializeVariant(buffer, state, allowExtensions) {\n  var i = buffer.getVaruint32();\n\n  if (i >= this.fields.length) {\n    throw new Error(\"type index \" + i + \" is not valid for variant\");\n  }\n\n  var field = this.fields[i];\n  return [field.name, field.type.deserialize(buffer, state, allowExtensions)];\n}\n\nfunction serializeArray(buffer, data, state, allowExtensions) {\n  var e_4, _a;\n\n  buffer.pushVaruint32(data.length);\n\n  try {\n    for (var data_2 = __values(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {\n      var item = data_2_1.value;\n      this.arrayOf.serialize(buffer, item, state, false);\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (data_2_1 && !data_2_1.done && (_a = data_2.return)) _a.call(data_2);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n}\n\nfunction deserializeArray(buffer, state, allowExtensions) {\n  var len = buffer.getVaruint32();\n  var result = [];\n\n  for (var i = 0; i < len; ++i) {\n    result.push(this.arrayOf.deserialize(buffer, state, false));\n  }\n\n  return result;\n}\n\nfunction serializeOptional(buffer, data, state, allowExtensions) {\n  if (data === null || data === undefined) {\n    buffer.push(0);\n  } else {\n    buffer.push(1);\n    this.optionalOf.serialize(buffer, data, state, allowExtensions);\n  }\n}\n\nfunction deserializeOptional(buffer, state, allowExtensions) {\n  if (buffer.get()) {\n    return this.optionalOf.deserialize(buffer, state, allowExtensions);\n  } else {\n    return null;\n  }\n}\n\nfunction serializeExtension(buffer, data, state, allowExtensions) {\n  this.extensionOf.serialize(buffer, data, state, allowExtensions);\n}\n\nfunction deserializeExtension(buffer, state, allowExtensions) {\n  return this.extensionOf.deserialize(buffer, state, allowExtensions);\n}\n\nfunction createType(attrs) {\n  return __assign({\n    name: '<missing name>',\n    aliasOfName: '',\n    arrayOf: null,\n    optionalOf: null,\n    extensionOf: null,\n    baseName: '',\n    base: null,\n    fields: [],\n    serialize: serializeUnknown,\n    deserialize: deserializeUnknown\n  }, attrs);\n}\n\nfunction checkRange(orig, converted) {\n  if (Number.isNaN(+orig) || Number.isNaN(+converted) || typeof orig !== 'number' && typeof orig !== 'string') {\n    throw new Error('Expected number');\n  }\n\n  if (+orig !== +converted) {\n    throw new Error('Number is out of range');\n  }\n\n  return +orig;\n}\n/** Create the set of types built-in to the abi format */\n\n\nfunction createInitialTypes() {\n  var result = new Map(Object.entries({\n    bool: createType({\n      name: 'bool',\n      serialize: function serialize(buffer, data) {\n        if (typeof data !== 'boolean') {\n          throw new Error('Expected true or false');\n        }\n\n        buffer.push(data ? 1 : 0);\n      },\n      deserialize: function deserialize(buffer) {\n        return !!buffer.get();\n      }\n    }),\n    uint8: createType({\n      name: 'uint8',\n      serialize: function serialize(buffer, data) {\n        buffer.push(checkRange(data, data & 0xff));\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.get();\n      }\n    }),\n    int8: createType({\n      name: 'int8',\n      serialize: function serialize(buffer, data) {\n        buffer.push(checkRange(data, data << 24 >> 24));\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.get() << 24 >> 24;\n      }\n    }),\n    uint16: createType({\n      name: 'uint16',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint16(checkRange(data, data & 0xffff));\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getUint16();\n      }\n    }),\n    int16: createType({\n      name: 'int16',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint16(checkRange(data, data << 16 >> 16));\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getUint16() << 16 >> 16;\n      }\n    }),\n    uint32: createType({\n      name: 'uint32',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint32(checkRange(data, data >>> 0));\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getUint32();\n      }\n    }),\n    uint64: createType({\n      name: 'uint64',\n      serialize: function serialize(buffer, data) {\n        buffer.pushArray(numeric.decimalToBinary(8, '' + data));\n      },\n      deserialize: function deserialize(buffer) {\n        return numeric.binaryToDecimal(buffer.getUint8Array(8));\n      }\n    }),\n    int64: createType({\n      name: 'int64',\n      serialize: function serialize(buffer, data) {\n        buffer.pushArray(numeric.signedDecimalToBinary(8, '' + data));\n      },\n      deserialize: function deserialize(buffer) {\n        return numeric.signedBinaryToDecimal(buffer.getUint8Array(8));\n      }\n    }),\n    int32: createType({\n      name: 'int32',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint32(checkRange(data, data | 0));\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getUint32() | 0;\n      }\n    }),\n    varuint32: createType({\n      name: 'varuint32',\n      serialize: function serialize(buffer, data) {\n        buffer.pushVaruint32(checkRange(data, data >>> 0));\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getVaruint32();\n      }\n    }),\n    varint32: createType({\n      name: 'varint32',\n      serialize: function serialize(buffer, data) {\n        buffer.pushVarint32(checkRange(data, data | 0));\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getVarint32();\n      }\n    }),\n    uint128: createType({\n      name: 'uint128',\n      serialize: function serialize(buffer, data) {\n        buffer.pushArray(numeric.decimalToBinary(16, '' + data));\n      },\n      deserialize: function deserialize(buffer) {\n        return numeric.binaryToDecimal(buffer.getUint8Array(16));\n      }\n    }),\n    int128: createType({\n      name: 'int128',\n      serialize: function serialize(buffer, data) {\n        buffer.pushArray(numeric.signedDecimalToBinary(16, '' + data));\n      },\n      deserialize: function deserialize(buffer) {\n        return numeric.signedBinaryToDecimal(buffer.getUint8Array(16));\n      }\n    }),\n    float32: createType({\n      name: 'float32',\n      serialize: function serialize(buffer, data) {\n        buffer.pushFloat32(data);\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getFloat32();\n      }\n    }),\n    float64: createType({\n      name: 'float64',\n      serialize: function serialize(buffer, data) {\n        buffer.pushFloat64(data);\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getFloat64();\n      }\n    }),\n    float128: createType({\n      name: 'float128',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16);\n      },\n      deserialize: function deserialize(buffer) {\n        return arrayToHex(buffer.getUint8Array(16));\n      }\n    }),\n    bytes: createType({\n      name: 'bytes',\n      serialize: function serialize(buffer, data) {\n        if (data instanceof Uint8Array || Array.isArray(data)) {\n          buffer.pushBytes(data);\n        } else {\n          buffer.pushBytes(hexToUint8Array(data));\n        }\n      },\n      deserialize: function deserialize(buffer, state) {\n        if (state && state.options.bytesAsUint8Array) {\n          return buffer.getBytes();\n        } else {\n          return arrayToHex(buffer.getBytes());\n        }\n      }\n    }),\n    string: createType({\n      name: 'string',\n      serialize: function serialize(buffer, data) {\n        buffer.pushString(data);\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getString();\n      }\n    }),\n    name: createType({\n      name: 'name',\n      serialize: function serialize(buffer, data) {\n        buffer.pushName(data);\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getName();\n      }\n    }),\n    time_point: createType({\n      name: 'time_point',\n      serialize: function serialize(buffer, data) {\n        buffer.pushNumberAsUint64(dateToTimePoint(data));\n      },\n      deserialize: function deserialize(buffer) {\n        return timePointToDate(buffer.getUint64AsNumber());\n      }\n    }),\n    time_point_sec: createType({\n      name: 'time_point_sec',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint32(dateToTimePointSec(data));\n      },\n      deserialize: function deserialize(buffer) {\n        return timePointSecToDate(buffer.getUint32());\n      }\n    }),\n    block_timestamp_type: createType({\n      name: 'block_timestamp_type',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint32(dateToBlockTimestamp(data));\n      },\n      deserialize: function deserialize(buffer) {\n        return blockTimestampToDate(buffer.getUint32());\n      }\n    }),\n    symbol_code: createType({\n      name: 'symbol_code',\n      serialize: function serialize(buffer, data) {\n        buffer.pushSymbolCode(data);\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getSymbolCode();\n      }\n    }),\n    symbol: createType({\n      name: 'symbol',\n      serialize: function serialize(buffer, data) {\n        buffer.pushSymbol(stringToSymbol(data));\n      },\n      deserialize: function deserialize(buffer) {\n        return symbolToString(buffer.getSymbol());\n      }\n    }),\n    asset: createType({\n      name: 'asset',\n      serialize: function serialize(buffer, data) {\n        buffer.pushAsset(data);\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getAsset();\n      }\n    }),\n    checksum160: createType({\n      name: 'checksum160',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20);\n      },\n      deserialize: function deserialize(buffer) {\n        return arrayToHex(buffer.getUint8Array(20));\n      }\n    }),\n    checksum256: createType({\n      name: 'checksum256',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32);\n      },\n      deserialize: function deserialize(buffer) {\n        return arrayToHex(buffer.getUint8Array(32));\n      }\n    }),\n    checksum512: createType({\n      name: 'checksum512',\n      serialize: function serialize(buffer, data) {\n        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64);\n      },\n      deserialize: function deserialize(buffer) {\n        return arrayToHex(buffer.getUint8Array(64));\n      }\n    }),\n    public_key: createType({\n      name: 'public_key',\n      serialize: function serialize(buffer, data) {\n        buffer.pushPublicKey(data);\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getPublicKey();\n      }\n    }),\n    private_key: createType({\n      name: 'private_key',\n      serialize: function serialize(buffer, data) {\n        buffer.pushPrivateKey(data);\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getPrivateKey();\n      }\n    }),\n    signature: createType({\n      name: 'signature',\n      serialize: function serialize(buffer, data) {\n        buffer.pushSignature(data);\n      },\n      deserialize: function deserialize(buffer) {\n        return buffer.getSignature();\n      }\n    })\n  }));\n  result.set('extended_asset', createType({\n    name: 'extended_asset',\n    baseName: '',\n    fields: [{\n      name: 'quantity',\n      typeName: 'asset',\n      type: result.get('asset')\n    }, {\n      name: 'contract',\n      typeName: 'name',\n      type: result.get('name')\n    }],\n    serialize: serializeStruct,\n    deserialize: deserializeStruct\n  }));\n  return result;\n} // createInitialTypes()\n\n\nexports.createInitialTypes = createInitialTypes;\n/** Get type from `types` */\n\nfunction getType(types, name) {\n  var type = types.get(name);\n\n  if (type && type.aliasOfName) {\n    return getType(types, type.aliasOfName);\n  }\n\n  if (type) {\n    return type;\n  }\n\n  if (name.endsWith('[]')) {\n    return createType({\n      name: name,\n      arrayOf: getType(types, name.substr(0, name.length - 2)),\n      serialize: serializeArray,\n      deserialize: deserializeArray\n    });\n  }\n\n  if (name.endsWith('?')) {\n    return createType({\n      name: name,\n      optionalOf: getType(types, name.substr(0, name.length - 1)),\n      serialize: serializeOptional,\n      deserialize: deserializeOptional\n    });\n  }\n\n  if (name.endsWith('$')) {\n    return createType({\n      name: name,\n      extensionOf: getType(types, name.substr(0, name.length - 1)),\n      serialize: serializeExtension,\n      deserialize: deserializeExtension\n    });\n  }\n\n  throw new Error('Unknown type: ' + name);\n}\n\nexports.getType = getType;\n/**\n * Get types from abi\n * @param initialTypes Set of types to build on.\n *     In most cases, it's best to fill this from a fresh call to `getTypesFromAbi()`.\n */\n\nfunction getTypesFromAbi(initialTypes, abi) {\n  var e_5, _a, e_6, _b, e_7, _c, e_8, _d, e_9, _e;\n\n  var types = new Map(initialTypes);\n\n  if (abi.types) {\n    try {\n      for (var _f = __values(abi.types), _g = _f.next(); !_g.done; _g = _f.next()) {\n        var _h = _g.value,\n            new_type_name = _h.new_type_name,\n            type = _h.type;\n        types.set(new_type_name, createType({\n          name: new_type_name,\n          aliasOfName: type\n        }));\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_g && !_g.done && (_a = _f.return)) _a.call(_f);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n  }\n\n  if (abi.structs) {\n    try {\n      for (var _j = __values(abi.structs), _k = _j.next(); !_k.done; _k = _j.next()) {\n        var _l = _k.value,\n            name_1 = _l.name,\n            base = _l.base,\n            fields = _l.fields;\n        types.set(name_1, createType({\n          name: name_1,\n          baseName: base,\n          fields: fields.map(function (_a) {\n            var n = _a.name,\n                type = _a.type;\n            return {\n              name: n,\n              typeName: type,\n              type: null\n            };\n          }),\n          serialize: serializeStruct,\n          deserialize: deserializeStruct\n        }));\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_k && !_k.done && (_b = _j.return)) _b.call(_j);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n  }\n\n  if (abi.variants) {\n    try {\n      for (var _m = __values(abi.variants), _o = _m.next(); !_o.done; _o = _m.next()) {\n        var _p = _o.value,\n            name_2 = _p.name,\n            t = _p.types;\n        types.set(name_2, createType({\n          name: name_2,\n          fields: t.map(function (s) {\n            return {\n              name: s,\n              typeName: s,\n              type: null\n            };\n          }),\n          serialize: serializeVariant,\n          deserialize: deserializeVariant\n        }));\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_o && !_o.done && (_c = _m.return)) _c.call(_m);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n  }\n\n  try {\n    for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {\n      var _q = __read(types_1_1.value, 2),\n          name_3 = _q[0],\n          type = _q[1];\n\n      if (type.baseName) {\n        type.base = getType(types, type.baseName);\n      }\n\n      try {\n        for (var _r = __values(type.fields), _s = _r.next(); !_s.done; _s = _r.next()) {\n          var field = _s.value;\n          field.type = getType(types, field.typeName);\n        }\n      } catch (e_9_1) {\n        e_9 = {\n          error: e_9_1\n        };\n      } finally {\n        try {\n          if (_s && !_s.done && (_e = _r.return)) _e.call(_r);\n        } finally {\n          if (e_9) throw e_9.error;\n        }\n      }\n    }\n  } catch (e_8_1) {\n    e_8 = {\n      error: e_8_1\n    };\n  } finally {\n    try {\n      if (types_1_1 && !types_1_1.done && (_d = types_1.return)) _d.call(types_1);\n    } finally {\n      if (e_8) throw e_8.error;\n    }\n  }\n\n  return types;\n} // getTypesFromAbi\n\n\nexports.getTypesFromAbi = getTypesFromAbi;\n/** TAPoS: Return transaction fields which reference `refBlock` and expire `expireSeconds` after `refBlock.timestamp` */\n\nfunction transactionHeader(refBlock, expireSeconds) {\n  return {\n    expiration: timePointSecToDate(dateToTimePointSec(refBlock.timestamp) + expireSeconds),\n    ref_block_num: refBlock.block_num & 0xffff,\n    ref_block_prefix: refBlock.ref_block_prefix\n  };\n}\n\nexports.transactionHeader = transactionHeader;\n/** Convert action data to serialized form (hex) */\n\nfunction serializeActionData(contract, account, name, data, textEncoder, textDecoder) {\n  var action = contract.actions.get(name);\n\n  if (!action) {\n    throw new Error(\"Unknown action \" + name + \" in contract \" + account);\n  }\n\n  var buffer = new SerialBuffer({\n    textEncoder: textEncoder,\n    textDecoder: textDecoder\n  });\n  action.serialize(buffer, data);\n  return arrayToHex(buffer.asUint8Array());\n}\n\nexports.serializeActionData = serializeActionData;\n/** Return action in serialized form */\n\nfunction serializeAction(contract, account, name, authorization, data, textEncoder, textDecoder) {\n  return {\n    account: account,\n    name: name,\n    authorization: authorization,\n    data: serializeActionData(contract, account, name, data, textEncoder, textDecoder)\n  };\n}\n\nexports.serializeAction = serializeAction;\n/** Deserialize action data. If `data` is a `string`, then it's assumed to be in hex. */\n\nfunction deserializeActionData(contract, account, name, data, textEncoder, textDecoder) {\n  var action = contract.actions.get(name);\n\n  if (typeof data === 'string') {\n    data = hexToUint8Array(data);\n  }\n\n  if (!action) {\n    throw new Error(\"Unknown action \" + name + \" in contract \" + account);\n  }\n\n  var buffer = new SerialBuffer({\n    textDecoder: textDecoder,\n    textEncoder: textEncoder\n  });\n  buffer.pushArray(data);\n  return action.deserialize(buffer);\n}\n\nexports.deserializeActionData = deserializeActionData;\n/** Deserialize action. If `data` is a `string`, then it's assumed to be in hex. */\n\nfunction deserializeAction(contract, account, name, authorization, data, textEncoder, textDecoder) {\n  return {\n    account: account,\n    name: name,\n    authorization: authorization,\n    data: deserializeActionData(contract, account, name, data, textEncoder, textDecoder)\n  };\n}\n\nexports.deserializeAction = deserializeAction;","map":null,"metadata":{},"sourceType":"script"}