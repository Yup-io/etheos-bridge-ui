{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nvar BN = require('bn.js');\n\nvar _require = require('bytebuffer'),\n    Long = _require.Long;\n\nvar assert = require('assert');\n\nvar types = {\n  bytes: function bytes() {\n    return [bytebuf];\n  },\n  string: function string() {\n    return [_string];\n  },\n  vector: function vector(type) {\n    var sorted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return [_vector, {\n      type: type,\n      sorted: sorted\n    }];\n  },\n  optional: function optional(type) {\n    return [_optional, {\n      type: type\n    }];\n  },\n  time: function time() {\n    return [_time2];\n  },\n  map: function map(annotation) {\n    return [_map, {\n      annotation: annotation\n    }];\n  },\n  static_variant: function static_variant(types) {\n    return [_static_variant, {\n      types: types\n    }];\n  },\n  fixed_string16: function fixed_string16() {\n    return [_string, {\n      maxLen: 16\n    }];\n  },\n  fixed_string32: function fixed_string32() {\n    return [_string, {\n      maxLen: 32\n    }];\n  },\n  fixed_bytes16: function fixed_bytes16() {\n    return [bytebuf, {\n      len: 16\n    }];\n  },\n  fixed_bytes20: function fixed_bytes20() {\n    return [bytebuf, {\n      len: 20\n    }];\n  },\n  fixed_bytes28: function fixed_bytes28() {\n    return [bytebuf, {\n      len: 28\n    }];\n  },\n  fixed_bytes32: function fixed_bytes32() {\n    return [bytebuf, {\n      len: 32\n    }];\n  },\n  fixed_bytes33: function fixed_bytes33() {\n    return [bytebuf, {\n      len: 33\n    }];\n  },\n  fixed_bytes64: function fixed_bytes64() {\n    return [bytebuf, {\n      len: 64\n    }];\n  },\n  fixed_bytes65: function fixed_bytes65() {\n    return [bytebuf, {\n      len: 65\n    }];\n  },\n  uint8: function uint8() {\n    return [intbuf, {\n      bits: 8\n    }];\n  },\n  uint16: function uint16() {\n    return [intbuf, {\n      bits: 16\n    }];\n  },\n  uint32: function uint32() {\n    return [intbuf, {\n      bits: 32\n    }];\n  },\n  uint64: function uint64() {\n    return [intbuf, {\n      bits: 64\n    }];\n  },\n  uint128: function uint128() {\n    return [bnbuf, {\n      bits: 128\n    }];\n  },\n  uint224: function uint224() {\n    return [bnbuf, {\n      bits: 224\n    }];\n  },\n  uint256: function uint256() {\n    return [bnbuf, {\n      bits: 256\n    }];\n  },\n  uint512: function uint512() {\n    return [bnbuf, {\n      bits: 512\n    }];\n  },\n  varuint32: function varuint32() {\n    return [intbuf, {\n      bits: 32,\n      variable: true\n    }];\n  },\n  int8: function int8() {\n    return [intbuf, {\n      signed: true,\n      bits: 8\n    }];\n  },\n  int16: function int16() {\n    return [intbuf, {\n      signed: true,\n      bits: 16\n    }];\n  },\n  int32: function int32() {\n    return [intbuf, {\n      signed: true,\n      bits: 32\n    }];\n  },\n  int64: function int64() {\n    return [intbuf, {\n      signed: true,\n      bits: 64\n    }];\n  },\n  int128: function int128() {\n    return [bnbuf, {\n      signed: true,\n      bits: 128\n    }];\n  },\n  int224: function int224() {\n    return [bnbuf, {\n      signed: true,\n      bits: 224\n    }];\n  },\n  int256: function int256() {\n    return [bnbuf, {\n      signed: true,\n      bits: 256\n    }];\n  },\n  int512: function int512() {\n    return [bnbuf, {\n      signed: true,\n      bits: 512\n    }];\n  },\n  varint32: function varint32() {\n    return [intbuf, {\n      signed: true,\n      bits: 32,\n      variable: true\n    }];\n  },\n  float32: function float32() {\n    return [float, {\n      bits: 32\n    }];\n  },\n  float64: function float64() {\n    return [float, {\n      bits: 64\n    }];\n  }\n  /*\n    @arg {SerializerConfig} config\n    @return {object} {[typeName]: function(args)}\n  */\n\n};\n\nmodule.exports = function (config) {\n  config = Object.assign({\n    defaults: false,\n    debug: false,\n    customTypes: {}\n  }, config);\n  var allTypes = Object.assign({}, types, config.customTypes);\n\n  var createTypeReducer = function createTypeReducer(baseTypes) {\n    return function (customTypes, name) {\n      customTypes[name] = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var type = createType(name, config, args, baseTypes, allTypes, customTypes);\n        return type;\n      };\n\n      return customTypes;\n    };\n  };\n\n  var baseTypes = Object.keys(types).reduce(createTypeReducer(), {});\n  var customTypes = Object.keys(config.customTypes || {}).reduce(createTypeReducer(baseTypes), {});\n  return Object.assign({}, baseTypes, customTypes, {\n    config: config\n  });\n};\n/**\n    @args {string} typeName - matches types[]\n    @args {string} config - Additional arguments for types\n*/\n\n\nfunction createType(typeName, config, args, baseTypes, allTypes, customTypes) {\n  var Type = baseTypes ? allTypes[typeName] : types[typeName];\n\n  var _Type = Type.apply(undefined, _toConsumableArray(args)),\n      _Type2 = _slicedToArray(_Type, 2),\n      fn = _Type2[0],\n      _Type2$ = _Type2[1],\n      v = _Type2$ === undefined ? {} : _Type2$;\n\n  var validation = Object.assign(v, config);\n  validation.typeName = typeName;\n  var type = fn(validation, baseTypes, customTypes);\n  type.typeName = typeName;\n  return type;\n}\n\nvar _map = function _map(validation) {\n  var _validation$annotatio = _slicedToArray(validation.annotation, 2),\n      type1 = _validation$annotatio[0],\n      type2 = _validation$annotatio[1];\n\n  if (!isSerializer(type1)) {\n    throw new TypeError('map<type1, > unknown');\n  }\n\n  if (!isSerializer(type2)) {\n    throw new TypeError('map<, type2> unknown');\n  }\n\n  return {\n    fromByteBuffer: function fromByteBuffer(b) {\n      var size = b.readVarint32();\n      var result = {};\n\n      for (var i = 0; i < size; i++) {\n        result[type1.fromByteBuffer(b)] = type2.fromByteBuffer(b);\n      }\n\n      if (validation.debug) {\n        console.log('0x' + size.toString(16), '(map.fromByteBuffer length)', result);\n      }\n\n      return result;\n    },\n    appendByteBuffer: function appendByteBuffer(b, value) {\n      validate(value, validation);\n      var keys = Object.keys(value);\n      b.writeVarint32(keys.length);\n\n      if (validation.debug) {\n        console.log('0x' + keys.length.toString(16), '(map.appendByteBuffer length)', keys);\n      } // if(sorted === true) {\n      //   value = sortKeys(type1, Object.assign({}, value))\n      // }\n\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var o = _step.value;\n          var value2 = value[o];\n          type1.appendByteBuffer(b, o);\n          type2.appendByteBuffer(b, value2);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    },\n    fromObject: function fromObject(value) {\n      validate(value, validation);\n      var result = {}; // if(sorted === true) {\n      //   value = sortKeys(type1, Object.assign({}, value))\n      // }\n\n      for (var o in value) {\n        result[type1.fromObject(o)] = type2.fromObject(value[o]);\n      }\n\n      return result;\n    },\n    toObject: function toObject(value) {\n      if (validation.defaults && value == null) {\n        return _defineProperty({}, type1.toObject(null), type2.toObject(null));\n      }\n\n      validate(value, validation);\n      var result = {}; // if(sorted === true) {\n      //   value = sortKey(type1, Object.assign({}, value))\n      // }\n\n      for (var o in value) {\n        result[type1.toObject(o)] = type2.toObject(value[o]);\n      }\n\n      return result;\n    }\n  };\n};\n\nvar _static_variant = function _static_variant(validation) {\n  var types = validation.types;\n  return {\n    fromByteBuffer: function fromByteBuffer(b) {\n      var typePosition = b.readVarint32();\n      var type = types[typePosition];\n\n      if (validation.debug) {\n        console.error('static_variant id ' + typePosition + ' (0x' + typePosition.toString(16) + ')');\n      }\n\n      assert(type, 'static_variant invalid type position ' + typePosition);\n      return [typePosition, type.fromByteBuffer(b)];\n    },\n    appendByteBuffer: function appendByteBuffer(b, object) {\n      assert(Array.isArray(object) && object.length === 2, 'Required tuple');\n      var typePosition = object[0];\n      var type = types[typePosition];\n      assert(type, 'type ' + typePosition);\n      b.writeVarint32(typePosition);\n      type.appendByteBuffer(b, object[1]);\n    },\n    fromObject: function fromObject(object) {\n      assert(Array.isArray(object) && object.length === 2, 'Required tuple');\n      var typePosition = object[0];\n      var type = types[typePosition];\n      assert(type, 'type ' + typePosition);\n      return [typePosition, type.fromObject(object[1])];\n    },\n    toObject: function toObject(object) {\n      if (validation.defaults && object == null) {\n        return [0, types[0].toObject(null, debug)];\n      }\n\n      assert(Array.isArray(object) && object.length === 2, 'Required tuple');\n      var typePosition = object[0];\n      var type = types[typePosition];\n      assert(type, 'type ' + typePosition);\n      return [typePosition, type.toObject(object[1])];\n    }\n  };\n};\n\nvar _vector = function _vector(validation) {\n  var type = validation.type,\n      sorted = validation.sorted;\n\n  if (!isSerializer(type)) {\n    throw new TypeError('vector type should be a serializer');\n  }\n\n  return {\n    fromByteBuffer: function fromByteBuffer(b) {\n      var size = b.readVarint32();\n\n      if (validation.debug) {\n        console.log('fromByteBuffer vector length', size, '(0x' + size.toString(16) + ')');\n      }\n\n      var result = [];\n\n      for (var i = 0; i < size; i++) {\n        result.push(type.fromByteBuffer(b));\n      }\n\n      return result;\n    },\n    appendByteBuffer: function appendByteBuffer(b, value) {\n      if (value == null) {\n        value = [];\n      }\n\n      validate(value, validation);\n      b.writeVarint32(value.length);\n\n      if (sorted === true) {\n        value = sort(type, Object.assign([], value));\n      }\n\n      if (validation.debug) {\n        console.log('0x' + value.length.toString(16), '(vector.appendByteBuffer length)', value);\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var o = _step2.value;\n          type.appendByteBuffer(b, o);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    },\n    fromObject: function fromObject(value) {\n      if (value == null) {\n        value = [];\n      }\n\n      validate(value, validation);\n      var result = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var o = _step3.value;\n          result.push(type.fromObject(o));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      if (sorted === true) {\n        result = sort(type, Object.assign([], result));\n      }\n\n      return result;\n    },\n    toObject: function toObject(value) {\n      if (validation.defaults && value == null) {\n        return [type.toObject(value)];\n      }\n\n      if (value == null) {\n        value = [];\n      }\n\n      validate(value, validation);\n\n      if (sorted === true) {\n        value = sort(type, Object.assign([], value));\n      }\n\n      var result = [];\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = value[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var o = _step4.value;\n          result.push(type.toObject(o));\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return result;\n    }\n  };\n};\n\nvar _optional = function _optional(validation) {\n  var type = validation.type;\n\n  if (!isSerializer(type)) {\n    throw new TypeError('optional parameter should be a serializer');\n  }\n\n  return {\n    fromByteBuffer: function fromByteBuffer(b) {\n      if (!(b.readUint8() === 1)) {\n        return null;\n      }\n\n      return type.fromByteBuffer(b);\n    },\n    appendByteBuffer: function appendByteBuffer(b, value) {\n      if (value != null) {\n        b.writeUint8(1);\n        type.appendByteBuffer(b, value);\n      } else {\n        b.writeUint8(0);\n      }\n    },\n    fromObject: function fromObject(value) {\n      if (value == null) {\n        return null;\n      }\n\n      return type.fromObject(value);\n    },\n    toObject: function toObject(value) {\n      // toObject is only null save if defaults is true\n      var resultValue = void 0;\n\n      if (value == null && !validation.defaults) {\n        resultValue = null;\n      } else {\n        resultValue = type.toObject(value);\n      }\n\n      return resultValue;\n    }\n  };\n};\n\nvar intbufType = function intbufType(_ref2) {\n  var _ref2$signed = _ref2.signed,\n      signed = _ref2$signed === undefined ? false : _ref2$signed,\n      bits = _ref2.bits,\n      variable = _ref2.variable;\n  return variable ? 'Varint' + bits + (signed ? 'ZigZag' : '') : '' + (signed ? 'Int' : 'Uint') + bits;\n};\n\nvar intbuf = function intbuf(validation) {\n  return {\n    fromByteBuffer: function fromByteBuffer(b) {\n      var value = b['read' + intbufType(validation)]();\n      return Long.isLong(value) ? value.toString() : value;\n    },\n    appendByteBuffer: function appendByteBuffer(b, value) {\n      // validateInt(value, validation)\n      // value = typeof value === 'string' ? Long.fromString(value) : value\n      b['write' + intbufType(validation)](value);\n    },\n    fromObject: function fromObject(value) {\n      validateInt(value, validation); // if(validation.bits > 53 && typeof value === 'number')\n      //     value = String(value)\n\n      return value;\n    },\n    toObject: function toObject(value) {\n      if (validation.defaults && value == null) {\n        return validation.bits > 53 ? '0' : 0;\n      }\n\n      validateInt(value, validation); // if(validation.bits > 53 && typeof value === 'number')\n      //     value = String(value)\n\n      return Long.isLong(value) ? value.toString() : value;\n    }\n  };\n};\n/** Big Numbers (> 64 bits) */\n\n\nvar bnbuf = function bnbuf(validation) {\n  var _validation$signed = validation.signed,\n      signed = _validation$signed === undefined ? false : _validation$signed,\n      bits = validation.bits;\n  var size = bits / 8;\n  return {\n    fromByteBuffer: function fromByteBuffer(b) {\n      var bcopy = b.copy(b.offset, b.offset + size);\n      b.skip(size);\n      var bn = new BN(bcopy.toHex(), 'hex');\n      var buf = bn.toArrayLike(Buffer, 'le', size); // convert to little endian\n\n      bn = new BN(buf.toString('hex'), 'hex');\n\n      if (signed) {\n        bn = bn.fromTwos(bits);\n      }\n\n      var value = bn.toString();\n      validateInt(value, validation);\n      return bits > 53 ? value : bn.toNumber();\n    },\n    appendByteBuffer: function appendByteBuffer(b, value) {\n      validateInt(value, validation);\n      var bn = new BN(value);\n\n      if (signed) {\n        bn = bn.toTwos(bits);\n      }\n\n      var buf = bn.toArrayLike(Buffer, 'le', size);\n      b.append(buf.toString('binary'), 'binary');\n    },\n    fromObject: function fromObject(value) {\n      validateInt(value, validation);\n      return value;\n    },\n    toObject: function toObject(value) {\n      if (validation.defaults && value == null) {\n        return validation.bits > 53 ? '0' : 0;\n      }\n\n      validateInt(value, validation);\n      return value;\n    }\n  };\n};\n\nvar floatPoint = require('ieee-float');\n\nvar float = function float(validation) {\n  var bits = validation.bits; // assert(bits === 32 || bits === 64, 'unsupported float bit size: ' + bits)\n\n  var sizeName = bits === 32 ? 'Float' : bits === 64 ? 'Double' : null;\n  assert(sizeName, 'unsupported float bit size: ' + bits);\n  var size = bits / 8;\n  return {\n    fromByteBuffer: function fromByteBuffer(b) {\n      var bcopy = b.copy(b.offset, b.offset + size);\n      b.skip(size);\n      var fb = Buffer.from(bcopy.toBinary(), 'binary');\n      return floatPoint['read' + sizeName + 'LE'](fb);\n    },\n    appendByteBuffer: function appendByteBuffer(b, value) {\n      var output = [];\n      floatPoint['write' + sizeName + 'LE'](output, value);\n      b.append(output);\n    },\n    fromObject: function fromObject(value) {\n      return value;\n    },\n    toObject: function toObject(value) {\n      if (validation.defaults && value == null) {\n        return 0.0;\n      }\n\n      return value;\n    }\n  };\n};\n\nvar bytebuf = function bytebuf(validation) {\n  var _bytebuf = {\n    fromByteBuffer: function fromByteBuffer(b) {\n      var len = validation.len;\n      var bCopy = void 0;\n\n      if (len == null) {\n        var lenPrefix = b.readVarint32();\n        bCopy = b.copy(b.offset, b.offset + lenPrefix);\n        b.skip(lenPrefix);\n      } else {\n        bCopy = b.copy(b.offset, b.offset + len);\n        b.skip(len);\n      }\n\n      return Buffer.from(bCopy.toBinary(), 'binary');\n    },\n    appendByteBuffer: function appendByteBuffer(b, value) {\n      // value = _bytebuf.fromObject(value)\n      var len = validation.len;\n\n      if (len == null) {\n        b.writeVarint32(value.length);\n      }\n\n      b.append(value.toString('binary'), 'binary');\n    },\n    fromObject: function fromObject(value) {\n      if (typeof value === 'string') {\n        value = Buffer.from(value, 'hex');\n      } else if (value instanceof Array) {\n        value = Buffer.from(value);\n      } else if (value instanceof Uint8Array) {\n        value = Buffer.from(value);\n      }\n\n      validate(value, validation);\n      return value;\n    },\n    toObject: function toObject(value) {\n      var defaults = validation.defaults,\n          len = validation.len;\n\n      if (defaults && value == null) {\n        return Array(len ? len + 1 : 1).join('00');\n      }\n\n      validate(value, validation);\n      return value.toString('hex');\n    },\n    compare: function compare(a, b) {\n      return Buffer.compare(a, b);\n    }\n  };\n  return _bytebuf;\n};\n\nvar _string = function _string(validation) {\n  return {\n    fromByteBuffer: function fromByteBuffer(b) {\n      return b.readVString();\n    },\n    appendByteBuffer: function appendByteBuffer(b, value) {\n      validate(value, validation);\n      b.writeVString(value.toString());\n    },\n    fromObject: function fromObject(value) {\n      validate(value, validation);\n      return value;\n    },\n    toObject: function toObject(value) {\n      if (validation.defaults && value == null) {\n        return '';\n      }\n\n      validate(value, validation);\n      return value;\n    }\n  };\n};\n\nvar _time2 = function _time2(validation) {\n  var _time = {\n    fromByteBuffer: function fromByteBuffer(b) {\n      return b.readUint32();\n    },\n    appendByteBuffer: function appendByteBuffer(b, value) {\n      // if(typeof value !== \"number\")\n      //     value = _time.fromObject(value)\n      validate(value, validation);\n      b.writeUint32(value);\n    },\n    fromObject: function fromObject(value) {\n      validate(value, validation);\n\n      if (typeof value === 'number') {\n        return value;\n      }\n\n      if (value.getTime) {\n        return Math.floor(value.getTime() / 1000);\n      }\n\n      if (typeof value !== 'string') {\n        throw new Error('Unknown date type: ' + value);\n      } // Chrome assumes Zulu when missing, Firefox does not\n\n\n      if (typeof value === 'string' && !/Z$/.test(value)) {\n        value += 'Z';\n      }\n\n      return Math.floor(new Date(value).getTime() / 1000);\n    },\n    toObject: function toObject(value) {\n      if (validation.defaults && value == null) {\n        return new Date(0).toISOString().split('.')[0];\n      }\n\n      validate(value, validation); // if(typeof value === \"string\") {\n      //     if(!/Z$/.test(value))\n      //         value += \"Z\"\n      //\n      //     return value\n      // }\n      // if(value.getTime)\n      //     return value.toISOString().split('.')[0] + 'Z'\n\n      validateInt(value, spread(validation, {\n        bits: 32\n      }));\n      var int = parseInt(value);\n      return new Date(int * 1000).toISOString().split('.')[0];\n    }\n  };\n  return _time;\n};\n\nvar validate = function validate(value, validation) {\n  if (isEmpty(value)) {\n    throw new Error('Required ' + validation.typeName);\n  }\n\n  if (validation.len != null) {\n    if (value.length == null) {\n      throw new Error('len validation requries a \"length\" property');\n    }\n\n    var len = validation.len;\n\n    if (value.length !== len) {\n      throw new Error(validation.typeName + ' length ' + value.length + ' does not equal ' + len);\n    }\n  }\n\n  if (validation.maxLen != null) {\n    var maxLen = validation.maxLen;\n\n    if (value.length == null) {\n      throw new Error('maxLen validation requries a \"length\" property');\n    }\n\n    if (value.length > maxLen) {\n      throw new Error(validation.typeName + ' length ' + value.length + ' exceeds maxLen ' + maxLen);\n    }\n  }\n};\n\nvar ZERO = new BN();\nvar ONE = new BN('1');\n\nfunction validateInt(value, validation) {\n  if (isEmpty(value)) {\n    throw new Error('Required ' + validation.typeName);\n  }\n\n  var _validation$signed2 = validation.signed,\n      signed = _validation$signed2 === undefined ? false : _validation$signed2,\n      _validation$bits = validation.bits,\n      bits = _validation$bits === undefined ? 54 : _validation$bits;\n  value = String(value).trim();\n\n  if (signed && !/^-?[0-9]+$/.test(value) || !signed && !/^[0-9]+$/.test(value)) {\n    throw new Error('Number format ' + validation.typeName + ' ' + value);\n  }\n\n  var max = signed ? maxSigned(bits) : maxUnsigned(bits);\n  var min = signed ? minSigned(bits) : ZERO;\n  var i = new BN(value); // console.log('i.toString(), min.toString()', i.toString(), min.toString())\n\n  if (i.cmp(min) < 0 || i.cmp(max) > 0) {\n    throw new Error('Overflow ' + validation.typeName + ' ' + value + ', ' + ('max ' + max.toString() + ', min ' + min.toString() + ', signed ' + signed + ', bits ' + bits));\n  }\n}\n\nvar isSerializer = function isSerializer(type) {\n  return (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && typeof type.fromByteBuffer === 'function' && typeof type.appendByteBuffer === 'function' && typeof type.fromObject === 'function' && typeof type.toObject === 'function';\n};\n\nvar toString = function toString(value, encoding) {\n  return value == null ? value : value.toString ? value.toString(encoding) : value;\n};\n\nvar sort = function sort(type, values) {\n  return type.compare ? values.sort(type.compare) : // custom compare\n  values.sort();\n};\n\nvar spread = function spread() {\n  return Object.assign.apply(Object, arguments);\n};\n\nvar isEmpty = function isEmpty(value) {\n  return value == null;\n}; // 1 << N === Math.pow(2, N)\n\n\nvar maxUnsigned = function maxUnsigned(bits) {\n  return new BN(1).ishln(bits).isub(ONE);\n};\n\nvar maxSigned = function maxSigned(bits) {\n  return new BN(1).ishln(bits - 1).isub(ONE);\n};\n\nvar minSigned = function minSigned(bits) {\n  return new BN(1).ishln(bits - 1).ineg();\n};","map":null,"metadata":{},"sourceType":"script"}