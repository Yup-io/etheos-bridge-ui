{"ast":null,"code":"/**\n * pure javascript functions to read and write 32-bit and 64-bit IEEE 754 floating-point\n *\n * Copyright (C) 2017 Andras Radics\n * Licensed under the Apache License, Version 2.0\n */\n'use strict';\n\nvar isBigeCpu = false;\nvar readFloat32Array, writeFloat32Array, readFloat32ArrayRev, writeFloat32ArrayRev;\nvar readFloat64Array, writeFloat64Array, readFloat64ArrayRev, writeFloat64ArrayRev; // test FloatArray existence with && to not throw off code coverage\n\ntypeof Float32Array === 'function' && function () {\n  var _fp32 = new Float32Array(1);\n\n  var _b32 = new Uint8Array(_fp32.buffer);\n\n  _fp32[0] = -1;\n  isBigeCpu = _b32[3] === 0;\n\n  readFloat32Array = function readFloat32Array(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 4 > buf.length) return 0;\n    _b32[0] = buf[pos++];\n    _b32[1] = buf[pos++];\n    _b32[2] = buf[pos++];\n    _b32[3] = buf[pos]; //_b32[0] = buf[pos+0]; _b32[1] = buf[pos+1]; _b32[2] = buf[pos+2]; _b32[3] = buf[pos+3];\n\n    return _fp32[0];\n  };\n\n  readFloat32ArrayRev = function readFloat32ArrayRev(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 4 > buf.length) return 0;\n    _b32[3] = buf[pos++];\n    _b32[2] = buf[pos++];\n    _b32[1] = buf[pos++];\n    _b32[0] = buf[pos]; //_b32[3] = buf[pos+0]; _b32[2] = buf[pos+1]; _b32[1] = buf[pos+2]; _b32[0] = buf[pos+3];\n\n    return _fp32[0];\n  };\n\n  writeFloat32Array = function writeFloat32Array(buf, v, pos) {\n    pos = pos || 0;\n    _fp32[0] = v;\n    buf[pos++] = _b32[0];\n    buf[pos++] = _b32[1];\n    buf[pos++] = _b32[2];\n    buf[pos] = _b32[3]; //buf[pos+0] = _b32[0]; buf[pos+1] = _b32[1]; buf[pos+2] = _b32[2]; buf[pos+3] = _b32[3];\n  };\n\n  writeFloat32ArrayRev = function writeFloat32ArrayRev(buf, v, pos) {\n    pos = pos || 0;\n    _fp32[0] = v;\n    buf[pos++] = _b32[3];\n    buf[pos++] = _b32[2];\n    buf[pos++] = _b32[1];\n    buf[pos] = _b32[0]; //buf[pos+0] = _b32[3]; buf[pos+1] = _b32[2]; buf[pos+2] = _b32[1]; buf[pos+3] = _b32[0];\n  };\n}();\ntypeof Float64Array === 'function' && function () {\n  var _fp64 = new Float64Array(1);\n\n  var _b64 = new Uint8Array(_fp64.buffer);\n\n  readFloat64Array = function readFloat64Array(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 8 > buf.length) return 0; //_b64[0] = buf[pos++]; _b64[1] = buf[pos++]; _b64[2] = buf[pos++]; _b64[3] = buf[pos++];\n    //_b64[4] = buf[pos++]; _b64[5] = buf[pos++]; _b64[6] = buf[pos++]; _b64[7] = buf[pos];\n\n    _b64[0] = buf[pos + 0];\n    _b64[1] = buf[pos + 1];\n    _b64[2] = buf[pos + 2];\n    _b64[3] = buf[pos + 3];\n    _b64[4] = buf[pos + 4];\n    _b64[5] = buf[pos + 5];\n    _b64[6] = buf[pos + 6];\n    _b64[7] = buf[pos + 7];\n    return _fp64[0];\n  };\n\n  readFloat64ArrayRev = function readFloat64ArrayRev(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 8 > buf.length) return 0; //_b64[7] = buf[pos++]; _b64[6] = buf[pos++]; _b64[5] = buf[pos++]; _b64[4] = buf[pos++];\n    //_b64[3] = buf[pos++]; _b64[2] = buf[pos++]; _b64[1] = buf[pos++]; _b64[0] = buf[pos];\n\n    _b64[7] = buf[pos + 0];\n    _b64[6] = buf[pos + 1];\n    _b64[5] = buf[pos + 2];\n    _b64[4] = buf[pos + 3];\n    _b64[3] = buf[pos + 4];\n    _b64[2] = buf[pos + 5];\n    _b64[1] = buf[pos + 6];\n    _b64[0] = buf[pos + 7];\n    return _fp64[0];\n  };\n\n  writeFloat64Array = function writeFloat64Array(buf, v, pos) {\n    pos = pos || 0;\n    _fp64[0] = v;\n    buf[pos + 0] = _b64[0];\n    buf[pos + 1] = _b64[1];\n    buf[pos + 2] = _b64[2];\n    buf[pos + 3] = _b64[3];\n    buf[pos + 4] = _b64[4];\n    buf[pos + 5] = _b64[5];\n    buf[pos + 6] = _b64[6];\n    buf[pos + 7] = _b64[7];\n  };\n\n  writeFloat64ArrayRev = function writeFloat64ArrayRev(buf, v, pos) {\n    pos = pos || 0;\n    _fp64[0] = v;\n    buf[pos + 0] = _b64[7];\n    buf[pos + 1] = _b64[6];\n    buf[pos + 2] = _b64[5];\n    buf[pos + 3] = _b64[4];\n    buf[pos + 4] = _b64[3];\n    buf[pos + 5] = _b64[2];\n    buf[pos + 6] = _b64[1];\n    buf[pos + 7] = _b64[0];\n  };\n}(); // arithmetic operations preserve NaN, but logical ops (, >>, etc) convert them to zero\n// Assemble the word to generate NaN if any reads are undefined (outside the bounds of the array).\n\nfunction readWord(buf, offs, dirn) {\n  var a = buf[offs++],\n      b = buf[offs++],\n      c = buf[offs++],\n      d = buf[offs];\n  return dirn === 'bige' ? ((a * 256 + b) * 256 + c) * 256 + d : ((d * 256 + c) * 256 + b) * 256 + a;\n}\n\nfunction writeWord(buf, v, offs, dirn) {\n  var a = v >>> 24 & 0xff,\n      b = v >> 16 & 0xff,\n      c = v >> 8 & 0xff,\n      d = v & 0xff;\n  dirn === 'bige' ? (buf[offs++] = a, buf[offs++] = b, buf[offs++] = c, buf[offs] = d) : (buf[offs++] = d, buf[offs++] = c, buf[offs++] = b, buf[offs] = a);\n} // write the two-word value [hi,lo] where hi holds the 32 msb bits and lo the 32 lsb bits\n\n\nfunction writeDoubleWord(buf, hi, lo, offs, dirn) {\n  if (dirn === 'bige') {\n    writeWord(buf, hi, offs, dirn);\n    writeWord(buf, lo, offs + 4, dirn);\n  } else {\n    writeWord(buf, lo, offs, dirn);\n    writeWord(buf, hi, offs + 4, dirn);\n  }\n} // given an exponent n, return 2**n\n// n is always an integer, faster to shift when possible\n// Note that nodejs Math.pow() is faster than a lookup table (may be caching)\n\n\nvar _2eXp = new Array();\n\nfor (var i = 0; i < 1200; i++) {\n  _2eXp[i] = Math.pow(2, i);\n}\n\nvar _2eXn = new Array();\n\nfor (var i = 0; i < 1200; i++) {\n  _2eXn[i] = Math.pow(2, -i);\n}\n\nfunction pow2(exp) {\n  return exp >= 0 ? _2eXp[exp] : _2eXn[-exp]; //return (exp >= 0) ? (exp <  31 ? (1 << exp) :        Math.pow(2, exp))\n  //                  : (exp > -31 ? (1 / (1 << -exp)) : Math.pow(2, exp));\n} // getFloat() from qbson, https://github.com/andrasq/node-qbson:\n\n/*\n * extract the 64-bit little-endian ieee 754 floating-point value\n *   see http://en.wikipedia.org/wiki/Double-precision_floating-point_format\n *   1 bit sign + 11 bits exponent + (1 implicit mantissa 1 bit) + 52 mantissa bits\n */\n\n\nvar _rshift32 = 1 / 0x100000000; // >> 32 for floats\n\n\nvar _rshift20 = 1 / 0x100000; // >> 20 for floats\n\n\nvar _lshift32 = 1 * 0x100000000; // << 32\n\n\nvar _rshift52 = 1 * _rshift32 * _rshift20; // >> 52\n\n\nvar _rshift1023 = pow2(-1023); // 2^-1023\n\n\nfunction readDouble(buf, offset, dirn) {\n  var w0 = readWord(buf, offset, dirn);\n  var w1 = readWord(buf, offset + 4, dirn);\n  var highWord, lowWord;\n  dirn === 'bige' ? (highWord = w0, lowWord = w1) : (highWord = w1, lowWord = w0);\n  var mantissa = (highWord & 0x000FFFFF) * _lshift32 + lowWord;\n  var exponent = (highWord & 0x7FF00000) >>> 20;\n  var sign = highWord >> 31 || 1; // -1, 1, or 1 if NaN\n\n  var value;\n\n  if (exponent === 0x000) {\n    // zero if !mantissa, else subnormal (non-normalized reduced precision small value)\n    // recover negative zero -0.0 as distinct from 0.0\n    // subnormals do not have an implied leading 1 bit and are positioned 1 bit to the left\n    value = mantissa ? mantissa * pow2(-52 + 1 - 1023) : 0.0;\n  } else if (exponent < 0x7ff) {\n    // normalized value with an implied leading 1 bit and 1023 biased exponent\n    // test for NaN with (mantissa >= 0), and return 0 if NaN ie read from outside buffer bounds\n    value = mantissa >= 0 ? (1 + mantissa * _rshift52) * pow2(exponent - 1023) : 0.0;\n  } else {\n    // Infinity if zero mantissa (+/- per sign), NaN if nonzero mantissa\n    value = mantissa ? NaN : Infinity;\n  }\n\n  return sign * value;\n} //\n// Note: node-v9 prefers +28% (sign * value), node v6 doesnt care, node v8 likes +16% (-value : value)\n//\n// float32: 1 sign + 8 exponent + 24 mantissa (23 stored, 1 implied)\n// see https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n//\n// Exponent     Mantissa == 0   Mantissa > 0    Value\n// 00           +0, -0          denormalized    2^(  1-127) * (0. + (mantissa / 2^23))\n// 00.. FE                      normalized      2^(exp-127) * (1. + (mantissa / 2^23))\n// FF           +/-Infinity     NaN             -\n//\n\n\nvar _rshift23 = Math.pow(2, -23); // >> 23 for floats\n\n\nvar _rshift127 = Math.pow(2, -127); // 2^-127\n\n\nfunction readFloat(buf, offset, dirn) {\n  var word = readWord(buf, offset, dirn);\n  var mantissa = word & 0x007FFFFF;\n  var exponent = (word & 0x7F800000) >>> 23;\n  var sign = word >> 31 || 1; // -1, 1, or 1 if NaN\n\n  var value;\n\n  if (exponent === 0x000) {\n    value = mantissa ? mantissa * _rshift23 * 2 * _rshift127 : 0.0;\n  } else if (exponent < 0xff) {\n    value = (1 + mantissa * _rshift23) * pow2(exponent - 127); // * _rshift127;\n  } else {\n    value = mantissa ? NaN : Infinity;\n  }\n\n  return sign * value; //return (word >>> 31) ? -value : value;\n} // given a positive value v, normalize it to between 1 and less than 2 with a binary exponent\n// The exponent is the number of bit places it was shifted, positive if v was >= 2.\n// The special values 0, -0, NaN, +Infinity and -Infinity are not handled here.\n// Looping is faster than (Math.log(v) / Math.LN2) in node-v6, v8, and v9.\n// This function can account for half the time taken to write a double.\n\n\nvar _parts = {\n  exp: 0,\n  mant: 0\n};\n\nfunction normalize(v) {\n  var exp = 0;\n\n  if (v >= 2) {\n    exp = countDoublings(1, v);\n    v *= pow2(-exp); // if doubled to exactly v/2, adjust up to v\n\n    if (v >= 2) {\n      v /= 2;\n      exp += 1;\n    }\n  } else if (v < 1) {\n    exp = countDoublings(v, 2); // avoid using pow2 exponents > 1023, they overflow to Infinity\n\n    if (exp <= 1023) v *= pow2(exp);else {\n      v *= pow2(exp - 100);\n      v *= pow2(100);\n    }\n    exp = -exp;\n  } // TODO: pass in num bits, and normalize straight to mantissa / denorm\n\n\n  _parts.exp = exp;\n  _parts.mant = v;\n  return _parts;\n} // count how many doublings of a are needed for it be close to b.\n// Returns a shift count that grows (a) to at least (b/2) but less than (b).\n// Doubling 1 toward v ensures that (v >> n) >= 1 < 2,\n// and doubling from v toward 2 ensures that (v << n) >= 1 < 2.\n\n\nvar _2e192 = Math.pow(2, 192);\n\nfunction countDoublings(a, b) {\n  var n = 0;\n\n  while (a * _2e192 < b) {\n    a *= _2e192;\n    n += 192;\n  }\n\n  while (a * 0x10000000000000000 < b) {\n    a *= 0x10000000000000000;\n    n += 64;\n  }\n\n  while (a * 0x10000 < b) {\n    a *= 0x10000;\n    n += 16;\n  }\n\n  while (a * 0x40 < b) {\n    a *= 0x40;\n    n += 6;\n  }\n\n  while (a * 2 < b) {\n    a *= 2;\n    n += 1;\n  }\n\n  return n;\n} // round the fraction in v and scale up to scale = 2^n bits\n// https://blog.angularindepth.com/how-to-round-binary-fractions-625c8fa3a1af\n// Rounding can cause the scaled value to exceed 2^n.\n\n\nfunction roundMantissa(v, scale) {\n  v *= scale; // round to nearest, but round a 0.5 tie to even (0.5 to 0.0 and 1.5 to 2.0)\n  // round all numbers with a fraction other than 1/2, and round up odd numbers with\n\n  return v - Math.floor(v) !== 0.5 || v & 1 ? v + 0.5 : v;\n} // float32: 1 sign + 8 exponent + (1 implied mantissa 1 bit) + 23 stored mantissa bits\n// NaN types: quiet Nan = x.ff.8xxx, signaling NaN = x.ff.0xx1 (msb zero, at least one other bit set)\n// JavaScript built-in NaN is the non-signaling 7fc00000, but arithmetic can yield a negative NaN ffc00000.\n\n\nfunction writeFloat(buf, v, offset, dirn) {\n  var norm,\n      word,\n      sign = 0;\n\n  if (v < 0) {\n    sign = 0x80000000;\n    v = -v;\n  }\n\n  if (!(v && v < Infinity)) {\n    if (v === 0) {\n      // -0, +0\n      word = 1 / v < 0 ? 0x80000000 : 0x00000000;\n    } else if (v === Infinity) {\n      // -Infinity, +Infinity\n      word = sign | 0x7F800000;\n    } else {\n      // NaN - positive, non-signaling\n      word = 0x7FC00000;\n    }\n\n    writeWord(buf, word, offset, dirn);\n  } else {\n    norm = normalize(v); // separate exponent and mantissa\n\n    norm.exp += 127; // bias exponent\n\n    if (norm.exp <= 0) {\n      // denormalized number\n      if (norm.exp <= -25) {\n        // too small, underflow to zero.  -24 might round up though.\n        norm.mant = 0;\n        norm.exp = 0;\n      } else {\n        // denormalize\n        norm.mant = roundMantissa(norm.mant, pow2(22 + norm.exp));\n        norm.exp = 0; // rounding can carry out and re-normalize the number\n\n        if (norm.mant >= 0x800000) {\n          norm.mant -= 0x800000;\n          norm.exp += 1;\n        }\n      }\n    } else {\n      norm.mant = roundMantissa(norm.mant - 1, 0x800000); // if rounding overflowed into the hidden 1s place, hide it and adjust the exponent\n\n      if (norm.mant >= 0x800000) {\n        norm.mant -= 0x800000;\n        norm.exp += 1;\n      }\n\n      if (norm.exp > 254) {\n        // overflow to Infinity\n        norm.mant = 0;\n        norm.exp = 255;\n      }\n    }\n\n    word = sign | norm.exp << 23 | norm.mant;\n    writeWord(buf, word, offset, dirn);\n  }\n} // double64: 1 bit sign + 11 bits exponent + (1 implied mantissa 1 bit) + 52 stored mantissa bits\n// Writing doubles is simpler than floats, because the internal javascript 64-bit floats\n// are identical to the stored representation, and thus will not overflow or underflow.\n\n\nvar doubleArray = [0, 0, 0, 0, 0, 0, 0, 0];\nvar doubleBuf = new Buffer(8);\n\nvar _2e52 = Math.pow(2, 52);\n\nfunction writeDouble(buf, v, offset, dirn) {\n  var norm,\n      highWord,\n      lowWord,\n      sign = 0;\n\n  if (v < 0) {\n    sign = 0x80000000;\n    v = -v;\n  }\n\n  if (!(v && v < Infinity)) {\n    if (v === 0) {\n      // -0, +0\n      highWord = 1 / v < 0 ? 0x80000000 : 0;\n      lowWord = 0;\n    } else if (v === Infinity) {\n      // -Infinity, +Infinity\n      highWord = sign + 0x7FF00000;\n      lowWord = 0;\n    } else {\n      // NaN - positive, non-signaling\n      highWord = 0x7FF80000;\n      lowWord = 0;\n    }\n\n    writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n  } else {\n    norm = normalize(v); // separate exponent and mantissa\n\n    norm.exp += 1023; // bias exponent\n\n    if (norm.exp <= 0) {\n      // denormalized\n      // JavaScript numbers can not hold values small enough to underflow\n      // and no need to round, all bits will be written\n      norm.mant *= pow2(51 + norm.exp);\n      norm.exp = 0;\n    } else {\n      // no need to round, all bits will be written\n      norm.mant = (norm.mant - 1) * _2e52;\n    }\n\n    highWord = sign | norm.exp << 20 | norm.mant / 0x100000000;\n    lowWord = norm.mant >>> 0;\n    writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n  }\n}\n\n;\n(function install() {\n  var exports = typeof module === 'object' && module.exports || this;\n  exports.readWord = readWord;\n  exports.writeWord = writeWord;\n  exports.writeDoubleWord = writeDoubleWord;\n  exports.readFloat = readFloat;\n  exports.writeFloat = writeFloat;\n  exports.readDouble = readDouble;\n  exports.writeDouble = writeDouble; // expose the implementation to the tests\n\n  exports._useFloatArray = function (yesno) {\n    exports._usingFloatArray = yesno;\n\n    if (yesno) {\n      // software conversion is faster for float32 than Float32Array\n      // Only read via Float32Array if yesno == 'full'.\n      if (yesno == 'full') exports.readFloatLE = isBigeCpu ? readFloat32ArrayRev : readFloat32Array;\n      exports.writeFloatLE = isBigeCpu ? writeFloat32ArrayRev : writeFloat32Array;\n      if (yesno == 'full') exports.readFloatBE = isBigeCpu ? readFloat32Array : readFloat32ArrayRev;\n      exports.writeFloatBE = isBigeCpu ? writeFloat32Array : writeFloat32ArrayRev;\n      exports.readDoubleLE = isBigeCpu ? readFloat64ArrayRev : readFloat64Array;\n      exports.writeDoubleLE = isBigeCpu ? writeFloat64ArrayRev : writeFloat64Array;\n      exports.readDoubleBE = isBigeCpu ? readFloat64Array : readFloat64ArrayRev;\n      exports.writeDoubleBE = isBigeCpu ? writeFloat64Array : writeFloat64ArrayRev;\n    } else {\n      exports._usingFloatArray = '';\n\n      exports.readFloatLE = function readFloatLE(buf, offset) {\n        return exports.readFloat(buf, offset || 0, 'le');\n      };\n\n      exports.writeFloatLE = function writeFloatLE(buf, v, offset) {\n        exports.writeFloat(buf, v, offset || 0, 'le');\n      };\n\n      exports.readFloatBE = function readFloatBE(buf, offset) {\n        return exports.readFloat(buf, offset || 0, 'bige');\n      };\n\n      exports.writeFloatBE = function writeFloatBE(buf, v, offset) {\n        exports.writeFloat(buf, v, offset || 0, 'bige');\n      };\n\n      exports.readDoubleLE = function readDoubleLE(buf, offset) {\n        return exports.readDouble(buf, offset || 0, 'le');\n      };\n\n      exports.writeDoubleLE = function writeDoubleLE(buf, v, offset) {\n        exports.writeDouble(buf, v, offset || 0, 'le');\n      };\n\n      exports.readDoubleBE = function readDoubleBE(buf, offset) {\n        return exports.readDouble(buf, offset || 0, 'bige');\n      };\n\n      exports.writeDoubleBE = function writeDoubleLE(buf, v, offset) {\n        exports.writeDouble(buf, v, offset || 0, 'bige');\n      };\n    }\n  }; // expose the cpu endianism to the tests\n\n\n  exports._getBigeCpu = function () {\n    return isBigeCpu;\n  };\n\n  exports._setBigeCpu = function (yesno) {\n    isBigeCpu = yesno;\n  }; // by default export the software conversion functions, then\n  // if available, convert by casting a FloatArray to a byte array\n\n\n  exports._useFloatArray(false);\n\n  exports._useFloatArray(readFloat32Array && readFloat64Array && 'fastest'); // accelerate access\n\n\n  install.prototype = exports;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}