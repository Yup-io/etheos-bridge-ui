{"ast":null,"code":"'use strict';\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ecc = require('eosjs-ecc');\n\nvar Fcbuffer = require('fcbuffer');\n\nvar EosApi = require('eosjs-api');\n\nvar assert = require('assert');\n\nvar Structs = require('./structs');\n\nvar AbiCache = require('./abi-cache');\n\nvar writeApiGen = require('./write-api');\n\nvar format = require('./format');\n\nvar schema = require('./schema');\n\nvar token = require('./schema/eosio.token.abi.json');\n\nvar system = require('./schema/eosio.system.abi.json');\n\nvar eosio_null = require('./schema/eosio.null.abi.json');\n\nvar Eos = function Eos() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var configDefaults = {\n    httpEndpoint: 'http://127.0.0.1:8888',\n    debug: false,\n    verbose: false,\n    broadcast: true,\n    logger: {\n      log: function log() {\n        var _console;\n\n        return config.verbose ? (_console = console).log.apply(_console, arguments) : null;\n      },\n      error: function error() {\n        var _console2;\n\n        return config.verbose ? (_console2 = console).error.apply(_console2, arguments) : null;\n      }\n    },\n    sign: true\n  };\n\n  function applyDefaults(target, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (target[key] === undefined) {\n        target[key] = defaults[key];\n      }\n    });\n  }\n\n  applyDefaults(config, configDefaults);\n  applyDefaults(config.logger, configDefaults.logger);\n  return createEos(config);\n};\n\nmodule.exports = Eos;\nObject.assign(Eos, {\n  version: '16.0.0',\n  modules: {\n    format: format,\n    api: EosApi,\n    ecc: ecc,\n    json: {\n      api: EosApi.api,\n      schema: schema\n    },\n    Fcbuffer: Fcbuffer\n  },\n\n  /** @deprecated */\n  Testnet: function Testnet(config) {\n    console.error('deprecated, change Eos.Testnet(..) to just Eos(..)');\n    return Eos(config);\n  },\n\n  /** @deprecated */\n  Localnet: function Localnet(config) {\n    console.error('deprecated, change Eos.Localnet(..) to just Eos(..)');\n    return Eos(config);\n  }\n});\n\nfunction createEos(config) {\n  var network = config.httpEndpoint != null ? EosApi(config) : null;\n  config.network = network;\n  var abis = [];\n  var abiCache = AbiCache(network, config);\n  abis.push(abiCache.abi('eosio.null', eosio_null));\n  abis.push(abiCache.abi('eosio.token', token));\n  abis.push(abiCache.abi('eosio', system));\n\n  if (!config.chainId) {\n    config.chainId = 'cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f';\n  }\n\n  if (network) {\n    checkChainId(network, config.chainId, config.logger);\n  }\n\n  if (config.mockTransactions != null) {\n    if (typeof config.mockTransactions === 'string') {\n      var mock = config.mockTransactions;\n\n      config.mockTransactions = function () {\n        return mock;\n      };\n    }\n\n    assert.equal((0, _typeof3.default)(config.mockTransactions), 'function', 'config.mockTransactions');\n  }\n\n  var _Structs = Structs(config),\n      structs = _Structs.structs,\n      types = _Structs.types,\n      fromBuffer = _Structs.fromBuffer,\n      toBuffer = _Structs.toBuffer;\n\n  var eos = mergeWriteFunctions(config, EosApi, structs, abis);\n  Object.assign(eos, {\n    config: safeConfig(config),\n    fc: {\n      structs: structs,\n      types: types,\n      fromBuffer: fromBuffer,\n      toBuffer: toBuffer,\n      abiCache: abiCache\n    },\n    // Repeat of static Eos.modules, help apps that use dependency injection\n    modules: {\n      format: format\n    }\n  });\n\n  if (!config.signProvider) {\n    config.signProvider = defaultSignProvider(eos, config);\n  }\n\n  return eos;\n}\n/**\n  Set each property as read-only, read-write, no-access.  This is shallow\n  in that it applies only to the root object and does not limit access\n  to properties under a given object.\n*/\n\n\nfunction safeConfig(config) {\n  // access control is shallow references only\n  var readOnly = new Set(['httpEndpoint', 'abiCache', 'chainId', 'expireInSeconds']);\n  var readWrite = new Set(['verbose', 'debug', 'broadcast', 'logger', 'sign']);\n  var protectedConfig = {};\n  Object.keys(config).forEach(function (key) {\n    Object.defineProperty(protectedConfig, key, {\n      set: function set(value) {\n        if (readWrite.has(key)) {\n          config[key] = value;\n          return;\n        }\n\n        throw new Error('Access denied');\n      },\n      get: function get() {\n        if (readOnly.has(key) || readWrite.has(key)) {\n          return config[key];\n        }\n\n        throw new Error('Access denied');\n      }\n    });\n  });\n  return protectedConfig;\n}\n/**\n  Merge in write functions (operations).  Tested against existing methods for\n  name conflicts.\n\n  @arg {object} config.network - read-only api calls\n  @arg {object} EosApi - api[EosApi] read-only api calls\n  @return {object} - read and write method calls (create and sign transactions)\n  @throw {TypeError} if a funciton name conflicts\n*/\n\n\nfunction mergeWriteFunctions(config, EosApi, structs, abis) {\n  var network = config.network;\n  var merge = Object.assign({}, network);\n  var writeApi = writeApiGen(EosApi, network, structs, config, abis);\n  throwOnDuplicate(merge, writeApi, 'Conflicting methods in EosApi and Transaction Api');\n  Object.assign(merge, writeApi);\n  return merge;\n}\n\nfunction throwOnDuplicate(o1, o2, msg) {\n  for (var key in o1) {\n    if (o2[key]) {\n      throw new TypeError(msg + ': ' + key);\n    }\n  }\n}\n/**\n  The default sign provider is designed to interact with the available public\n  keys (maybe just one), the transaction, and the blockchain to figure out\n  the minimum set of signing keys.\n\n  If only one key is available, the blockchain API calls are skipped and that\n  key is used to sign the transaction.\n*/\n\n\nvar defaultSignProvider = function defaultSignProvider(eos, config) {\n  return function _callee(_ref) {\n    var sign = _ref.sign,\n        buf = _ref.buf,\n        transaction = _ref.transaction,\n        optionsKeyProvider = _ref.optionsKeyProvider;\n\n    var keyProvider, keys, pvt, sigs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key, keyMap, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _key, isPrivate, isPublic, pubkeys;\n\n    return _regenerator2.default.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // optionsKeyProvider is a per-action key: await eos.someAction('user2' .., {keyProvider: privateKey2})\n            keyProvider = optionsKeyProvider ? optionsKeyProvider : config.keyProvider;\n\n            if (keyProvider) {\n              _context.next = 3;\n              break;\n            }\n\n            throw new TypeError('This transaction requires a keyProvider for signing');\n\n          case 3:\n            keys = keyProvider;\n\n            if (typeof keyProvider === 'function') {\n              keys = keyProvider({\n                transaction: transaction\n              });\n            } // keyProvider may return keys or Promise<keys>\n\n\n            _context.next = 7;\n            return _regenerator2.default.awrap(Promise.resolve(keys));\n\n          case 7:\n            keys = _context.sent;\n\n            if (!Array.isArray(keys)) {\n              keys = [keys];\n            }\n\n            keys = keys.map(function (key) {\n              try {\n                // normalize format (WIF => PVT_K1_base58privateKey)\n                return {\n                  private: ecc.PrivateKey(key).toString()\n                };\n              } catch (e) {\n                // normalize format (EOSKey => PUB_K1_base58publicKey)\n                return {\n                  public: ecc.PublicKey(key).toString()\n                };\n              }\n\n              assert(false, 'expecting public or private keys from keyProvider');\n            });\n\n            if (keys.length) {\n              _context.next = 12;\n              break;\n            }\n\n            throw new Error('missing key, check your keyProvider');\n\n          case 12:\n            if (!(keys.length === 1 && keys[0].private)) {\n              _context.next = 15;\n              break;\n            }\n\n            pvt = keys[0].private;\n            return _context.abrupt('return', sign(buf, pvt));\n\n          case 15:\n            if (!(config.httpEndpoint == null)) {\n              _context.next = 37;\n              break;\n            }\n\n            sigs = [];\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _iteratorError = undefined;\n            _context.prev = 20;\n\n            for (_iterator = keys[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              key = _step.value;\n              sigs.push(sign(buf, key.private));\n            }\n\n            _context.next = 28;\n            break;\n\n          case 24:\n            _context.prev = 24;\n            _context.t0 = _context['catch'](20);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 28:\n            _context.prev = 28;\n            _context.prev = 29;\n\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n\n          case 31:\n            _context.prev = 31;\n\n            if (!_didIteratorError) {\n              _context.next = 34;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 34:\n            return _context.finish(31);\n\n          case 35:\n            return _context.finish(28);\n\n          case 36:\n            return _context.abrupt('return', sigs);\n\n          case 37:\n            keyMap = new Map(); // keys are either public or private keys\n\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _iteratorError2 = undefined;\n            _context.prev = 41;\n\n            for (_iterator2 = keys[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              _key = _step2.value;\n              isPrivate = _key.private != null;\n              isPublic = _key.public != null;\n\n              if (isPrivate) {\n                keyMap.set(ecc.privateToPublic(_key.private), _key.private);\n              } else {\n                keyMap.set(_key.public, null);\n              }\n            }\n\n            _context.next = 49;\n            break;\n\n          case 45:\n            _context.prev = 45;\n            _context.t1 = _context['catch'](41);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context.t1;\n\n          case 49:\n            _context.prev = 49;\n            _context.prev = 50;\n\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n\n          case 52:\n            _context.prev = 52;\n\n            if (!_didIteratorError2) {\n              _context.next = 55;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 55:\n            return _context.finish(52);\n\n          case 56:\n            return _context.finish(49);\n\n          case 57:\n            pubkeys = Array.from(keyMap.keys());\n            return _context.abrupt('return', eos.getRequiredKeys(transaction, pubkeys).then(function (_ref2) {\n              var required_keys = _ref2.required_keys;\n\n              if (!required_keys.length) {\n                throw new Error('missing required keys for ' + JSON.stringify(transaction));\n              }\n\n              var pvts = [],\n                  missingKeys = [];\n              var _iteratorNormalCompletion3 = true;\n              var _didIteratorError3 = false;\n              var _iteratorError3 = undefined;\n\n              try {\n                for (var _iterator3 = required_keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                  var requiredKey = _step3.value; // normalize (EOSKey.. => PUB_K1_Key..)\n\n                  requiredKey = ecc.PublicKey(requiredKey).toString();\n                  var wif = keyMap.get(requiredKey);\n\n                  if (wif) {\n                    pvts.push(wif);\n                  } else {\n                    missingKeys.push(requiredKey);\n                  }\n                }\n              } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                    _iterator3.return();\n                  }\n                } finally {\n                  if (_didIteratorError3) {\n                    throw _iteratorError3;\n                  }\n                }\n              }\n\n              if (missingKeys.length !== 0) {\n                assert(typeof keyProvider === 'function', 'keyProvider function is needed for private key lookup'); // const pubkeys = missingKeys.map(key => ecc.PublicKey(key).toStringLegacy())\n\n                keyProvider({\n                  pubkeys: missingKeys\n                }).forEach(function (pvt) {\n                  pvts.push(pvt);\n                });\n              }\n\n              var sigs = [];\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n\n              try {\n                for (var _iterator4 = pvts[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  var _pvt = _step4.value;\n                  sigs.push(sign(buf, _pvt));\n                }\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n\n              return sigs;\n            }));\n\n          case 59:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, null, this, [[20, 24, 28, 36], [29,, 31, 35], [41, 45, 49, 57], [50,, 52, 56]]);\n  };\n};\n\nfunction checkChainId(network, chainId, logger) {\n  network.getInfo({}).then(function (info) {\n    if (info.chain_id !== chainId) {\n      if (logger.log) {\n        logger.log('chainId mismatch, signatures will not match transaction authority. ' + ('expected ' + chainId + ' !== actual ' + info.chain_id));\n      }\n    }\n  }).catch(function (error) {\n    if (logger.error) {\n      logger.error('Warning, unable to validate chainId: ' + error.message);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}