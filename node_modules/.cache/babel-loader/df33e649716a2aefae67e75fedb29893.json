{"ast":null,"code":"'use strict';\n\nvar ByteBuffer = require('bytebuffer');\n/**\n  @class Struct\n\n  @arg {object} config.override = {\n    'Message.data.appendByteBuffer': ({fields, object, b}) => {..}\n  }\n  Rare cases where specialized serilization is needed (ex A Message object has\n  'type' and 'data' fields where object.type === 'transfer' can define\n  serialization time Struct needed for 'data' .. This saves complexity for the\n  end-user's working with json.  See override unit test.\n*/\n\n\nmodule.exports = function (name) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    debug: false\n  };\n  config = Object.assign({\n    override: {}\n  }, config);\n  var fields = {};\n  var fieldOne = void 0,\n      fieldOneName = void 0;\n  return {\n    compare: function compare(a, b) {\n      var v1 = a[fieldOneName];\n      var v2 = b[fieldOneName];\n\n      if (!fieldOne || !fieldOne.compare) {\n        return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;\n      }\n\n      return fieldOne.compare(v1, v2);\n    },\n\n    /** @private */\n    add: function add(fieldName, type) {\n      fields[fieldName] = type;\n\n      if (fieldOne == null) {\n        fieldOne = type;\n        fieldOneName = fieldName;\n      }\n    },\n    // Complete list of fields, after resolving \"base\" inheritance\n    fields: fields,\n    fromByteBuffer: function fromByteBuffer(b) {\n      var object = {};\n      var field = null;\n\n      try {\n        for (field in fields) {\n          var type = fields[field];\n\n          try {\n            var o1 = b.offset;\n\n            if (field === '') {\n              // structPtr\n              object = type.fromByteBuffer(b, config);\n            } else {\n              var fromByteBuffer = config.override[name + '.' + field + '.fromByteBuffer'];\n\n              if (fromByteBuffer) {\n                fromByteBuffer({\n                  fields: fields,\n                  object: object,\n                  b: b,\n                  config: config\n                });\n              } else {\n                object[field] = type.fromByteBuffer(b, config);\n              }\n            }\n\n            if (config.debug) {\n              if (type.struct) {\n                console.error(type.struct);\n              } else {\n                var value = void 0;\n\n                try {\n                  // human readable text\n                  value = type.toObject(field === '' ? object : object[field], config);\n                } catch (error) {\n                  // console.error('fromByteBuffer debug error:', error)\n                  value = '';\n                }\n\n                var _b = b.copy(o1, b.offset);\n\n                console.error('fromByteBuffer', name + '.' + field, '\\'' + value + '\\'', _b.toHex());\n              }\n            }\n          } catch (e) {\n            console.error(e + ' in ' + name + '.' + field);\n            b.printDebug();\n            throw e;\n          }\n        }\n      } catch (error) {\n        error.message += ' in ' + name + '.' + field;\n        throw error;\n      }\n\n      return object;\n    },\n    appendByteBuffer: function appendByteBuffer(b, object) {\n      var field = null;\n\n      try {\n        for (field in fields) {\n          var type = fields[field];\n\n          if (field === '') {\n            // structPtr\n            type.appendByteBuffer(b, object);\n          } else {\n            var appendByteBuffer = config.override[name + '.' + field + '.appendByteBuffer'];\n\n            if (appendByteBuffer) {\n              appendByteBuffer({\n                fields: fields,\n                object: object,\n                b: b\n              });\n            } else {\n              type.appendByteBuffer(b, object[field]);\n            }\n          }\n        }\n      } catch (error) {\n        try {\n          error.message += ' ' + name + '.' + field + ' = ' + JSON.stringify(object[field]);\n        } catch (e) {\n          // circular ref\n          error.message += ' ' + name + '.' + field + ' = ' + object[field];\n        }\n\n        throw error;\n      }\n    },\n    fromObject: function fromObject(serializedObject) {\n      var fromObject_struct = config.override[name + '.fromObject'];\n\n      if (fromObject_struct) {\n        var ret = fromObject_struct(serializedObject);\n\n        if (ret != null) {\n          return ret;\n        }\n      }\n\n      var result = {};\n      var field = null;\n\n      try {\n        for (field in fields) {\n          // if(config.debug) {\n          //   console.error(name, field, '(fromObject)')\n          // }\n          var type = fields[field];\n\n          if (field === '') {\n            // structPtr\n            var object = type.fromObject(serializedObject);\n            Object.assign(result, object);\n          } else {\n            var fromObject = config.override[name + '.' + field + '.fromObject'];\n\n            if (fromObject) {\n              fromObject({\n                fields: fields,\n                object: serializedObject,\n                result: result\n              });\n            } else {\n              var value = serializedObject[field];\n\n              var _object = type.fromObject(value);\n\n              result[field] = _object;\n            }\n          }\n        }\n      } catch (error) {\n        error.message += ' ' + name + '.' + field;\n        throw error;\n      }\n\n      return result;\n    },\n    toObject: function toObject() {\n      var serializedObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var toObject_struct = config.override[name + '.toObject'];\n\n      if (toObject_struct) {\n        var ret = toObject_struct(serializedObject);\n\n        if (ret != null) {\n          return ret;\n        }\n      }\n\n      var result = {};\n      var field = null;\n\n      try {\n        // if (!fields) { return result }\n        for (field in fields) {\n          var type = fields[field];\n          var toObject = config.override[name + '.' + field + '.toObject'];\n\n          if (toObject) {\n            toObject({\n              fields: fields,\n              object: serializedObject,\n              result: result,\n              config: config\n            });\n          } else {\n            if (field === '') {\n              // structPtr\n              var object = type.toObject(serializedObject, config);\n              Object.assign(result, object);\n            } else {\n              var _object2 = type.toObject(serializedObject ? serializedObject[field] : null, config);\n\n              result[field] = _object2;\n            }\n          }\n\n          if (config.debug) {\n            try {\n              var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n\n              if (serializedObject != null) {\n                var value = serializedObject[field];\n\n                if (value) {\n                  var appendByteBuffer = config.override[name + '.' + field + '.appendByteBuffer'];\n\n                  if (toObject && appendByteBuffer) {\n                    appendByteBuffer({\n                      fields: fields,\n                      object: serializedObject,\n                      b: b\n                    });\n                  } else {\n                    type.appendByteBuffer(b, value);\n                  }\n                }\n              }\n\n              b = b.copy(0, b.offset);\n              console.error('toObject', name + '.' + field, '\\'' + result[field] + '\\'', b.toHex());\n            } catch (error) {\n              // work-around to prevent debug time crash\n              error.message = name + '.' + field + ' ' + error.message;\n              console.error(error);\n            }\n          }\n        }\n      } catch (error) {\n        error.message += ' ' + name + '.' + field;\n        throw error;\n      }\n\n      return result;\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}