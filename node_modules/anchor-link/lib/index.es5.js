(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.AnchorLink = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionError = exports.IdentityError = exports.CancelError = void 0;
/**
 * Error that is thrown if a [[LinkTransport]] cancels a request.
 * @internal
 */
class CancelError extends Error {
    constructor(reason) {
        super(`User canceled request ${reason ? '(' + reason + ')' : ''}`);
        this.code = 'E_CANCEL';
    }
}
exports.CancelError = CancelError;
/**
 * Error that is thrown if an identity request fails to verify.
 * @internal
 */
class IdentityError extends Error {
    constructor(reason) {
        super(`Unable to verify identity ${reason ? '(' + reason + ')' : ''}`);
        this.code = 'E_IDENTITY';
    }
}
exports.IdentityError = IdentityError;
/**
 * Error originating from a [[LinkSession]].
 * @internal
 */
class SessionError extends Error {
    constructor(reason, code) {
        super(reason);
        this.code = code;
    }
}
exports.SessionError = SessionError;

},{}],2:[function(require,module,exports){
let pkg = require('./index')
module.exports = pkg.default
for (const key of Object.keys(pkg)) {
    if (key === 'default') continue
    module.exports[key] = pkg[key]
}

},{"./index":3}],3:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./link"), exports);
__exportStar(require("./link-session"), exports);
__exportStar(require("./errors"), exports);
// default export is Link class for convenience
const link_1 = require("./link");
exports.default = link_1.Link;
// convenience re-exports from esr
var eosio_signing_request_1 = require("eosio-signing-request");
Object.defineProperty(exports, "PlaceholderAuth", { enumerable: true, get: function () { return eosio_signing_request_1.PlaceholderAuth; } });
Object.defineProperty(exports, "PlaceholderName", { enumerable: true, get: function () { return eosio_signing_request_1.PlaceholderName; } });
Object.defineProperty(exports, "PlaceholderPermission", { enumerable: true, get: function () { return eosio_signing_request_1.PlaceholderPermission; } });

},{"./errors":1,"./link":7,"./link-session":6,"eosio-signing-request":undefined}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    version: 'eosio::abi/1.1',
    types: [],
    structs: [
        {
            name: 'sealed_message',
            base: '',
            fields: [
                {
                    name: 'from',
                    type: 'public_key',
                },
                {
                    name: 'nonce',
                    type: 'uint64',
                },
                {
                    name: 'ciphertext',
                    type: 'bytes',
                },
                {
                    name: 'checksum',
                    type: 'uint32',
                },
            ],
        },
        {
            name: 'link_create',
            base: '',
            fields: [
                {
                    name: 'session_name',
                    type: 'name',
                },
                {
                    name: 'request_key',
                    type: 'public_key',
                },
            ],
        },
        {
            name: 'link_info',
            base: '',
            fields: [
                {
                    name: 'expiration',
                    type: 'time_point_sec',
                },
            ],
        },
    ],
    actions: [],
    ricardian_clauses: [],
    error_messages: [],
    tables: [],
    abi_extensions: [],
};

},{}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaults = void 0;
/** @internal */
exports.defaults = {
    chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',
    rpc: 'https://eos.greymass.com',
    service: 'https://cb.anchor.link',
};

},{}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkFallbackSession = exports.LinkChannelSession = exports.LinkSession = void 0;
const errors_1 = require("./errors");
const utils_1 = require("./utils");
/**
 * Type describing a link session that can create a eosjs compatible
 * signature provider and transact for a specific auth.
 */
class LinkSession {
    /**
     * Convenience, remove this session from associated [[Link]] storage if set.
     * Equivalent to:
     * ```ts
     * session.link.removeSession(session.identifier, session.auth)
     * ```
     */
    async remove() {
        if (this.link.storage) {
            await this.link.removeSession(this.identifier, this.auth);
        }
    }
    /** Restore a previously serialized session. */
    static restore(link, data) {
        switch (data.type) {
            case 'channel':
                return new LinkChannelSession(link, data.data, data.metadata);
            case 'fallback':
                return new LinkFallbackSession(link, data.data, data.metadata);
            default:
                throw new Error('Unable to restore, session data invalid');
        }
    }
}
exports.LinkSession = LinkSession;
/**
 * Link session that pushes requests over a channel.
 * @internal
 */
class LinkChannelSession extends LinkSession {
    constructor(link, data, metadata) {
        super();
        this.type = 'channel';
        this.timeout = 2 * 60 * 1000; // ms
        this.link = link;
        this.auth = data.auth;
        this.publicKey = data.publicKey;
        this.channel = data.channel;
        this.identifier = data.identifier;
        this.encrypt = (request) => {
            return utils_1.sealMessage(request.encode(true, false), data.requestKey, data.channel.key);
        };
        this.metadata = {
            ...(metadata || {}),
            timeout: this.timeout,
            name: this.channel.name,
        };
        this.serialize = () => ({
            type: 'channel',
            data,
            metadata: this.metadata,
        });
    }
    onSuccess(request, result) {
        if (this.link.transport.onSuccess) {
            this.link.transport.onSuccess(request, result);
        }
    }
    onFailure(request, error) {
        if (this.link.transport.onFailure) {
            this.link.transport.onFailure(request, error);
        }
    }
    onRequest(request, cancel) {
        const info = {
            expiration: new Date(Date.now() + this.timeout).toISOString().slice(0, -1),
        };
        if (this.link.transport.onSessionRequest) {
            this.link.transport.onSessionRequest(this, request, cancel);
        }
        setTimeout(() => {
            cancel(new errors_1.SessionError('Wallet did not respond in time', 'E_TIMEOUT'));
        }, this.timeout + 500);
        request.data.info.push({
            key: 'link',
            value: utils_1.abiEncode(info, 'link_info'),
        });
        utils_1.fetch(this.channel.url, {
            method: 'POST',
            headers: {
                'X-Buoy-Wait': (this.timeout / 1000).toFixed(0),
            },
            body: this.encrypt(request),
        })
            .then((response) => {
            if (response.status !== 200) {
                cancel(new errors_1.SessionError('Unable to push message', 'E_DELIVERY'));
            }
            else {
                // request delivered
            }
        })
            .catch((error) => {
            cancel(new errors_1.SessionError(`Unable to reach link service (${error.message || String(error)})`, 'E_DELIVERY'));
        });
    }
    prepare(request) {
        if (this.link.transport.prepare) {
            return this.link.transport.prepare(request, this);
        }
        return Promise.resolve(request);
    }
    showLoading() {
        if (this.link.transport.showLoading) {
            return this.link.transport.showLoading();
        }
    }
    makeSignatureProvider() {
        return this.link.makeSignatureProvider([this.publicKey], this);
    }
    makeAuthorityProvider() {
        return this.link.makeAuthorityProvider();
    }
    transact(args, options) {
        return this.link.transact(args, options, this);
    }
}
exports.LinkChannelSession = LinkChannelSession;
/**
 * Link session that sends every request over the transport.
 * @internal
 */
class LinkFallbackSession extends LinkSession {
    constructor(link, data, metadata) {
        super();
        this.type = 'fallback';
        this.link = link;
        this.auth = data.auth;
        this.publicKey = data.publicKey;
        this.metadata = metadata || {};
        this.identifier = data.identifier;
        this.serialize = () => ({
            type: this.type,
            data,
            metadata: this.metadata,
        });
    }
    onSuccess(request, result) {
        if (this.link.transport.onSuccess) {
            this.link.transport.onSuccess(request, result);
        }
    }
    onFailure(request, error) {
        if (this.link.transport.onFailure) {
            this.link.transport.onFailure(request, error);
        }
    }
    onRequest(request, cancel) {
        if (this.link.transport.onSessionRequest) {
            this.link.transport.onSessionRequest(this, request, cancel);
        }
        else {
            this.link.transport.onRequest(request, cancel);
        }
    }
    prepare(request) {
        if (this.link.transport.prepare) {
            return this.link.transport.prepare(request, this);
        }
        return Promise.resolve(request);
    }
    showLoading() {
        if (this.link.transport.showLoading) {
            return this.link.transport.showLoading();
        }
    }
    makeSignatureProvider() {
        return this.link.makeSignatureProvider([this.publicKey], this);
    }
    makeAuthorityProvider() {
        return this.link.makeAuthorityProvider();
    }
    transact(args, options) {
        return this.link.transact(args, options, this);
    }
}
exports.LinkFallbackSession = LinkFallbackSession;

},{"./errors":1,"./utils":8}],7:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Link = void 0;
const esr = __importStar(require("eosio-signing-request"));
const eosjs_1 = require("eosjs");
const ecc = __importStar(require("eosjs-ecc"));
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const pako_1 = __importDefault(require("pako"));
const uuid_1 = require("uuid");
const errors_1 = require("./errors");
const link_options_1 = require("./link-options");
const link_session_1 = require("./link-session");
const utils_1 = require("./utils");
/**
 * Main class, also exposed as the default export of the library.
 *
 * Example:
 *
 * ```ts
 * import AnchorLink from 'anchor-link'
 * import ConsoleTransport from 'anchor-link-console-transport'
 *
 * const link = new AnchorLink({
 *     transport: new ConsoleTransport()
 * })
 *
 * const result = await link.transact({actions: myActions})
 * ```
 */
class Link {
    /** Create a new link instance. */
    constructor(options) {
        this.abiCache = new Map();
        this.pendingAbis = new Map();
        if (typeof options !== 'object') {
            throw new TypeError('Missing options object');
        }
        if (!options.transport) {
            throw new TypeError('options.transport is required, see https://github.com/greymass/anchor-link#transports');
        }
        if (options.rpc === undefined || typeof options.rpc === 'string') {
            this.rpc = new eosjs_1.JsonRpc(options.rpc || link_options_1.defaults.rpc, { fetch: utils_1.fetch });
        }
        else {
            this.rpc = options.rpc;
        }
        if (options.chainId) {
            this.chainId =
                typeof options.chainId === 'number'
                    ? esr.nameToId(options.chainId)
                    : options.chainId;
        }
        else {
            this.chainId = link_options_1.defaults.chainId;
        }
        this.serviceAddress = (options.service || link_options_1.defaults.service).trim().replace(/\/$/, '');
        this.transport = options.transport;
        if (options.storage !== null) {
            this.storage = options.storage || this.transport.storage;
        }
        this.requestOptions = {
            abiProvider: this,
            textDecoder: options.textDecoder || new TextDecoder(),
            textEncoder: options.textEncoder || new TextEncoder(),
            zlib: pako_1.default,
        };
    }
    /**
     * Fetch the ABI for given account, cached.
     * @internal
     */
    async getAbi(account) {
        let rv = this.abiCache.get(account);
        if (!rv) {
            let getAbi = this.pendingAbis.get(account);
            if (!getAbi) {
                getAbi = this.rpc.get_abi(account);
                this.pendingAbis.set(account, getAbi);
            }
            rv = (await getAbi).abi;
            this.pendingAbis.delete(account);
            if (rv) {
                this.abiCache.set(account, rv);
            }
        }
        return rv;
    }
    /**
     * Create a new unique buoy callback url.
     * @internal
     */
    createCallbackUrl() {
        return `${this.serviceAddress}/${uuid_1.v4()}`;
    }
    /**
     * Create a SigningRequest instance configured for this link.
     * @internal
     */
    async createRequest(args, transport) {
        const t = transport || this.transport;
        // generate unique callback url
        let request = await esr.SigningRequest.create({
            ...args,
            chainId: this.chainId,
            broadcast: false,
            callback: {
                url: this.createCallbackUrl(),
                background: true,
            },
        }, this.requestOptions);
        if (t.prepare) {
            request = await t.prepare(request);
        }
        return request;
    }
    /**
     * Send a SigningRequest instance using this link.
     * @internal
     */
    async sendRequest(request, transport, broadcast = false) {
        const t = transport || this.transport;
        try {
            const linkUrl = request.data.callback;
            if (!linkUrl.startsWith(this.serviceAddress)) {
                throw new Error('Request must have a link callback');
            }
            if (request.data.flags !== 2) {
                throw new Error('Invalid request flags');
            }
            // wait for callback or user cancel
            const ctx = {};
            const socket = waitForCallback(linkUrl, ctx).then((data) => {
                if (typeof data.rejected === 'string') {
                    throw new errors_1.CancelError(`Rejected by wallet: ${data.rejected}`);
                }
                return data;
            });
            const cancel = new Promise((resolve, reject) => {
                t.onRequest(request, (reason) => {
                    if (ctx.cancel) {
                        ctx.cancel();
                    }
                    if (typeof reason === 'string') {
                        reject(new errors_1.CancelError(reason));
                    }
                    else {
                        reject(reason);
                    }
                });
            });
            const payload = await Promise.race([socket, cancel]);
            const signer = {
                actor: payload.sa,
                permission: payload.sp,
            };
            const signatures = Object.keys(payload)
                .filter((key) => key.startsWith('sig') && key !== 'sig0')
                .map((key) => payload[key]);
            // recreate transaction from request response
            const resolved = await esr.ResolvedSigningRequest.fromPayload(payload, this.requestOptions);
            const info = resolved.request.getInfo();
            if (info['fuel_sig']) {
                signatures.unshift(info['fuel_sig']);
            }
            const { serializedTransaction, transaction } = resolved;
            const result = {
                request: resolved.request,
                serializedTransaction,
                transaction,
                signatures,
                payload,
                signer,
            };
            if (broadcast) {
                const res = await this.rpc.push_transaction({
                    signatures: result.signatures,
                    serializedTransaction: result.serializedTransaction,
                });
                result.processed = res.processed;
            }
            if (t.onSuccess) {
                t.onSuccess(request, result);
            }
            return result;
        }
        catch (error) {
            if (t.onFailure) {
                t.onFailure(request, error);
            }
            throw error;
        }
    }
    /**
     * Sign and optionally broadcast a EOSIO transaction, action or actions.
     *
     * Example:
     *
     * ```ts
     * let result = await myLink.transact({transaction: myTx})
     * ```
     *
     * @param args The action, actions or transaction to use.
     * @param options Options for this transact call.
     * @param transport Transport override, for internal use.
     */
    async transact(args, options, transport) {
        const t = transport || this.transport;
        const broadcast = options ? options.broadcast !== false : true;
        // Initialize the loading state of the transport
        if (t && t.showLoading) {
            t.showLoading();
        }
        // eosjs transact compat: upgrade to transaction if args have any header fields
        let anyArgs = args;
        if (args.actions &&
            (anyArgs.expiration ||
                anyArgs.ref_block_num ||
                anyArgs.ref_block_prefix ||
                anyArgs.max_net_usage_words ||
                anyArgs.max_cpu_usage_ms ||
                anyArgs.delay_sec)) {
            args = {
                transaction: {
                    expiration: '1970-01-01T00:00:00',
                    ref_block_num: 0,
                    ref_block_prefix: 0,
                    max_net_usage_words: 0,
                    max_cpu_usage_ms: 0,
                    delay_sec: 0,
                    ...anyArgs,
                },
            };
        }
        const request = await this.createRequest(args, t);
        const result = await this.sendRequest(request, t, broadcast);
        return result;
    }
    /**
     * Send an identity request and verify the identity proof.
     * @param requestPermission Optional request permission if the request is for a specific account or permission.
     * @param info Metadata to add to the request.
     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.
     */
    async identify(requestPermission, info) {
        const request = await this.createRequest({
            identity: { permission: requestPermission || null },
            info,
        });
        const res = await this.sendRequest(request);
        if (!res.request.isIdentity()) {
            throw new errors_1.IdentityError(`Unexpected response`);
        }
        const message = Buffer.concat([
            Buffer.from(request.getChainId(), 'hex'),
            Buffer.from(res.serializedTransaction),
            Buffer.alloc(32),
        ]);
        const { signer } = res;
        const signerKey = ecc.recover(res.signatures[0], message);
        const account = await this.rpc.get_account(signer.actor);
        if (!account) {
            throw new errors_1.IdentityError(`Signature from unknown account: ${signer.actor}`);
        }
        const permission = account.permissions.find(({ perm_name }) => perm_name === signer.permission);
        if (!permission) {
            throw new errors_1.IdentityError(`${signer.actor} signed for unknown permission: ${signer.permission}`);
        }
        const auth = permission.required_auth;
        const keyAuth = auth.keys.find(({ key }) => utils_1.publicKeyEqual(key, signerKey));
        if (!keyAuth) {
            throw new errors_1.IdentityError(`${formatAuth(signer)} has no key matching id signature`);
        }
        if (auth.threshold > keyAuth.weight) {
            throw new errors_1.IdentityError(`${formatAuth(signer)} signature does not reach auth threshold`);
        }
        if (requestPermission) {
            if ((requestPermission.actor !== esr.PlaceholderName &&
                requestPermission.actor !== signer.actor) ||
                (requestPermission.permission !== esr.PlaceholderPermission &&
                    requestPermission.permission !== signer.permission)) {
                throw new errors_1.IdentityError(`Unexpected identity proof from ${formatAuth(signer)}, expected ${formatAuth(requestPermission)} `);
            }
        }
        return {
            ...res,
            account,
            signerKey,
        };
    }
    /**
     * Login and create a persistent session.
     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).
     *                   Should be set to the contract account if applicable.
     */
    async login(identifier) {
        const privateKey = await utils_1.generatePrivateKey();
        const requestKey = ecc.privateToPublic(privateKey);
        const createInfo = {
            session_name: identifier,
            request_key: requestKey,
        };
        const res = await this.identify(undefined, {
            link: utils_1.abiEncode(createInfo, 'link_create'),
        });
        const metadata = { sameDevice: res.request.getRawInfo()['return_path'] !== undefined };
        let session;
        if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {
            session = new link_session_1.LinkChannelSession(this, {
                identifier,
                auth: res.signer,
                publicKey: res.signerKey,
                channel: {
                    url: res.payload.link_ch,
                    key: res.payload.link_key,
                    name: res.payload.link_name,
                },
                requestKey: privateKey,
            }, metadata);
        }
        else {
            session = new link_session_1.LinkFallbackSession(this, {
                identifier,
                auth: res.signer,
                publicKey: res.signerKey,
            }, metadata);
        }
        if (this.storage) {
            await this.storeSession(identifier, session);
        }
        return {
            ...res,
            session,
        };
    }
    /**
     * Restore previous session, see [[Link.login]] to create a new session.
     * @param identifier The session identifier, should be same as what was used when creating the session with [[Link.login]].
     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.
     * @returns A [[LinkSession]] instance or null if no session can be found.
     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.
     **/
    async restoreSession(identifier, auth) {
        if (!this.storage) {
            throw new Error('Unable to restore session: No storage adapter configured');
        }
        let key;
        if (auth) {
            key = this.sessionKey(identifier, formatAuth(auth));
        }
        else {
            let latest = (await this.listSessions(identifier))[0];
            if (!latest) {
                return null;
            }
            key = this.sessionKey(identifier, formatAuth(latest));
        }
        let data = await this.storage.read(key);
        if (!data) {
            return null;
        }
        let sessionData;
        try {
            sessionData = JSON.parse(data);
        }
        catch (error) {
            throw new Error(`Unable to restore session: Stored JSON invalid (${error.message || String(error)})`);
        }
        const session = link_session_1.LinkSession.restore(this, sessionData);
        if (auth) {
            // update latest used
            await this.touchSession(identifier, auth);
        }
        return session;
    }
    /**
     * List stored session auths for given identifier.
     * The most recently used session is at the top (index 0).
     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.
     **/
    async listSessions(identifier) {
        if (!this.storage) {
            throw new Error('Unable to list sessions: No storage adapter configured');
        }
        let key = this.sessionKey(identifier, 'list');
        let list;
        try {
            list = JSON.parse((await this.storage.read(key)) || '[]');
        }
        catch (error) {
            throw new Error(`Unable to list sessions: Stored JSON invalid (${error.message || String(error)})`);
        }
        return list;
    }
    /**
     * Remove stored session for given identifier and auth.
     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.
     */
    async removeSession(identifier, auth) {
        if (!this.storage) {
            throw new Error('Unable to remove session: No storage adapter configured');
        }
        let key = this.sessionKey(identifier, formatAuth(auth));
        await this.storage.remove(key);
        await this.touchSession(identifier, auth, true);
    }
    /**
     * Remove all stored sessions for given identifier.
     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.
     */
    async clearSessions(identifier) {
        if (!this.storage) {
            throw new Error('Unable to clear sessions: No storage adapter configured');
        }
        for (const auth of await this.listSessions(identifier)) {
            await this.removeSession(identifier, auth);
        }
    }
    /**
     * Create an eosjs compatible signature provider using this link.
     * @param availableKeys Keys the created provider will claim to be able to sign for.
     * @param transport (internal) Transport override for this call.
     * @note We don't know what keys are available so those have to be provided,
     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].
     */
    makeSignatureProvider(availableKeys, transport) {
        return {
            getAvailableKeys: async () => availableKeys,
            sign: async (args) => {
                const t = transport || this.transport;
                let request = esr.SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, this.requestOptions);
                request.setCallback(this.createCallbackUrl(), true);
                request.setBroadcast(false);
                if (t.prepare) {
                    request = await t.prepare(request);
                }
                const { serializedTransaction, signatures, } = await this.sendRequest(request, t);
                return {
                    ...args,
                    serializedTransaction,
                    signatures,
                };
            },
        };
    }
    /**
     * Create an eosjs authority provider using this link.
     * @note Uses the configured RPC Node's `/v1/chain/get_required_keys` API to resolve keys.
     */
    makeAuthorityProvider() {
        const { rpc } = this;
        return {
            async getRequiredKeys(args) {
                const { availableKeys, transaction } = args;
                const result = await rpc.fetch('/v1/chain/get_required_keys', {
                    transaction,
                    available_keys: availableKeys.map(utils_1.normalizePublicKey),
                });
                return result.required_keys.map(utils_1.normalizePublicKey);
            },
        };
    }
    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */
    async touchSession(identifier, auth, remove = false) {
        let auths = await this.listSessions(identifier);
        let formattedAuth = formatAuth(auth);
        let existing = auths.findIndex((a) => formatAuth(a) === formattedAuth);
        if (existing >= 0) {
            auths.splice(existing, 1);
        }
        if (remove === false) {
            auths.unshift(auth);
        }
        let key = this.sessionKey(identifier, 'list');
        await this.storage.write(key, JSON.stringify(auths));
    }
    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */
    async storeSession(identifier, session) {
        let key = this.sessionKey(identifier, formatAuth(session.auth));
        let data = JSON.stringify(session.serialize());
        await this.storage.write(key, data);
        await this.touchSession(identifier, session.auth);
    }
    /** Session storage key for identifier and suffix. */
    sessionKey(identifier, suffix) {
        return [this.chainId, identifier, suffix].join('-');
    }
}
exports.Link = Link;
/**
 * Connect to a WebSocket channel and wait for a message.
 * @internal
 */
function waitForCallback(url, ctx) {
    return new Promise((resolve, reject) => {
        let active = true;
        let retries = 0;
        const socketUrl = url.replace(/^http/, 'ws');
        const handleResponse = (response) => {
            try {
                resolve(JSON.parse(response));
            }
            catch (error) {
                error.message = 'Unable to parse callback JSON: ' + error.message;
                reject(error);
            }
        };
        const connect = () => {
            const socket = new isomorphic_ws_1.default(socketUrl);
            ctx.cancel = () => {
                active = false;
                if (socket.readyState === isomorphic_ws_1.default.OPEN ||
                    socket.readyState === isomorphic_ws_1.default.CONNECTING) {
                    socket.close();
                }
            };
            socket.onmessage = (event) => {
                active = false;
                if (socket.readyState === isomorphic_ws_1.default.OPEN) {
                    socket.close();
                }
                if (typeof Blob !== 'undefined' && event.data instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = () => {
                        handleResponse(reader.result);
                    };
                    reader.onerror = (error) => {
                        reject(error);
                    };
                    reader.readAsText(event.data);
                }
                else {
                    if (typeof event.data === 'string') {
                        handleResponse(event.data);
                    }
                    else {
                        handleResponse(event.data.toString());
                    }
                }
            };
            socket.onopen = () => {
                retries = 0;
            };
            socket.onerror = (error) => { };
            socket.onclose = (close) => {
                if (active) {
                    setTimeout(connect, backoff(retries++));
                }
            };
        };
        connect();
    });
}
/**
 * Exponential backoff function that caps off at 10s after 10 tries.
 * https://i.imgur.com/IrUDcJp.png
 * @internal
 */
function backoff(tries) {
    return Math.min(Math.pow(tries * 10, 2), 10 * 1000);
}
/**
 * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.
 * @internal
 */
function formatAuth(auth) {
    let { actor, permission } = auth;
    if (actor === esr.PlaceholderName) {
        actor = '<any>';
    }
    if (permission === esr.PlaceholderName || permission === esr.PlaceholderPermission) {
        permission = '<any>';
    }
    return `${actor}@${permission}`;
}

},{"./errors":1,"./link-options":5,"./link-session":6,"./utils":8,"eosio-signing-request":undefined,"eosjs":undefined,"eosjs-ecc":undefined,"isomorphic-ws":undefined,"pako":undefined,"uuid":undefined}],8:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePrivateKey = exports.publicKeyEqual = exports.normalizePublicKey = exports.sealMessage = exports.abiDecode = exports.abiEncode = exports.fetch = void 0;
const eosjs_1 = require("eosjs");
const ecc = __importStar(require("eosjs-ecc"));
const fetch_ponyfill_1 = __importDefault(require("fetch-ponyfill"));
const link_abi_data_1 = __importDefault(require("./link-abi-data"));
/** @internal */
exports.fetch = fetch_ponyfill_1.default().fetch;
/** @internal */
const types = eosjs_1.Serialize.getTypesFromAbi(eosjs_1.Serialize.createInitialTypes(), link_abi_data_1.default);
/**
 * Helper to ABI encode value.
 * @internal
 */
function abiEncode(value, typeName) {
    let type = types.get(typeName);
    if (!type) {
        throw new Error(`No such type: ${typeName}`);
    }
    let buf = new eosjs_1.Serialize.SerialBuffer();
    type.serialize(buf, value);
    return buf.asUint8Array();
}
exports.abiEncode = abiEncode;
/**
 * Helper to ABI decode data.
 * @internal
 */
function abiDecode(data, typeName) {
    let type = types.get(typeName);
    if (!type) {
        throw new Error(`No such type: ${typeName}`);
    }
    if (typeof data === 'string') {
        data = eosjs_1.Serialize.hexToUint8Array(data);
    }
    else if (!(data instanceof Uint8Array)) {
        data = new Uint8Array(data);
    }
    let buf = new eosjs_1.Serialize.SerialBuffer({
        array: data,
    });
    return type.deserialize(buf);
}
exports.abiDecode = abiDecode;
/**
 * Encrypt a message using AES and shared secret derived from given keys.
 * @internal
 */
function sealMessage(message, privateKey, publicKey) {
    const res = ecc.Aes.encrypt(privateKey, publicKey, message);
    const data = {
        from: ecc.privateToPublic(privateKey),
        nonce: res.nonce.toString(),
        ciphertext: res.message,
        checksum: res.checksum,
    };
    return abiEncode(data, 'sealed_message');
}
exports.sealMessage = sealMessage;
/**
 * Ensure public key is in new PUB_ format.
 * @internal
 */
function normalizePublicKey(key) {
    if (key.startsWith('PUB_')) {
        return key;
    }
    return eosjs_1.Numeric.publicKeyToString(eosjs_1.Numeric.stringToPublicKey('EOS' + key.substr(-50)));
}
exports.normalizePublicKey = normalizePublicKey;
/**
 * Return true if given public keys are equal.
 * @internal
 */
function publicKeyEqual(keyA, keyB) {
    return normalizePublicKey(keyA) === normalizePublicKey(keyB);
}
exports.publicKeyEqual = publicKeyEqual;
/**
 * Generate a random private key.
 * Uses browser crypto if available, otherwise falls back to slow eosjs-ecc.
 * @internal
 */
async function generatePrivateKey() {
    if (typeof window !== 'undefined' && window.crypto) {
        const data = new Uint32Array(32);
        window.crypto.getRandomValues(data);
        return ecc.PrivateKey.fromBuffer(Buffer.from(data)).toString();
    }
    else {
        return await ecc.randomKey();
    }
}
exports.generatePrivateKey = generatePrivateKey;

},{"./link-abi-data":4,"eosjs":undefined,"eosjs-ecc":undefined,"fetch-ponyfill":undefined}]},{},[2])(2)
});
//# sourceMappingURL=index.es5.js.map
