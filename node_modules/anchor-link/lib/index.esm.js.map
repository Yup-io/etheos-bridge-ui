{"version":3,"file":"index.esm.js","sources":["../src/errors.ts","../src/link-options.ts","../node_modules/tslib/tslib.es6.js","../src/link-types.ts","../src/utils.ts","../src/link-session.ts","../src/link-callback.ts","../src/link.ts"],"sourcesContent":["/**\n * Error codes. Accessible using the `code` property on errors thrown by [[Link]] and [[LinkSession]].\n * - `E_DELIVERY`: Unable to request message to wallet.\n * - `E_TIMEOUT`: Request was delivered but user/wallet didn't respond in time.\n * - `E_CANCEL`: The [[LinkTransport]] canceled the request.\n * - `E_IDENTITY`: Identity proof failed to verify.\n */\nexport type LinkErrorCode = 'E_DELIVERY' | 'E_TIMEOUT' | 'E_CANCEL' | 'E_IDENTITY'\n\n/**\n * Error that is thrown if a [[LinkTransport]] cancels a request.\n * @internal\n */\nexport class CancelError extends Error {\n    public code = 'E_CANCEL'\n    constructor(reason?: string) {\n        super(`User canceled request ${reason ? '(' + reason + ')' : ''}`)\n    }\n}\n\n/**\n * Error that is thrown if an identity request fails to verify.\n * @internal\n */\nexport class IdentityError extends Error {\n    public code = 'E_IDENTITY'\n    constructor(reason?: string) {\n        super(`Unable to verify identity ${reason ? '(' + reason + ')' : ''}`)\n    }\n}\n\n/**\n * Error originating from a [[LinkSession]].\n * @internal\n */\nexport class SessionError extends Error {\n    public code: 'E_DELIVERY' | 'E_TIMEOUT'\n    constructor(reason: string, code: 'E_DELIVERY' | 'E_TIMEOUT') {\n        super(reason)\n        this.code = code\n    }\n}\n","import {APIClient} from '@greymass/eosio'\nimport {ChainIdType} from 'eosio-signing-request'\nimport {LinkStorage} from './link-storage'\nimport {LinkTransport} from './link-transport'\nimport {LinkCallbackService} from './link-callback'\n\n/**\n * Available options when creating a new [[Link]] instance.\n */\nexport interface LinkOptions {\n    /**\n     * Link transport responsible for presenting signing requests to user, required.\n     */\n    transport: LinkTransport\n    /**\n     * ChainID or esr chain name alias for which the link is valid.\n     * Defaults to EOS (aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906).\n     */\n    chainId?: ChainIdType\n    /**\n     * URL to EOSIO node to communicate with or a @greymass/eosio APIClient instance.\n     * Defaults to https://eos.greymass.com\n     */\n    client?: string | APIClient\n    /**\n     * URL to link callback service.\n     * Defaults to https://cb.anchor.link.\n     */\n    service?: string | LinkCallbackService\n    /**\n     * Optional storage adapter that will be used to persist sessions if set.\n     * If not storage adapter is set but the given transport provides a storage, that will be used.\n     * Explicitly set this to `null` to force no storage.\n     */\n    storage?: LinkStorage | null\n    /**\n     * Text encoder, only needed in old browsers or if used in node.js versions prior to v13.\n     */\n    textEncoder?: TextEncoder\n    /**\n     * Text decoder, only needed in old browsers or if used in node.js versions prior to v13.\n     */\n    textDecoder?: TextDecoder\n}\n\nexport namespace LinkOptions {\n    /** @internal */\n    export const defaults = {\n        chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',\n        client: 'https://eos.greymass.com',\n        service: 'https://cb.anchor.link',\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {Bytes, Name, PublicKey, Struct, TimePointSec, UInt32, UInt64} from '@greymass/eosio'\n\n@Struct.type('sealed_message')\nexport class SealedMessage extends Struct {\n    @Struct.field('public_key') from!: PublicKey\n    @Struct.field('uint64') nonce!: UInt64\n    @Struct.field('bytes') ciphertext!: Bytes\n    @Struct.field('uint32') checksum!: UInt32\n}\n\n@Struct.type('link_create')\nexport class LinkCreate extends Struct {\n    @Struct.field('name') session_name!: Name\n    @Struct.field('public_key') request_key!: PublicKey\n}\n\n@Struct.type('link_info')\nexport class LinkInfo extends Struct {\n    @Struct.field('time_point_sec') expiration!: TimePointSec\n}\n","import makeFetch from 'fetch-ponyfill'\nimport {Bytes, Checksum256, PrivateKey, PublicKey, Serializer, UInt64} from '@greymass/eosio'\nimport {SealedMessage} from './link-types'\n\nimport {AES_CBC} from 'asmcrypto.js'\n\n/** @internal */\nexport const fetch = makeFetch().fetch\n\n/**\n * Encrypt a message using AES and shared secret derived from given keys.\n * @internal\n */\nexport function sealMessage(\n    message: string,\n    privateKey: PrivateKey,\n    publicKey: PublicKey,\n    nonce?: UInt64\n): SealedMessage {\n    const secret = privateKey.sharedSecret(publicKey)\n    if (!nonce) {\n        nonce = UInt64.random()\n    }\n    const key = Serializer.encode({object: nonce}).appending(secret.array).sha512Digest\n    const cbc = new AES_CBC(key.array.slice(0, 32), key.array.slice(32, 48))\n    const ciphertext = Bytes.from(cbc.encrypt(Bytes.from(message, 'utf8').array))\n    const checksumView = new DataView(Checksum256.hash(key.array).array.buffer)\n    const checksum = checksumView.getUint32(0, true)\n    return SealedMessage.from({\n        from: privateKey.toPublic(),\n        nonce,\n        ciphertext,\n        checksum,\n    })\n}\n","import {\n    Name,\n    NameType,\n    PermissionLevel,\n    PermissionLevelType,\n    PrivateKey,\n    PrivateKeyType,\n    PublicKey,\n    PublicKeyType,\n    Serializer,\n} from '@greymass/eosio'\n\nimport {SigningRequest} from 'eosio-signing-request'\n\nimport {SessionError} from './errors'\nimport {Link, TransactArgs, TransactOptions, TransactResult} from './link'\nimport {LinkTransport} from './link-transport'\nimport {LinkInfo, SealedMessage} from './link-types'\nimport {fetch, sealMessage} from './utils'\n\n/**\n * Type describing a link session that can create a eosjs compatible\n * signature provider and transact for a specific auth.\n */\nexport abstract class LinkSession {\n    /** The underlying link instance used by the session. */\n    abstract link: Link\n    /** App identifier that owns the session. */\n    abstract identifier: Name\n    /** The public key the session can sign for. */\n    abstract publicKey: PublicKey\n    /** The EOSIO auth (a.k.a. permission level) the session can sign for. */\n    abstract auth: PermissionLevel\n    /** Session type, e.g. 'channel'.  */\n    abstract type: string\n    /** Arbitrary metadata that will be serialized with the session. */\n    abstract metadata: {[key: string]: any}\n    /** Creates a eosjs compatible signature provider that can sign for the session public key. */\n    abstract makeSignatureProvider(): any\n    /**\n     * Transact using this session. See [[Link.transact]].\n     */\n    abstract transact(args: TransactArgs, options?: TransactOptions): Promise<TransactResult>\n    /** Returns a JSON-encodable object that can be used recreate the session. */\n    abstract serialize(): SerializedLinkSession\n    /**\n     * Convenience, remove this session from associated [[Link]] storage if set.\n     * Equivalent to:\n     * ```ts\n     * session.link.removeSession(session.identifier, session.auth)\n     * ```\n     */\n    async remove() {\n        if (this.link.storage) {\n            await this.link.removeSession(this.identifier, this.auth)\n        }\n    }\n    /** Restore a previously serialized session. */\n    static restore(link: Link, data: SerializedLinkSession): LinkSession {\n        switch (data.type) {\n            case 'channel':\n                return new LinkChannelSession(link, data.data, data.metadata)\n            case 'fallback':\n                return new LinkFallbackSession(link, data.data, data.metadata)\n            default:\n                throw new Error('Unable to restore, session data invalid')\n        }\n    }\n}\n\n/** @internal */\nexport interface SerializedLinkSession {\n    type: string\n    metadata: {[key: string]: any}\n    data: any\n}\n\n/** @internal */\ninterface ChannelInfo {\n    /** Public key requests are encrypted to. */\n    key: PublicKeyType\n    /** The wallet given channel name, usually the device name. */\n    name: string\n    /** The channel push url. */\n    url: string\n}\n\n/** @internal */\nexport interface LinkChannelSessionData {\n    /** App identifier that owns the session. */\n    identifier: NameType\n    /** Authenticated user permission. */\n    auth: PermissionLevelType\n    /** Public key of authenticated user */\n    publicKey: PublicKeyType\n    /** The wallet channel url. */\n    channel: ChannelInfo\n    /** The private request key. */\n    requestKey: PrivateKeyType\n}\n\n/**\n * Link session that pushes requests over a channel.\n * @internal\n */\nexport class LinkChannelSession extends LinkSession implements LinkTransport {\n    readonly link: Link\n    readonly auth: PermissionLevel\n    readonly identifier: Name\n    readonly type = 'channel'\n    readonly metadata\n    readonly publicKey: PublicKey\n    serialize: () => SerializedLinkSession\n    private channel: ChannelInfo\n    private timeout = 2 * 60 * 1000 // ms\n    private encrypt: (request: SigningRequest) => SealedMessage\n\n    constructor(link: Link, data: LinkChannelSessionData, metadata: any) {\n        super()\n        this.link = link\n        this.auth = PermissionLevel.from(data.auth)\n        this.publicKey = PublicKey.from(data.publicKey)\n        this.channel = data.channel\n        this.identifier = Name.from(data.identifier)\n        const privateKey = PrivateKey.from(data.requestKey)\n        const publicKey = PublicKey.from(data.channel.key)\n        this.encrypt = (request) => {\n            return sealMessage(request.encode(true, false), privateKey, publicKey)\n        }\n        this.metadata = {\n            ...(metadata || {}),\n            timeout: this.timeout,\n            name: this.channel.name,\n        }\n        this.serialize = () => ({\n            type: 'channel',\n            data,\n            metadata: this.metadata,\n        })\n    }\n\n    onSuccess(request, result) {\n        if (this.link.transport.onSuccess) {\n            this.link.transport.onSuccess(request, result)\n        }\n    }\n\n    onFailure(request, error) {\n        if (this.link.transport.onFailure) {\n            this.link.transport.onFailure(request, error)\n        }\n    }\n\n    onRequest(request: SigningRequest, cancel) {\n        const info = LinkInfo.from({\n            expiration: new Date(Date.now() + this.timeout).toISOString().slice(0, -1),\n        })\n        if (this.link.transport.onSessionRequest) {\n            this.link.transport.onSessionRequest(this, request, cancel)\n        }\n        setTimeout(() => {\n            cancel(new SessionError('Wallet did not respond in time', 'E_TIMEOUT'))\n        }, this.timeout + 500)\n        request.setInfoKey('link', info)\n        fetch(this.channel.url, {\n            method: 'POST',\n            headers: {\n                'X-Buoy-Wait': (this.timeout / 1000).toFixed(0),\n            },\n            body: Serializer.encode({object: this.encrypt(request)}).array,\n        })\n            .then((response) => {\n                if (response.status !== 200) {\n                    cancel(new SessionError('Unable to push message', 'E_DELIVERY'))\n                } else {\n                    // request delivered\n                }\n            })\n            .catch((error) => {\n                cancel(\n                    new SessionError(\n                        `Unable to reach link service (${error.message || String(error)})`,\n                        'E_DELIVERY'\n                    )\n                )\n            })\n    }\n\n    prepare(request) {\n        if (this.link.transport.prepare) {\n            return this.link.transport.prepare(request, this)\n        }\n        return Promise.resolve(request)\n    }\n\n    showLoading() {\n        if (this.link.transport.showLoading) {\n            return this.link.transport.showLoading()\n        }\n    }\n\n    public makeSignatureProvider(): any {\n        return this.link.makeSignatureProvider([this.publicKey.toString()], this)\n    }\n\n    transact(args: TransactArgs, options?: TransactOptions) {\n        return this.link.transact(args, options, this)\n    }\n}\n\n/** @internal */\nexport interface LinkFallbackSessionData {\n    auth: PermissionLevelType\n    publicKey: PublicKeyType\n    identifier: NameType\n}\n\n/**\n * Link session that sends every request over the transport.\n * @internal\n */\nexport class LinkFallbackSession extends LinkSession implements LinkTransport {\n    readonly link: Link\n    readonly auth: PermissionLevel\n    readonly type = 'fallback'\n    readonly identifier: Name\n    readonly metadata: {[key: string]: any}\n    readonly publicKey: PublicKey\n    serialize: () => SerializedLinkSession\n\n    constructor(link: Link, data: LinkFallbackSessionData, metadata: any) {\n        super()\n        this.link = link\n        this.auth = PermissionLevel.from(data.auth)\n        this.publicKey = PublicKey.from(data.publicKey)\n        this.metadata = metadata || {}\n        this.identifier = Name.from(data.identifier)\n        this.serialize = () => ({\n            type: this.type,\n            data,\n            metadata: this.metadata,\n        })\n    }\n\n    onSuccess(request, result) {\n        if (this.link.transport.onSuccess) {\n            this.link.transport.onSuccess(request, result)\n        }\n    }\n\n    onFailure(request, error) {\n        if (this.link.transport.onFailure) {\n            this.link.transport.onFailure(request, error)\n        }\n    }\n\n    onRequest(request, cancel) {\n        if (this.link.transport.onSessionRequest) {\n            this.link.transport.onSessionRequest(this, request, cancel)\n        } else {\n            this.link.transport.onRequest(request, cancel)\n        }\n    }\n\n    prepare(request) {\n        if (this.link.transport.prepare) {\n            return this.link.transport.prepare(request, this)\n        }\n        return Promise.resolve(request)\n    }\n\n    showLoading() {\n        if (this.link.transport.showLoading) {\n            return this.link.transport.showLoading()\n        }\n    }\n\n    public makeSignatureProvider(): any {\n        return this.link.makeSignatureProvider([this.publicKey.toString()], this)\n    }\n\n    transact(args: TransactArgs, options?: TransactOptions) {\n        return this.link.transact(args, options, this)\n    }\n}\n","import {v4 as uuid} from 'uuid'\nimport {CallbackPayload} from 'eosio-signing-request'\nimport WebSocket from 'isomorphic-ws'\n\nimport {fetch} from './utils'\n\n/** Service that handles waiting for a ESR callback to be sent to an url. */\nexport interface LinkCallbackService {\n    create(): LinkCallback\n}\n\n/** Callback that can be waited for. */\nexport interface LinkCallback {\n    /** Url that should be hit to trigger the callback. */\n    url: string\n    /** Wait for the callback to resolve. */\n    wait(): Promise<CallbackPayload>\n    /** Cancel a pending callback. */\n    cancel(): void\n}\n\n/** @internal */\nexport class BuoyCallbackService implements LinkCallbackService {\n    readonly address: string\n    constructor(address: string) {\n        this.address = address.trim().replace(/\\/$/, '')\n    }\n\n    create() {\n        const url = `${this.address}/${uuid()}`\n        return new BuoyCallback(url)\n    }\n}\n\n/** @internal */\nclass BuoyCallback implements LinkCallback {\n    constructor(readonly url: string) {}\n    private ctx: {cancel?: () => void} = {}\n    wait() {\n        if (this.url.includes('hyperbuoy')) {\n            return pollForCallback(this.url, this.ctx)\n        } else {\n            return waitForCallback(this.url, this.ctx)\n        }\n    }\n    cancel() {\n        if (this.ctx.cancel) {\n            this.ctx.cancel()\n        }\n    }\n}\n\n/**\n * Connect to a WebSocket channel and wait for a message.\n * @internal\n */\nfunction waitForCallback(url: string, ctx: {cancel?: () => void}) {\n    return new Promise<CallbackPayload>((resolve, reject) => {\n        let active = true\n        let retries = 0\n        const socketUrl = url.replace(/^http/, 'ws')\n        const handleResponse = (response: string) => {\n            try {\n                resolve(JSON.parse(response))\n            } catch (error) {\n                error.message = 'Unable to parse callback JSON: ' + error.message\n                reject(error)\n            }\n        }\n        const connect = () => {\n            const socket = new WebSocket(socketUrl)\n            ctx.cancel = () => {\n                active = false\n                if (\n                    socket.readyState === WebSocket.OPEN ||\n                    socket.readyState === WebSocket.CONNECTING\n                ) {\n                    socket.close()\n                }\n            }\n            socket.onmessage = (event) => {\n                active = false\n                if (socket.readyState === WebSocket.OPEN) {\n                    socket.close()\n                }\n                if (typeof Blob !== 'undefined' && event.data instanceof Blob) {\n                    const reader = new FileReader()\n                    reader.onload = () => {\n                        handleResponse(reader.result as string)\n                    }\n                    reader.onerror = (error) => {\n                        reject(error)\n                    }\n                    reader.readAsText(event.data)\n                } else {\n                    if (typeof event.data === 'string') {\n                        handleResponse(event.data)\n                    } else {\n                        handleResponse(event.data.toString())\n                    }\n                }\n            }\n            socket.onopen = () => {\n                retries = 0\n            }\n            socket.onclose = () => {\n                if (active) {\n                    setTimeout(connect, backoff(retries++))\n                }\n            }\n        }\n        connect()\n    })\n}\n\n/**\n * Long-poll for message.\n * @internal\n */\nasync function pollForCallback(url: string, ctx: {cancel?: () => void}): Promise<CallbackPayload> {\n    let active = true\n    ctx.cancel = () => {\n        active = false\n    }\n    while (active) {\n        try {\n            const res = await fetch(url)\n            if (res.status === 408) {\n                continue\n            } else if (res.status === 200) {\n                return await res.json()\n            } else {\n                throw new Error(`HTTP ${res.status}: ${res.statusText}`)\n            }\n        } catch (error) {\n            // eslint-disable-next-line no-console\n            console.warn('Unexpected hyperbuoy error', error)\n        }\n        await sleep(1000)\n    }\n    return new Promise<CallbackPayload>(() => {\n        // noop\n    })\n}\n\n/**\n * Exponential backoff function that caps off at 10s after 10 tries.\n * https://i.imgur.com/IrUDcJp.png\n * @internal\n */\nfunction backoff(tries: number): number {\n    return Math.min(Math.pow(tries * 10, 2), 10 * 1000)\n}\n\n/**\n * Return promise that resolves after given milliseconds.\n * @internal\n */\nfunction sleep(ms: number) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms)\n    })\n}\n","import zlib from 'pako'\n\nimport {\n    ABIDef,\n    ABISerializable,\n    AnyAction,\n    AnyTransaction,\n    API,\n    APIClient,\n    Bytes,\n    Name,\n    NameType,\n    PermissionLevel,\n    PermissionLevelType,\n    PrivateKey,\n    PublicKey,\n    Serializer,\n    Signature,\n    SignedTransaction,\n    Transaction,\n} from '@greymass/eosio'\n\nimport {\n    AbiProvider,\n    CallbackPayload,\n    ChainId,\n    PlaceholderName,\n    PlaceholderPermission,\n    ResolvedSigningRequest,\n    ResolvedTransaction,\n    SigningRequest,\n    SigningRequestCreateArguments,\n    SigningRequestEncodingOptions,\n} from 'eosio-signing-request'\n\nimport {CancelError, IdentityError} from './errors'\nimport {LinkOptions} from './link-options'\nimport {LinkChannelSession, LinkFallbackSession, LinkSession} from './link-session'\nimport {LinkStorage} from './link-storage'\nimport {LinkTransport} from './link-transport'\nimport {LinkCreate} from './link-types'\nimport {BuoyCallbackService, LinkCallback, LinkCallbackService} from './link-callback'\n\n/**\n * Payload accepted by the [[Link.transact]] method.\n * Note that one of `action`, `actions` or `transaction` must be set.\n */\nexport interface TransactArgs {\n    /** Full transaction to sign. */\n    transaction?: AnyTransaction\n    /** Action to sign. */\n    action?: AnyAction\n    /** Actions to sign. */\n    actions?: AnyAction[]\n}\n\n/**\n * Options for the [[Link.transact]] method.\n */\nexport interface TransactOptions {\n    /**\n     * Whether to broadcast the transaction or just return the signature.\n     * Defaults to true.\n     */\n    broadcast?: boolean\n}\n\n/**\n * The result of a [[Link.transact]] call.\n */\nexport interface TransactResult {\n    /** The signing request that was sent. */\n    request: SigningRequest\n    /** The transaction signatures. */\n    signatures: Signature[]\n    /** The callback payload. */\n    payload: CallbackPayload\n    /** The signer authority. */\n    signer: PermissionLevel\n    /** The resulting transaction. */\n    transaction: Transaction\n    /** Resolved version of transaction. */\n    resolvedTransaction: ResolvedTransaction\n    /** Push transaction response from api node, only present if transaction was broadcast. */\n    processed?: {[key: string]: any}\n}\n\n/**\n * The result of a [[Link.identify]] call.\n */\nexport interface IdentifyResult extends TransactResult {\n    /** The identified account. */\n    account: API.v1.AccountObject\n    /** The public key that signed the identity proof.  */\n    signerKey: PublicKey\n}\n\n/**\n * The result of a [[Link.login]] call.\n */\nexport interface LoginResult extends IdentifyResult {\n    /** The session created by the login. */\n    session: LinkSession\n}\n\n/**\n * Main class, also exposed as the default export of the library.\n *\n * Example:\n *\n * ```ts\n * import AnchorLink from 'anchor-link'\n * import ConsoleTransport from 'anchor-link-console-transport'\n *\n * const link = new AnchorLink({\n *     transport: new ConsoleTransport()\n * })\n *\n * const result = await link.transact({actions: myActions})\n * ```\n */\nexport class Link implements AbiProvider {\n    /** The eosjs-core api client instance used to communicate with the EOSIO node. */\n    public readonly client: APIClient\n    /** Transport used to deliver requests to the user wallet. */\n    public readonly transport: LinkTransport\n    /** EOSIO ChainID for which requests are valid. */\n    public readonly chainId: ChainId\n    /** Storage adapter used to persist sessions. */\n    public readonly storage?: LinkStorage\n\n    private callbackService: LinkCallbackService\n    private requestOptions: SigningRequestEncodingOptions\n    private abiCache = new Map<string, ABIDef>()\n    private pendingAbis = new Map<string, Promise<API.v1.GetAbiResponse>>()\n\n    /** Create a new link instance. */\n    constructor(options: LinkOptions) {\n        if (typeof options !== 'object') {\n            throw new TypeError('Missing options object')\n        }\n        if (!options.transport) {\n            throw new TypeError(\n                'options.transport is required, see https://github.com/greymass/anchor-link#transports'\n            )\n        }\n        if (options.client === undefined || typeof options.client === 'string') {\n            this.client = new APIClient({url: options.client || LinkOptions.defaults.client})\n        } else {\n            this.client = options.client\n        }\n        this.chainId = ChainId.from(options.chainId || LinkOptions.defaults.chainId)\n        if (options.service === undefined || typeof options.service === 'string') {\n            this.callbackService = new BuoyCallbackService(\n                options.service || LinkOptions.defaults.service\n            )\n        } else {\n            this.callbackService = options.service\n        }\n        this.transport = options.transport\n        if (options.storage !== null) {\n            this.storage = options.storage || this.transport.storage\n        }\n        this.requestOptions = {\n            abiProvider: this,\n            zlib,\n        }\n    }\n\n    /**\n     * Fetch the ABI for given account, cached.\n     * @internal\n     */\n    public async getAbi(account: Name) {\n        const key = account.toString()\n        let rv = this.abiCache.get(key)\n        if (!rv) {\n            let getAbi = this.pendingAbis.get(key)\n            if (!getAbi) {\n                getAbi = this.client.v1.chain.get_abi(account)\n                this.pendingAbis.set(key, getAbi)\n            }\n            rv = (await getAbi).abi\n            this.pendingAbis.delete(key)\n            if (rv) {\n                this.abiCache.set(key, rv)\n            }\n        }\n        return rv as ABIDef\n    }\n\n    /**\n     * Create a SigningRequest instance configured for this link.\n     * @internal\n     */\n    public async createRequest(args: SigningRequestCreateArguments, transport?: LinkTransport) {\n        const t = transport || this.transport\n        let request = await SigningRequest.create(\n            {\n                ...args,\n                chainId: this.chainId.toString(),\n                broadcast: false,\n            },\n            this.requestOptions\n        )\n        if (t.prepare) {\n            request = await t.prepare(request)\n        }\n        const callback = this.callbackService.create()\n        request.setCallback(callback.url, true)\n        return {request, callback}\n    }\n\n    /**\n     * Send a SigningRequest instance using this link.\n     * @internal\n     */\n    public async sendRequest(\n        request: SigningRequest,\n        callback: LinkCallback,\n        transport?: LinkTransport,\n        broadcast = false\n    ) {\n        const t = transport || this.transport\n        try {\n            const linkUrl = request.data.callback\n            if (linkUrl !== callback.url) {\n                throw new Error('Invalid request callback')\n            }\n            if (request.data.flags.broadcast === true || request.data.flags.background === false) {\n                throw new Error('Invalid request flags')\n            }\n            // wait for callback or user cancel\n            const cancel = new Promise<never>((resolve, reject) => {\n                t.onRequest(request, (reason) => {\n                    callback.cancel()\n                    if (typeof reason === 'string') {\n                        reject(new CancelError(reason))\n                    } else {\n                        reject(reason)\n                    }\n                })\n            })\n            const payload = await Promise.race([callback.wait(), cancel])\n            const signer = PermissionLevel.from({\n                actor: payload.sa,\n                permission: payload.sp,\n            })\n            const signatures: Signature[] = Object.keys(payload)\n                .filter((key) => key.startsWith('sig') && key !== 'sig0')\n                .map((key) => Signature.from(payload[key]!))\n            // recreate transaction from request response\n            const resolved = await ResolvedSigningRequest.fromPayload(payload, this.requestOptions)\n            // TODO: use the signature type directly instead of the string now that its not a pain to do\n            const fuelSig = resolved.request.getInfoKey<string>('fuel_sig', 'string')\n            if (fuelSig) {\n                signatures.unshift(Signature.from(fuelSig))\n            }\n            const result: TransactResult = {\n                request: resolved.request,\n                transaction: resolved.transaction,\n                resolvedTransaction: resolved.resolvedTransaction,\n                signatures,\n                payload,\n                signer,\n            }\n            if (broadcast) {\n                const signedTx = SignedTransaction.from({\n                    ...resolved.transaction,\n                    signatures,\n                })\n                const res = await this.client.v1.chain.push_transaction(signedTx)\n                result.processed = res.processed\n            }\n            if (t.onSuccess) {\n                t.onSuccess(request, result)\n            }\n            return result\n        } catch (error) {\n            if (t.onFailure) {\n                t.onFailure(request, error)\n            }\n            throw error\n        }\n    }\n\n    /**\n     * Sign and optionally broadcast a EOSIO transaction, action or actions.\n     *\n     * Example:\n     *\n     * ```ts\n     * let result = await myLink.transact({transaction: myTx})\n     * ```\n     *\n     * @param args The action, actions or transaction to use.\n     * @param options Options for this transact call.\n     * @param transport Transport override, for internal use.\n     */\n    public async transact(\n        args: TransactArgs,\n        options?: TransactOptions,\n        transport?: LinkTransport\n    ): Promise<TransactResult> {\n        const t = transport || this.transport\n        const broadcast = options ? options.broadcast !== false : true\n        // Initialize the loading state of the transport\n        if (t && t.showLoading) {\n            t.showLoading()\n        }\n        // eosjs transact compat: upgrade to transaction if args have any header fields\n        const anyArgs = args as any\n        if (\n            args.actions &&\n            (anyArgs.expiration ||\n                anyArgs.ref_block_num ||\n                anyArgs.ref_block_prefix ||\n                anyArgs.max_net_usage_words ||\n                anyArgs.max_cpu_usage_ms ||\n                anyArgs.delay_sec)\n        ) {\n            args = {\n                transaction: {\n                    expiration: '1970-01-01T00:00:00',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_net_usage_words: 0,\n                    max_cpu_usage_ms: 0,\n                    delay_sec: 0,\n                    ...anyArgs,\n                },\n            }\n        }\n        const {request, callback} = await this.createRequest(args, t)\n        const result = await this.sendRequest(request, callback, t, broadcast)\n        return result\n    }\n\n    /**\n     * Send an identity request and verify the identity proof.\n     * @param requestPermission Optional request permission if the request is for a specific account or permission.\n     * @param info Metadata to add to the request.\n     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.\n     */\n    public async identify(args: {\n        requestPermission?: PermissionLevelType\n        info?: {[key: string]: ABISerializable | Bytes}\n        scope?: NameType\n    }): Promise<IdentifyResult> {\n        const {request, callback} = await this.createRequest({\n            identity: {permission: args.requestPermission, scope: args.scope},\n            info: args.info,\n        })\n        const res = await this.sendRequest(request, callback)\n        if (!res.request.isIdentity()) {\n            throw new IdentityError(`Unexpected response`)\n        }\n        const digest = res.transaction.signingDigest(request.getChainId())\n        const signature = res.signatures[0]\n        const signerKey = signature.recoverDigest(digest)\n\n        const {signer} = res\n\n        const account = await this.client.v1.chain.get_account(signer.actor)\n        if (!account) {\n            throw new IdentityError(`Signature from unknown account: ${signer.actor}`)\n        }\n        const permission = account.permissions.find(({perm_name}) =>\n            signer.permission.equals(perm_name)\n        )\n        if (!permission) {\n            throw new IdentityError(\n                `${signer.actor} signed for unknown permission: ${signer.permission}`\n            )\n        }\n        const auth = permission.required_auth\n        const keyAuth = auth.keys.find(({key}) => signerKey.equals(key))\n        if (!keyAuth) {\n            throw new IdentityError(\n                `${formatAuth(signer)} has no key matching id signature (${signerKey})`\n            )\n        }\n        if (auth.threshold > keyAuth.weight) {\n            throw new IdentityError(`${formatAuth(signer)} signature does not reach auth threshold`)\n        }\n        if (args.requestPermission) {\n            const perm = PermissionLevel.from(args.requestPermission)\n            if (\n                (!perm.actor.equals(PlaceholderName) && !perm.actor.equals(signer.actor)) ||\n                (!perm.permission.equals(PlaceholderPermission) &&\n                    !perm.permission.equals(signer.permission))\n            ) {\n                throw new IdentityError(\n                    `Unexpected identity proof from ${formatAuth(signer)}, expected ${formatAuth(\n                        perm\n                    )} `\n                )\n            }\n        }\n        return {\n            ...res,\n            account,\n            signerKey,\n        }\n    }\n\n    /**\n     * Login and create a persistent session.\n     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).\n     *                   Should be set to the contract account if applicable.\n     */\n    public async login(identifier: NameType): Promise<LoginResult> {\n        const privateKey = PrivateKey.generate('K1')\n        const requestKey = privateKey.toPublic()\n        const createInfo = LinkCreate.from({\n            session_name: identifier,\n            request_key: requestKey,\n        })\n        const res = await this.identify({\n            scope: identifier,\n            info: {\n                link: createInfo,\n                scope: identifier,\n            },\n        })\n        const metadata = {sameDevice: res.request.getRawInfo()['return_path'] !== undefined}\n        let session: LinkSession\n        if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {\n            session = new LinkChannelSession(\n                this,\n                {\n                    identifier,\n                    auth: res.signer,\n                    publicKey: res.signerKey,\n                    channel: {\n                        url: res.payload.link_ch,\n                        key: res.payload.link_key,\n                        name: res.payload.link_name,\n                    },\n                    requestKey: privateKey,\n                },\n                metadata\n            )\n        } else {\n            session = new LinkFallbackSession(\n                this,\n                {\n                    identifier,\n                    auth: res.signer,\n                    publicKey: res.signerKey,\n                },\n                metadata\n            )\n        }\n        if (this.storage) {\n            await this.storeSession(identifier, session)\n        }\n        return {\n            ...res,\n            session,\n        }\n    }\n\n    /**\n     * Restore previous session, see [[Link.login]] to create a new session.\n     * @param identifier The session identifier, should be same as what was used when creating the session with [[Link.login]].\n     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.\n     * @returns A [[LinkSession]] instance or null if no session can be found.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.\n     **/\n    public async restoreSession(identifier: string, auth?: PermissionLevel) {\n        if (!this.storage) {\n            throw new Error('Unable to restore session: No storage adapter configured')\n        }\n        let key: string\n        if (auth) {\n            key = this.sessionKey(identifier, formatAuth(auth))\n        } else {\n            const latest = (await this.listSessions(identifier))[0]\n            if (!latest) {\n                return null\n            }\n            key = this.sessionKey(identifier, formatAuth(latest))\n        }\n        const data = await this.storage.read(key)\n        if (!data) {\n            return null\n        }\n        let sessionData: any\n        try {\n            sessionData = JSON.parse(data)\n        } catch (error) {\n            throw new Error(\n                `Unable to restore session: Stored JSON invalid (${error.message || String(error)})`\n            )\n        }\n        const session = LinkSession.restore(this, sessionData)\n        if (auth) {\n            // update latest used\n            await this.touchSession(identifier, auth)\n        }\n        return session\n    }\n\n    /**\n     * List stored session auths for given identifier.\n     * The most recently used session is at the top (index 0).\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.\n     **/\n    public async listSessions(identifier: NameType) {\n        if (!this.storage) {\n            throw new Error('Unable to list sessions: No storage adapter configured')\n        }\n        const key = this.sessionKey(identifier, 'list')\n        let list: PermissionLevel[]\n        try {\n            list = JSON.parse((await this.storage.read(key)) || '[]')\n        } catch (error) {\n            throw new Error(\n                `Unable to list sessions: Stored JSON invalid (${error.message || String(error)})`\n            )\n        }\n        return list\n    }\n\n    /**\n     * Remove stored session for given identifier and auth.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    public async removeSession(identifier: NameType, auth: PermissionLevel) {\n        if (!this.storage) {\n            throw new Error('Unable to remove session: No storage adapter configured')\n        }\n        const key = this.sessionKey(identifier, formatAuth(auth))\n        await this.storage.remove(key)\n        await this.touchSession(identifier, auth, true)\n    }\n\n    /**\n     * Remove all stored sessions for given identifier.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    public async clearSessions(identifier: string) {\n        if (!this.storage) {\n            throw new Error('Unable to clear sessions: No storage adapter configured')\n        }\n        for (const auth of await this.listSessions(identifier)) {\n            await this.removeSession(identifier, auth)\n        }\n    }\n\n    /**\n     * Create an eosjs compatible signature provider using this link.\n     * @param availableKeys Keys the created provider will claim to be able to sign for.\n     * @param transport (internal) Transport override for this call.\n     * @note We don't know what keys are available so those have to be provided,\n     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].\n     */\n    public makeSignatureProvider(availableKeys: string[], transport?: LinkTransport): any {\n        return {\n            getAvailableKeys: async () => availableKeys,\n            sign: async (args) => {\n                const t = transport || this.transport\n                let request = SigningRequest.fromTransaction(\n                    args.chainId,\n                    args.serializedTransaction,\n                    this.requestOptions\n                )\n                const callback = this.callbackService.create()\n                request.setCallback(callback.url, true)\n                request.setBroadcast(false)\n                if (t.prepare) {\n                    request = await t.prepare(request)\n                }\n                const {transaction, signatures} = await this.sendRequest(request, callback, t)\n                const serializedTransaction = Serializer.encode({object: transaction})\n                return {\n                    ...args,\n                    serializedTransaction,\n                    signatures,\n                }\n            },\n        }\n    }\n\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    private async touchSession(identifier: NameType, auth: PermissionLevel, remove = false) {\n        const auths = await this.listSessions(identifier)\n        const formattedAuth = formatAuth(auth)\n        const existing = auths.findIndex((a) => formatAuth(a) === formattedAuth)\n        if (existing >= 0) {\n            auths.splice(existing, 1)\n        }\n        if (remove === false) {\n            auths.unshift(auth)\n        }\n        const key = this.sessionKey(identifier, 'list')\n        await this.storage!.write(key, JSON.stringify(auths))\n    }\n\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    private async storeSession(identifier: NameType, session: LinkSession) {\n        const key = this.sessionKey(identifier, formatAuth(session.auth))\n        const data = JSON.stringify(session.serialize())\n        await this.storage!.write(key, data)\n        await this.touchSession(identifier, session.auth)\n    }\n\n    /** Session storage key for identifier and suffix. */\n    private sessionKey(identifier: NameType, suffix: string) {\n        return [this.chainId.toString(), Name.from(identifier).toString(), suffix].join('-')\n    }\n}\n\n/**\n * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.\n * @internal\n */\nfunction formatAuth(auth: PermissionLevelType): string {\n    const a = PermissionLevel.from(auth)\n    const actor = a.actor.equals(PlaceholderName) ? '<any>' : String(a.actor)\n    let permission: string\n    if (a.permission.equals(PlaceholderName) || a.permission.equals(PlaceholderPermission)) {\n        permission = '<any>'\n    } else {\n        permission = String(a.permission)\n    }\n    return `${actor}@${permission}`\n}\n"],"names":["CancelError","Error","constructor","reason","super","this","IdentityError","SessionError","code","LinkOptions","__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","chainId","client","service","SealedMessage","Struct","field","type","LinkCreate","LinkInfo","fetch","makeFetch","LinkSession","[object Object]","link","storage","removeSession","identifier","auth","data","LinkChannelSession","metadata","LinkFallbackSession","PermissionLevel","from","publicKey","PublicKey","channel","Name","privateKey","PrivateKey","requestKey","encrypt","request","message","nonce","secret","sharedSecret","UInt64","random","Serializer","encode","object","appending","array","sha512Digest","cbc","AES_CBC","slice","ciphertext","Bytes","checksum","DataView","Checksum256","hash","buffer","getUint32","toPublic","sealMessage","timeout","name","serialize","onSuccess","result","transport","onFailure","error","onRequest","cancel","info","expiration","Date","now","toISOString","onSessionRequest","setTimeout","setInfoKey","url","method","headers","X-Buoy-Wait","toFixed","body","then","response","status","catch","String","prepare","Promise","resolve","showLoading","makeSignatureProvider","toString","transact","args","options","BuoyCallbackService","address","trim","replace","create","uuid","BuoyCallback","wait","includes","async","ctx","active","res","json","statusText","console","warn","sleep","pollForCallback","reject","retries","socketUrl","handleResponse","JSON","parse","connect","socket","WebSocket","readyState","OPEN","CONNECTING","close","onmessage","event","Blob","reader","FileReader","onload","onerror","readAsText","onopen","onclose","tries","Math","min","pow","ms","Link","Map","TypeError","undefined","APIClient","defaults","ChainId","callbackService","requestOptions","abiProvider","zlib","account","rv","abiCache","get","getAbi","pendingAbis","v1","chain","get_abi","set","abi","delete","t","SigningRequest","broadcast","callback","setCallback","flags","background","payload","race","signer","actor","sa","permission","sp","signatures","keys","filter","startsWith","map","Signature","resolved","ResolvedSigningRequest","fromPayload","fuelSig","getInfoKey","unshift","transaction","resolvedTransaction","signedTx","SignedTransaction","push_transaction","processed","anyArgs","actions","ref_block_num","ref_block_prefix","max_net_usage_words","max_cpu_usage_ms","delay_sec","createRequest","sendRequest","identity","requestPermission","scope","isIdentity","digest","signingDigest","getChainId","signerKey","recoverDigest","get_account","permissions","find","perm_name","equals","required_auth","keyAuth","formatAuth","threshold","weight","perm","PlaceholderName","PlaceholderPermission","generate","createInfo","session_name","request_key","identify","sameDevice","getRawInfo","session","link_ch","link_key","link_name","storeSession","sessionKey","latest","listSessions","read","sessionData","restore","touchSession","list","remove","availableKeys","getAvailableKeys","sign","_this","fromTransaction","serializedTransaction","setBroadcast","auths","formattedAuth","existing","findIndex","a","splice","write","stringify","suffix","join"],"mappings":"mlBAaaA,UAAoBC,MAE7BC,YAAYC,GACRC,gCAA+BD,EAAS,IAAMA,EAAS,IAAM,KAF1DE,UAAO,kBAULC,UAAsBL,MAE/BC,YAAYC,GACRC,oCAAmCD,EAAS,IAAMA,EAAS,IAAM,KAF9DE,UAAO,oBAULE,UAAqBN,MAE9BC,YAAYC,EAAgBK,GACxBJ,MAAMD,GACNE,KAAKG,KAAOA,GCMHC,IAAAA,ECOjB,SAAgBC,EAAWC,EAAYC,EAAQC,EAAKC,GAChD,IAA2HC,EAAvHC,EAAIC,UAAUC,OAAQC,EAAIH,EAAI,EAAIJ,EAAkB,OAATE,EAAgBA,EAAOM,OAAOC,yBAAyBT,EAAQC,GAAOC,EACrH,GAAuB,iBAAZQ,SAAoD,mBAArBA,QAAQC,SAAyBJ,EAAIG,QAAQC,SAASZ,EAAYC,EAAQC,EAAKC,QACpH,IAAK,IAAIU,EAAIb,EAAWO,OAAS,EAAGM,GAAK,EAAGA,KAAST,EAAIJ,EAAWa,MAAIL,GAAKH,EAAI,EAAID,EAAEI,GAAKH,EAAI,EAAID,EAAEH,EAAQC,EAAKM,GAAKJ,EAAEH,EAAQC,KAASM,GAChJ,OAAOH,EAAI,GAAKG,GAAKC,OAAOK,eAAeb,EAAQC,EAAKM,GAAIA,GDXhE,SAAiBV,GAEAA,WAAW,CACpBiB,QAAS,mEACTC,OAAQ,2BACRC,QAAS,0BALjB,CAAiBnB,IAAAA,OE1CjB,IAAaoB,EAAb,cAAmCC,IACHpB,GAA3BoB,EAAOC,MAAM,0CACUrB,GAAvBoB,EAAOC,MAAM,uCACSrB,GAAtBoB,EAAOC,MAAM,2CACUrB,GAAvBoB,EAAOC,MAAM,0CAJLF,KADZC,EAAOE,KAAK,mBACAH,GAQb,IAAaI,EAAb,cAAgCH,IACNpB,GAArBoB,EAAOC,MAAM,4CACcrB,GAA3BoB,EAAOC,MAAM,iDAFLE,KADZH,EAAOE,KAAK,gBACAC,GAMb,IAAaC,EAAb,cAA8BJ,IACMpB,GAA/BoB,EAAOC,MAAM,oDADLG,KADZJ,EAAOE,KAAK,cACAE,SCVAC,EAAQC,IAAYD,YCiBXE,EA4BlBC,eACQjC,KAAKkC,KAAKC,oBACCD,KAAKE,cAAcpC,KAAKqC,WAAYrC,KAAKsC,MAI5DL,eAAeC,EAAYK,GACvB,OAAQA,EAAKZ,MACT,IAAK,UACD,WAAWa,EAAmBN,EAAMK,EAAKA,KAAMA,EAAKE,UACxD,IAAK,WACD,WAAWC,EAAoBR,EAAMK,EAAKA,KAAMA,EAAKE,UACzD,QACI,UAAU7C,MAAM,mDAwCnB4C,UAA2BR,EAYpCnC,YAAYqC,EAAYK,EAA8BE,GAClD1C,QATKC,UAAO,UAKRA,aAAU,KAKdA,KAAKkC,KAAOA,EACZlC,KAAKsC,KAAOK,EAAgBC,KAAKL,EAAKD,MACtCtC,KAAK6C,UAAYC,EAAUF,KAAKL,EAAKM,WACrC7C,KAAK+C,QAAUR,EAAKQ,QACpB/C,KAAKqC,WAAaW,EAAKJ,KAAKL,EAAKF,YACjC,MAAMY,EAAaC,EAAWN,KAAKL,EAAKY,YAClCN,EAAYC,EAAUF,KAAKL,EAAKQ,QAAQvC,KAC9CR,KAAKoD,QAAWC,YDhHpBC,EACAL,EACAJ,EACAU,GAEA,MAAMC,EAASP,EAAWQ,aAAaZ,GAClCU,IACDA,EAAQG,EAAOC,UAEnB,MAAMnD,EAAMoD,EAAWC,OAAO,CAACC,OAAQP,IAAQQ,UAAUP,EAAOQ,OAAOC,aACjEC,EAAM,IAAIC,EAAQ3D,EAAIwD,MAAMI,MAAM,EAAG,IAAK5D,EAAIwD,MAAMI,MAAM,GAAI,KAC9DC,EAAaC,EAAM1B,KAAKsB,EAAId,QAAQkB,EAAM1B,KAAKU,EAAS,QAAQU,QAEhEO,EADe,IAAIC,SAASC,EAAYC,KAAKlE,EAAIwD,OAAOA,MAAMW,QACtCC,UAAU,GAAG,GAC3C,OAAOpD,EAAcoB,KAAK,CACtBA,KAAMK,EAAW4B,WACjBtB,MAAAA,EACAc,WAAAA,EACAE,SAAAA,IC+FWO,CAAYzB,EAAQQ,QAAO,GAAM,GAAQZ,EAAYJ,GAEhE7C,KAAKyC,SAAW,IACRA,GAAY,GAChBsC,QAAS/E,KAAK+E,QACdC,KAAMhF,KAAK+C,QAAQiC,MAEvBhF,KAAKiF,UAAY,MACbtD,KAAM,UACNY,KAAAA,EACAE,SAAUzC,KAAKyC,WAIvByC,UAAU7B,EAAS8B,GACXnF,KAAKkC,KAAKkD,UAAUF,WACpBlF,KAAKkC,KAAKkD,UAAUF,UAAU7B,EAAS8B,GAI/CE,UAAUhC,EAASiC,GACXtF,KAAKkC,KAAKkD,UAAUC,WACpBrF,KAAKkC,KAAKkD,UAAUC,UAAUhC,EAASiC,GAI/CC,UAAUlC,EAAyBmC,GAC/B,MAAMC,EAAO5D,EAASe,KAAK,CACvB8C,WAAY,IAAIC,KAAKA,KAAKC,MAAQ5F,KAAK+E,SAASc,cAAczB,MAAM,GAAI,KAExEpE,KAAKkC,KAAKkD,UAAUU,kBACpB9F,KAAKkC,KAAKkD,UAAUU,iBAAiB9F,KAAMqD,EAASmC,GAExDO,WAAW,KACPP,EAAO,IAAItF,EAAa,iCAAkC,eAC3DF,KAAK+E,QAAU,KAClB1B,EAAQ2C,WAAW,OAAQP,GAC3B3D,EAAM9B,KAAK+C,QAAQkD,IAAK,CACpBC,OAAQ,OACRC,QAAS,CACLC,eAAgBpG,KAAK+E,QAAU,KAAMsB,QAAQ,IAEjDC,KAAM1C,EAAWC,OAAO,CAACC,OAAQ9D,KAAKoD,QAAQC,KAAWW,QAExDuC,KAAMC,IACqB,MAApBA,EAASC,QACTjB,EAAO,IAAItF,EAAa,yBAA0B,iBAKzDwG,MAAOpB,IACJE,EACI,IAAItF,mCACiCoF,EAAMhC,SAAWqD,OAAOrB,MACzD,iBAMpBsB,QAAQvD,GACJ,OAAIrD,KAAKkC,KAAKkD,UAAUwB,aACR1E,KAAKkD,UAAUwB,QAAQvD,EAASrD,MAEzC6G,QAAQC,QAAQzD,GAG3B0D,cACI,GAAI/G,KAAKkC,KAAKkD,UAAU2B,YACpB,YAAY7E,KAAKkD,UAAU2B,cAI5BC,wBACH,YAAY9E,KAAK8E,sBAAsB,CAAChH,KAAK6C,UAAUoE,YAAajH,MAGxEkH,SAASC,EAAoBC,GACzB,YAAYlF,KAAKgF,SAASC,EAAMC,EAASpH,OAejD,MAAa0C,UAA4BV,EASrCnC,YAAYqC,EAAYK,EAA+BE,GACnD1C,QAPKC,UAAO,WAQZA,KAAKkC,KAAOA,EACZlC,KAAKsC,KAAOK,EAAgBC,KAAKL,EAAKD,MACtCtC,KAAK6C,UAAYC,EAAUF,KAAKL,EAAKM,WACrC7C,KAAKyC,SAAWA,GAAY,GAC5BzC,KAAKqC,WAAaW,EAAKJ,KAAKL,EAAKF,YACjCrC,KAAKiF,UAAY,MACbtD,KAAM3B,KAAK2B,KACXY,KAAAA,EACAE,SAAUzC,KAAKyC,WAIvByC,UAAU7B,EAAS8B,GACXnF,KAAKkC,KAAKkD,UAAUF,WACpBlF,KAAKkC,KAAKkD,UAAUF,UAAU7B,EAAS8B,GAI/CE,UAAUhC,EAASiC,GACXtF,KAAKkC,KAAKkD,UAAUC,WACpBrF,KAAKkC,KAAKkD,UAAUC,UAAUhC,EAASiC,GAI/CC,UAAUlC,EAASmC,GACXxF,KAAKkC,KAAKkD,UAAUU,iBACpB9F,KAAKkC,KAAKkD,UAAUU,iBAAiB9F,KAAMqD,EAASmC,GAEpDxF,KAAKkC,KAAKkD,UAAUG,UAAUlC,EAASmC,GAI/CoB,QAAQvD,GACJ,OAAIrD,KAAKkC,KAAKkD,UAAUwB,aACR1E,KAAKkD,UAAUwB,QAAQvD,EAASrD,MAEzC6G,QAAQC,QAAQzD,GAG3B0D,cACI,GAAI/G,KAAKkC,KAAKkD,UAAU2B,YACpB,YAAY7E,KAAKkD,UAAU2B,cAI5BC,wBACH,YAAY9E,KAAK8E,sBAAsB,CAAChH,KAAK6C,UAAUoE,YAAajH,MAGxEkH,SAASC,EAAoBC,GACzB,YAAYlF,KAAKgF,SAASC,EAAMC,EAASpH,aCpQpCqH,EAETxH,YAAYyH,GACRtH,KAAKsH,QAAUA,EAAQC,OAAOC,QAAQ,MAAO,IAGjDC,SACI,MAAMxB,KAASjG,KAAKsH,WAAWI,MAC/B,WAAWC,EAAa1B,IAKhC,MAAM0B,EACF9H,YAAqBoG,GAAAjG,SAAAiG,EACbjG,SAA6B,GACrC4H,OACI,OAAI5H,KAAKiG,IAAI4B,SAAS,aAgF9BC,eAA+B7B,EAAa8B,GACxC,IAAIC,GAAS,EAIb,IAHAD,EAAIvC,OAAS,KACTwC,GAAS,GAENA,GAAQ,CACX,IACI,MAAMC,QAAYnG,EAAMmE,GACxB,GAAmB,MAAfgC,EAAIxB,OACJ,YACsB,MAAfwB,EAAIxB,OACX,aAAawB,EAAIC,OAEjB,UAAUtI,cAAcqI,EAAIxB,WAAWwB,EAAIE,cAEjD,MAAO7C,GAEL8C,QAAQC,KAAK,6BAA8B/C,SAEzCgD,EAAM,KAEhB,WAAWzB,QAAyB,QApGrB0B,CAAgBvI,KAAKiG,IAAKjG,KAAK+H,MAgBzB9B,EAdUjG,KAAKiG,IAcF8B,EAdO/H,KAAK+H,QAenClB,QAAyB,CAACC,EAAS0B,KAC1C,IAAIR,GAAS,EACTS,EAAU,EACd,MAAMC,EAAYzC,EAAIuB,QAAQ,QAAS,MACjCmB,EAAkBnC,IACpB,IACIM,EAAQ8B,KAAKC,MAAMrC,IACrB,MAAOlB,GACLA,EAAMhC,QAAU,kCAAoCgC,EAAMhC,QAC1DkF,EAAOlD,KAGTwD,EAAU,KACZ,MAAMC,EAAS,IAAIC,EAAUN,GAC7BX,EAAIvC,OAAS,KACTwC,GAAS,EAELe,EAAOE,aAAeD,EAAUE,MAChCH,EAAOE,aAAeD,EAAUG,YAEhCJ,EAAOK,SAGfL,EAAOM,UAAaC,IAKhB,GAJAtB,GAAS,EACLe,EAAOE,aAAeD,EAAUE,MAChCH,EAAOK,QAES,oBAATG,MAAwBD,EAAM/G,gBAAgBgH,KAAM,CAC3D,MAAMC,EAAS,IAAIC,WACnBD,EAAOE,OAAS,KACZf,EAAea,EAAOrE,SAE1BqE,EAAOG,QAAWrE,IACdkD,EAAOlD,IAEXkE,EAAOI,WAAWN,EAAM/G,WAGpBoG,EADsB,iBAAfW,EAAM/G,KACE+G,EAAM/G,KAEN+G,EAAM/G,KAAK0E,aAItC8B,EAAOc,OAAS,KACZpB,EAAU,GAEdM,EAAOe,QAAU,KA6C7B,IAAiBC,EA5CG/B,GACAjC,WAAW+C,GA2CdiB,EA3C+BtB,IA4CrCuB,KAAKC,IAAID,KAAKE,IAAY,GAARH,EAAY,GAAI,SAxCrCjB,OAvDR,IAAyB7C,EAAa8B,EAXlCvC,SACQxF,KAAK+H,IAAIvC,QACTxF,KAAK+H,IAAIvC,UA+GrB,SAAS8C,EAAM6B,GACX,WAAWtD,QAASC,IAChBf,WAAWe,EAASqD,WCvCfC,EAgBTvK,YAAYuH,GACR,GALIpH,cAAW,IAAIqK,IACfrK,iBAAc,IAAIqK,IAIC,iBAAZjD,EACP,UAAUkD,UAAU,0BAExB,IAAKlD,EAAQhC,UACT,UAAUkF,UACN,yFAIJtK,KAAKsB,YADciJ,IAAnBnD,EAAQ9F,QAAkD,iBAAnB8F,EAAQ9F,OACjC,IAAIkJ,EAAU,CAACvE,IAAKmB,EAAQ9F,QAAUlB,EAAYqK,SAASnJ,SAE3D8F,EAAQ9F,OAE1BtB,KAAKqB,QAAUqJ,EAAQ9H,KAAKwE,EAAQ/F,SAAWjB,EAAYqK,SAASpJ,SAEhErB,KAAK2K,qBADeJ,IAApBnD,EAAQ7F,SAAoD,iBAApB6F,EAAQ7F,QACzB,IAAI8F,EACvBD,EAAQ7F,SAAWnB,EAAYqK,SAASlJ,SAGrB6F,EAAQ7F,QAEnCvB,KAAKoF,UAAYgC,EAAQhC,UACD,OAApBgC,EAAQjF,UACRnC,KAAKmC,QAAUiF,EAAQjF,SAAWnC,KAAKoF,UAAUjD,SAErDnC,KAAK4K,eAAiB,CAClBC,YAAa7K,KACb8K,KAAAA,GAQD7I,aAAa8I,GAChB,MAAMvK,EAAMuK,EAAQ9D,WACpB,IAAI+D,EAAKhL,KAAKiL,SAASC,IAAI1K,GAC3B,IAAKwK,EAAI,CACL,IAAIG,EAASnL,KAAKoL,YAAYF,IAAI1K,GAC7B2K,IACDA,EAASnL,KAAKsB,OAAO+J,GAAGC,MAAMC,QAAQR,GACtC/K,KAAKoL,YAAYI,IAAIhL,EAAK2K,IAE9BH,SAAYG,GAAQM,IACpBzL,KAAKoL,YAAYM,OAAOlL,GACpBwK,GACAhL,KAAKiL,SAASO,IAAIhL,EAAKwK,GAG/B,OAAOA,EAOJ/I,oBAAoBkF,EAAqC/B,GAC5D,MAAMuG,EAAIvG,GAAapF,KAAKoF,UAC5B,IAAI/B,QAAgBuI,EAAenE,OAC/B,IACON,EACH9F,QAASrB,KAAKqB,QAAQ4F,WACtB4E,WAAW,GAEf7L,KAAK4K,gBAELe,EAAE/E,UACFvD,QAAgBsI,EAAE/E,QAAQvD,IAE9B,MAAMyI,EAAW9L,KAAK2K,gBAAgBlD,SAEtC,OADApE,EAAQ0I,YAAYD,EAAS7F,KAAK,GAC3B,CAAC5C,QAAAA,EAASyI,SAAAA,GAOd7J,kBACHoB,EACAyI,EACA1G,EACAyG,GAAY,GAEZ,MAAMF,EAAIvG,GAAapF,KAAKoF,UAC5B,IAEI,GADgB/B,EAAQd,KAAKuJ,WACbA,EAAS7F,IACrB,UAAUrG,MAAM,4BAEpB,IAAqC,IAAjCyD,EAAQd,KAAKyJ,MAAMH,YAAwD,IAAlCxI,EAAQd,KAAKyJ,MAAMC,WAC5D,UAAUrM,MAAM,yBAGpB,MAAM4F,EAAS,IAAIqB,QAAe,CAACC,EAAS0B,KACxCmD,EAAEpG,UAAUlC,EAAUvD,IAClBgM,EAAStG,SAELgD,EADkB,iBAAX1I,EACA,IAAIH,EAAYG,GAEhBA,OAIboM,QAAgBrF,QAAQsF,KAAK,CAACL,EAASlE,OAAQpC,IAC/C4G,EAASzJ,EAAgBC,KAAK,CAChCyJ,MAAOH,EAAQI,GACfC,WAAYL,EAAQM,KAElBC,EAA0B1L,OAAO2L,KAAKR,GACvCS,OAAQnM,GAAQA,EAAIoM,WAAW,QAAkB,SAARpM,GACzCqM,IAAKrM,GAAQsM,EAAUlK,KAAKsJ,EAAQ1L,KAEnCuM,QAAiBC,EAAuBC,YAAYf,EAASlM,KAAK4K,gBAElEsC,EAAUH,EAAS1J,QAAQ8J,WAAmB,WAAY,UAC5DD,GACAT,EAAWW,QAAQN,EAAUlK,KAAKsK,IAEtC,MAAM/H,EAAyB,CAC3B9B,QAAS0J,EAAS1J,QAClBgK,YAAaN,EAASM,YACtBC,oBAAqBP,EAASO,oBAC9Bb,WAAAA,EACAP,QAAAA,EACAE,OAAAA,GAEJ,GAAIP,EAAW,CACX,MAAM0B,EAAWC,EAAkB5K,KAAK,IACjCmK,EAASM,YACZZ,WAAAA,IAEExE,aAAiB3G,OAAO+J,GAAGC,MAAMmC,iBAAiBF,GACxDpI,EAAOuI,UAAYzF,EAAIyF,UAK3B,OAHI/B,EAAEzG,WACFyG,EAAEzG,UAAU7B,EAAS8B,GAElBA,EACT,MAAOG,GAIL,MAHIqG,EAAEtG,WACFsG,EAAEtG,UAAUhC,EAASiC,GAEnBA,GAiBPrD,eACHkF,EACAC,EACAhC,GAEA,MAAMuG,EAAIvG,GAAapF,KAAKoF,UACtByG,GAAYzE,IAAgC,IAAtBA,EAAQyE,UAEhCF,GAAKA,EAAE5E,aACP4E,EAAE5E,cAGN,MAAM4G,EAAUxG,EAEZA,EAAKyG,UACJD,EAAQjI,YACLiI,EAAQE,eACRF,EAAQG,kBACRH,EAAQI,qBACRJ,EAAQK,kBACRL,EAAQM,aAEZ9G,EAAO,CACHkG,YAAa,CACT3H,WAAY,sBACZmI,cAAe,EACfC,iBAAkB,EAClBC,oBAAqB,EACrBC,iBAAkB,EAClBC,UAAW,KACRN,KAIf,MAAMtK,QAACA,EAADyI,SAAUA,cAAuBoC,cAAc/G,EAAMwE,GAE3D,kBAD0BwC,YAAY9K,EAASyI,EAAUH,EAAGE,GAUzD5J,eAAekF,GAKlB,MAAM9D,QAACA,EAADyI,SAAUA,cAAuBoC,cAAc,CACjDE,SAAU,CAAC7B,WAAYpF,EAAKkH,kBAAmBC,MAAOnH,EAAKmH,OAC3D7I,KAAM0B,EAAK1B,OAETwC,aAAiBkG,YAAY9K,EAASyI,GAC5C,IAAK7D,EAAI5E,QAAQkL,aACb,UAAUtO,yBAEd,MAAMuO,EAASvG,EAAIoF,YAAYoB,cAAcpL,EAAQqL,cAE/CC,EADY1G,EAAIwE,WAAW,GACLmC,cAAcJ,IAEpCpC,OAACA,GAAUnE,EAEX8C,aAAqBzJ,OAAO+J,GAAGC,MAAMuD,YAAYzC,EAAOC,OAC9D,IAAKtB,EACD,UAAU9K,qCAAiDmM,EAAOC,OAEtE,MAAME,EAAaxB,EAAQ+D,YAAYC,KAAK,EAAEC,UAAAA,KAC1C5C,EAAOG,WAAW0C,OAAOD,IAE7B,IAAKzC,EACD,UAAUtM,KACHmM,EAAOC,wCAAwCD,EAAOG,cAGjE,MAAMjK,EAAOiK,EAAW2C,cAClBC,EAAU7M,EAAKoK,KAAKqC,KAAK,EAAEvO,IAAAA,KAASmO,EAAUM,OAAOzO,IAC3D,IAAK2O,EACD,UAAUlP,KACHmP,EAAWhD,wCAA6CuC,MAGnE,GAAIrM,EAAK+M,UAAYF,EAAQG,OACzB,UAAUrP,EAAiBmP,EAAWhD,+CAE1C,GAAIjF,EAAKkH,kBAAmB,CACxB,MAAMkB,EAAO5M,EAAgBC,KAAKuE,EAAKkH,mBACvC,IACMkB,EAAKlD,MAAM4C,OAAOO,KAAqBD,EAAKlD,MAAM4C,OAAO7C,EAAOC,SAChEkD,EAAKhD,WAAW0C,OAAOQ,KACpBF,EAAKhD,WAAW0C,OAAO7C,EAAOG,YAEnC,UAAUtM,oCAC4BmP,EAAWhD,gBAAqBgD,EAC9DG,OAKhB,MAAO,IACAtH,EACH8C,QAAAA,EACA4D,UAAAA,GASD1M,YAAYI,GACf,MAAMY,EAAaC,EAAWwM,SAAS,MACjCvM,EAAaF,EAAW4B,WACxB8K,EAAa/N,EAAWgB,KAAK,CAC/BgN,aAAcvN,EACdwN,YAAa1M,IAEX8E,aAAiB6H,SAAS,CAC5BxB,MAAOjM,EACPoD,KAAM,CACFvD,KAAMyN,EACNrB,MAAOjM,KAGTI,EAAW,CAACsN,gBAAwDxF,IAA5CtC,EAAI5E,QAAQ2M,aAAZ,aAC9B,IAAIC,EA+BJ,OA7BIA,EADAhI,EAAIiE,QAAQgE,SAAWjI,EAAIiE,QAAQiE,UAAYlI,EAAIiE,QAAQkE,UACjD,IAAI5N,EACVxC,KACA,CACIqC,WAAAA,EACAC,KAAM2F,EAAImE,OACVvJ,UAAWoF,EAAI0G,UACf5L,QAAS,CACLkD,IAAKgC,EAAIiE,QAAQgE,QACjB1P,IAAKyH,EAAIiE,QAAQiE,SACjBnL,KAAMiD,EAAIiE,QAAQkE,WAEtBjN,WAAYF,GAEhBR,GAGM,IAAIC,EACV1C,KACA,CACIqC,WAAAA,EACAC,KAAM2F,EAAImE,OACVvJ,UAAWoF,EAAI0G,WAEnBlM,GAGJzC,KAAKmC,oBACMkO,aAAahO,EAAY4N,GAEjC,IACAhI,EACHgI,QAAAA,GAWDhO,qBAAqBI,EAAoBC,GAC5C,IAAKtC,KAAKmC,QACN,UAAUvC,MAAM,4DAEpB,IAAIY,EACJ,GAAI8B,EACA9B,EAAMR,KAAKsQ,WAAWjO,EAAY+M,EAAW9M,QAC1C,CACH,MAAMiO,cAAqBC,aAAanO,IAAa,GACrD,IAAKkO,EACD,YAEJ/P,EAAMR,KAAKsQ,WAAWjO,EAAY+M,EAAWmB,IAEjD,MAAMhO,aAAkBJ,QAAQsO,KAAKjQ,GACrC,IAAK+B,EACD,YAEJ,IAAImO,EACJ,IACIA,EAAc9H,KAAKC,MAAMtG,GAC3B,MAAO+C,GACL,UAAU1F,yDAC6C0F,EAAMhC,SAAWqD,OAAOrB,OAGnF,MAAM2K,EAAUjO,EAAY2O,QAAQ3Q,KAAM0Q,GAK1C,OAJIpO,cAEWsO,aAAavO,EAAYC,GAEjC2N,EAQJhO,mBAAmBI,GACtB,IAAKrC,KAAKmC,QACN,UAAUvC,MAAM,0DAEpB,MAAMY,EAAMR,KAAKsQ,WAAWjO,EAAY,QACxC,IAAIwO,EACJ,IACIA,EAAOjI,KAAKC,iBAAkB1G,QAAQsO,KAAKjQ,IAAS,MACtD,MAAO8E,GACL,UAAU1F,uDAC2C0F,EAAMhC,SAAWqD,OAAOrB,OAGjF,OAAOuL,EAOJ5O,oBAAoBI,EAAsBC,GAC7C,IAAKtC,KAAKmC,QACN,UAAUvC,MAAM,2DAEpB,MAAMY,EAAMR,KAAKsQ,WAAWjO,EAAY+M,EAAW9M,eACxCH,QAAQ2O,OAAOtQ,cACfoQ,aAAavO,EAAYC,GAAM,GAOvCL,oBAAoBI,GACvB,IAAKrC,KAAKmC,QACN,UAAUvC,MAAM,2DAEpB,IAAK,MAAM0C,gBAAmBkO,aAAanO,cAC5BD,cAAcC,EAAYC,GAWtC0E,sBAAsB+J,EAAyB3L,cAClD,MAAO,CACH4L,iBAAkBlJ,wBAAYiJ,GAC9BE,KAAMnJ,eAAOX,GACT,MAAMwE,EAAIvG,GAAa8L,EAAK9L,UAC5B,IAAI/B,EAAUuI,EAAeuF,gBACzBhK,EAAK9F,QACL8F,EAAKiK,sBACLF,EAAKtG,gBAET,MAAMkB,EAAWoF,EAAKvG,gBAAgBlD,SACtCpE,EAAQ0I,YAAYD,EAAS7F,KAAK,GAClC5C,EAAQgO,cAAa,GACjB1F,EAAE/E,UACFvD,QAAgBsI,EAAE/E,QAAQvD,IAE9B,MAAMgK,YAACA,EAADZ,WAAcA,SAAoByE,EAAK/C,YAAY9K,EAASyI,EAAUH,GACtEyF,EAAwBxN,EAAWC,OAAO,CAACC,OAAQuJ,IACzD,MAAO,IACAlG,EACHiK,sBAAAA,EACA3E,WAAAA,KAORxK,mBAAmBI,EAAsBC,EAAuBwO,GAAS,GAC7E,MAAMQ,aAAmBd,aAAanO,GAChCkP,EAAgBnC,EAAW9M,GAC3BkP,EAAWF,EAAMG,UAAWC,GAAMtC,EAAWsC,KAAOH,GACtDC,GAAY,GACZF,EAAMK,OAAOH,EAAU,IAEZ,IAAXV,GACAQ,EAAMlE,QAAQ9K,GAElB,MAAM9B,EAAMR,KAAKsQ,WAAWjO,EAAY,mBAC7BF,QAASyP,MAAMpR,EAAKoI,KAAKiJ,UAAUP,IAI1CrP,mBAAmBI,EAAsB4N,GAC7C,MAAMzP,EAAMR,KAAKsQ,WAAWjO,EAAY+M,EAAWa,EAAQ3N,OACrDC,EAAOqG,KAAKiJ,UAAU5B,EAAQhL,wBACzB9C,QAASyP,MAAMpR,EAAK+B,cACpBqO,aAAavO,EAAY4N,EAAQ3N,MAIxCgO,WAAWjO,EAAsByP,GACrC,MAAO,CAAC9R,KAAKqB,QAAQ4F,WAAYjE,EAAKJ,KAAKP,GAAY4E,WAAY6K,GAAQC,KAAK,MAQxF,SAAS3C,EAAW9M,GAChB,MAAMoP,EAAI/O,EAAgBC,KAAKN,GACzB+J,EAAQqF,EAAErF,MAAM4C,OAAOO,GAAmB,QAAU7I,OAAO+K,EAAErF,OACnE,IAAIE,EAMJ,OAJIA,EADAmF,EAAEnF,WAAW0C,OAAOO,IAAoBkC,EAAEnF,WAAW0C,OAAOQ,GAC/C,QAEA9I,OAAO+K,EAAEnF,eAEhBF,KAASE"}