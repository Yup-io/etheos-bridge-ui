"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_1 = require("./symbol");
const check_1 = require("./check");
const eosiolib_1 = require("./eosiolib");
const utils_1 = require("./utils");
const big_integer_1 = __importDefault(require("big-integer"));
/**
 * Asset
 *
 * @name Asset
 * @param {number} amount The amount of the asset
 * @param {Symbol} sym  The name of the symbol
 * @returns {Asset} Asset
 * @example
 *
 * const quantity = new Asset(10000, new Symbol("EOS", 4));
 * quantity.toString() //=> "1.0000 EOS";
 * quantity.symbol.code() //=> "EOS"
 * quantity.symbol.precision //=> 4
 */
class Asset {
    /**
     * Construct a new asset given the symbol name and the amount
     */
    constructor(obj1, obj2) {
        /**
         * {int64_t} The amount of the asset
         */
        this.amount = big_integer_1.default(0);
        /**
         * {symbol} The symbol name of the asset
         */
        this.symbol = symbol_1.symbol();
        if (utils_1.isNull(obj1) && utils_1.isNull(obj2)) {
            return;
        }
        if (typeof obj1 == "string") {
            const [amount_str, symbol_str] = obj1.split(" ");
            const precision = (amount_str.split(".")[1] || []).length;
            this.amount = utils_1.number_to_bigint(Number(amount_str) * Math.pow(10, precision));
            this.symbol = new symbol_1.Sym(symbol_str, precision);
        }
        else if (utils_1.getType(obj1) == "asset") {
            const _sym = utils_1.getSymbol(obj1);
            if (!_sym)
                throw new Error("[sym] is required");
            this.amount = utils_1.getAmount(obj1);
            this.symbol = _sym;
        }
        else if (obj2) {
            this.amount = utils_1.getAmount(obj1);
            this.symbol = obj2;
        }
        else {
            throw new Error("[sym] is required");
        }
        check_1.check(this.is_amount_within_range(), "magnitude of asset amount must be less than 2^62");
        check_1.check(this.symbol.is_valid(), "invalid symbol name");
    }
    get [Symbol.toStringTag]() {
        return 'asset';
    }
    /**
     * The typeof operator returns a string indicating the type of the unevaluated operand.
     */
    get typeof() { return 'asset'; }
    /**
     * The isinstance() function returns True if the specified object is of the specified type, otherwise False.
     */
    static isInstance(obj) { return obj instanceof Asset; }
    /**
     * Check if the amount doesn't exceed the max amount
     *
     * @return true - if the amount doesn't exceed the max amount
     * @return false - otherwise
     */
    is_amount_within_range() {
        return (Asset.max_amount.multiply(-1)).lesserOrEquals(this.amount) && this.amount.lesserOrEquals(Asset.max_amount);
    }
    /**
     * Check if the asset is valid. %A valid asset has its amount <= max_amount and its symbol name valid
     *
     * @return true - if the asset is valid
     * @return false - otherwise
     */
    is_valid() {
        return this.is_amount_within_range() && this.symbol.is_valid();
    }
    /**
     * Set the amount of the asset
     *
     * @param a - New amount for the asset
     */
    set_amount(amount) {
        this.amount = typeof amount == "number" ? big_integer_1.default(amount) : amount;
        check_1.check(this.is_amount_within_range(), "magnitude of asset amount must be less than 2^62");
    }
    /**
     * Subtraction assignment operator
     *
     * @param a - Another asset to subtract this asset with
     * @return asset& - Reference to this asset
     * @post The amount of this asset is subtracted by the amount of asset a
     */
    minus(a) {
        const amount = utils_1.getAmount(a);
        const sym = utils_1.getSymbol(a);
        if (sym)
            check_1.check(sym.isEqual(this.symbol), "attempt to subtract asset with different symbol");
        this.amount = this.amount.minus(amount);
        check_1.check(Asset.max_amount.multiply(-1).lesserOrEquals(this.amount), "subtraction underflow");
        check_1.check(this.amount.lesserOrEquals(Asset.max_amount), "subtraction overflow");
        return this;
    }
    /**
     * Addition Assignment  operator
     *
     * @param a - Another asset to subtract this asset with
     * @return asset& - Reference to this asset
     * @post The amount of this asset is added with the amount of asset a
     */
    plus(a) {
        const amount = utils_1.getAmount(a);
        const sym = utils_1.getSymbol(a);
        if (sym)
            check_1.check(sym.isEqual(this.symbol), "attempt to add asset with different symbol");
        this.amount = this.amount.plus(amount);
        check_1.check(Asset.max_amount.multiply(-1).lesserOrEquals(this.amount), "addition underflow");
        check_1.check(this.amount.lesserOrEquals(Asset.max_amount), "addition overflow");
        return this;
    }
    /**
     * Addition operator
     *
     * @param a - The first asset to be added
     * @param b - The second asset to be added
     * @return asset - New asset as the result of addition
     */
    static plus(a, b) {
        const result = new Asset(a.amount, a.symbol);
        result.plus(b);
        return result;
    }
    /**
     * Subtraction operator
     *
     * @param a - The asset to be subtracted
     * @param b - The asset used to subtract
     * @return asset - New asset as the result of subtraction of a with b
     */
    static minus(a, b) {
        const result = new Asset(a.amount, a.symbol);
        result.minus(b);
        return result;
    }
    /**
     * Multiplication assignment operator, with a number
     *
     * @details Multiplication assignment operator. Multiply the amount of this asset with a number and then assign the value to itself.
     * @param a - The multiplier for the asset's amount
     * @return asset - Reference to this asset
     * @post The amount of this asset is multiplied by a
     */
    times(a) {
        const amount = utils_1.getAmount(a);
        const sym = utils_1.getSymbol(a);
        if (sym)
            check_1.check(sym.isEqual(this.symbol), "comparison of assets with different symbols is not allowed");
        const tmp = this.amount.multiply(amount);
        check_1.check(tmp.lesserOrEquals(Asset.max_amount), "multiplication overflow");
        check_1.check(tmp.greaterOrEquals(Asset.max_amount.multiply(-1)), "multiplication underflow");
        this.amount = tmp;
        return this;
    }
    /**
     * Multiplication operator, with a number proceeding
     *
     * @brief Multiplication operator, with a number proceeding
     * @param a - The asset to be multiplied
     * @param b - The multiplier for the asset's amount
     * @return asset - New asset as the result of multiplication
     */
    static times(a, b) {
        const result = new Asset(a.amount, a.symbol);
        result.times(b);
        return result;
    }
    /**
     * @brief Division assignment operator, with a number
     *
     * @details Division assignment operator. Divide the amount of this asset with a number and then assign the value to itself.
     * @param a - The divisor for the asset's amount
     * @return asset - Reference to this asset
     * @post The amount of this asset is divided by a
     */
    div(a) {
        const amount = utils_1.getAmount(a);
        const sym = utils_1.getSymbol(a);
        if (sym)
            check_1.check(sym.isEqual(this.symbol), "comparison of assets with different symbols is not allowed");
        check_1.check(amount.notEquals(0), "divide by zero");
        check_1.check(!(this.amount.equals(Asset.max_amount.multiply(-1)) && amount.equals(-1)), "signed division overflow");
        this.amount = this.amount.divide(amount);
        return this;
    }
    /**
     * Division operator, with a number proceeding
     *
     * @param a - The asset to be divided
     * @param b - The divisor for the asset's amount
     * @return asset - New asset as the result of division
     */
    static div(a, b) {
        const result = new Asset(a.amount, a.symbol);
        result.div(b);
        return result;
    }
    /**
     * Equality operator
     *
     * @param a - The first asset to be compared
     * @param b - The second asset to be compared
     * @return true - if both asset has the same amount
     * @return false - otherwise
     * @pre Both asset must have the same symbol
     */
    static isEqual(a, b) {
        check_1.check(a.symbol.isEqual(b.symbol), "comparison of assets with different symbols is not allowed");
        return a.amount.equals(b.amount);
    }
    isEqual(a) {
        check_1.check(a.symbol.isEqual(this.symbol), "comparison of assets with different symbols is not allowed");
        return a.amount.equals(this.amount);
    }
    /**
     * Inequality operator
     *
     * @param a - The first asset to be compared
     * @param b - The second asset to be compared
     * @return true - if both asset doesn't have the same amount
     * @return false - otherwise
     * @pre Both asset must have the same symbol
     */
    static isNotEqual(a, b) {
        return !(a.isEqual(b));
    }
    isNotEqual(a) {
        return !(a.isEqual(this));
    }
    /**
     * Less than operator
     *
     * @param a - The first asset to be compared
     * @param b - The second asset to be compared
     * @return true - if the first asset's amount is less than the second asset amount
     * @return false - otherwise
     * @pre Both asset must have the same symbol
     */
    static isLessThan(a, b) {
        check_1.check(a.symbol.isEqual(b.symbol), "comparison of assets with different symbols is not allowed");
        return a.amount.lesser(b.amount);
    }
    isLessThan(a) {
        check_1.check(a.symbol.isEqual(this.symbol), "comparison of assets with different symbols is not allowed");
        return this.amount.lesser(a.amount);
    }
    /**
     * Less or equal to operator
     *
     * @param a - The first asset to be compared
     * @param b - The second asset to be compared
     * @return true - if the first asset's amount is less or equal to the second asset amount
     * @return false - otherwise
     * @pre Both asset must have the same symbol
     */
    static isLessThanOrEqual(a, b) {
        check_1.check(a.symbol.isEqual(b.symbol), "comparison of assets with different symbols is not allowed");
        return a.amount.lesserOrEquals(b.amount);
    }
    isLessThanOrEqual(a) {
        check_1.check(a.symbol.isEqual(this.symbol), "comparison of assets with different symbols is not allowed");
        return this.amount.lesserOrEquals(a.amount);
    }
    /**
     * Greater than operator
     *
     * @param a - The first asset to be compared
     * @param b - The second asset to be compared
     * @return true - if the first asset's amount is greater than the second asset amount
     * @return false - otherwise
     * @pre Both asset must have the same symbol
     */
    static isGreaterThan(a, b) {
        check_1.check(a.symbol.isEqual(b.symbol), "comparison of assets with different symbols is not allowed");
        return a.amount.greater(b.amount);
    }
    isGreaterThan(a) {
        check_1.check(a.symbol.isEqual(this.symbol), "comparison of assets with different symbols is not allowed");
        return this.amount.greater(a.amount);
    }
    /**
     * Greater or equal to operator
     *
     * @param a - The first asset to be compared
     * @param b - The second asset to be compared
     * @return true - if the first asset's amount is greater or equal to the second asset amount
     * @return false - otherwise
     * @pre Both asset must have the same symbol
     */
    static isGreaterThanOrEqual(a, b) {
        check_1.check(a.symbol.isEqual(b.symbol), "comparison of assets with different symbols is not allowed");
        return a.amount.greaterOrEquals(b.amount);
    }
    isGreaterThanOrEqual(a) {
        check_1.check(a.symbol.isEqual(this.symbol), "comparison of assets with different symbols is not allowed");
        return this.amount.greaterOrEquals(a.amount);
    }
    /**
     * The toString() method returns the string representation of the object.
     */
    toString() {
        return this.to_string();
    }
    to_string() {
        const amount = eosiolib_1.write_decimal(this.amount, this.symbol.precision(), true);
        const symcode = this.symbol.code().to_string();
        return `${amount} ${symcode}`;
    }
}
exports.Asset = Asset;
/**
 * {constexpr int64_t} Maximum amount possible for this asset. It's capped to 2^62 - 1
 */
Asset.max_amount = (big_integer_1.default(1).shiftLeft(62)).minus(1);
exports.asset = (obj1, obj2) => {
    return new Asset(obj1, obj2);
};
