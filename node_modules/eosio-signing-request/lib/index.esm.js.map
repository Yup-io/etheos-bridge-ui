{"version":3,"file":"index.esm.js","sources":["../src/base64u.ts","../node_modules/tslib/tslib.es6.js","../src/chain-id.ts","../src/abi.ts","../src/signing-request.ts"],"sourcesContent":["/**\n * Base64u - URL-Safe Base64 variant no padding.\n * Based on https://gist.github.com/jonleighton/958841\n */\n\nconst charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'\nconst lookup = new Uint8Array(256)\nfor (let i = 0; i < 64; i++) {\n    lookup[charset.charCodeAt(i)] = i\n}\n\nexport function encode(data: Uint8Array): string {\n    const byteLength = data.byteLength\n    const byteRemainder = byteLength % 3\n    const mainLength = byteLength - byteRemainder\n\n    const parts: string[] = []\n\n    let a: number\n    let b: number\n    let c: number\n    let d: number\n    let chunk: number\n\n    // Main loop deals with bytes in chunks of 3\n    for (let i = 0; i < mainLength; i += 3) {\n        // Combine the three bytes into a single integer\n        chunk = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2]\n\n        // Use bitmasks to extract 6-bit segments from the triplet\n        a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18\n        b = (chunk & 258048) >> 12 // 258048   = (2^6 - 1) << 12\n        c = (chunk & 4032) >> 6 // 4032     = (2^6 - 1) << 6\n        d = chunk & 63 // 63       =  2^6 - 1\n\n        // Convert the raw binary segments to the appropriate ASCII encoding\n        parts.push(charset[a] + charset[b] + charset[c] + charset[d])\n    }\n\n    // Deal with the remaining bytes\n    if (byteRemainder === 1) {\n        chunk = data[mainLength]\n\n        a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2\n\n        // Set the 4 least significant bits to zero\n        b = (chunk & 3) << 4 // 3   = 2^2 - 1\n\n        parts.push(charset[a] + charset[b])\n    } else if (byteRemainder === 2) {\n        chunk = (data[mainLength] << 8) | data[mainLength + 1]\n\n        a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10\n        b = (chunk & 1008) >> 4 // 1008  = (2^6 - 1) << 4\n\n        // Set the 2 least significant bits to zero\n        c = (chunk & 15) << 2 // 15    = 2^4 - 1\n\n        parts.push(charset[a] + charset[b] + charset[c])\n    }\n\n    return parts.join('')\n}\n\nexport function decode(input: string): Uint8Array {\n    const byteLength = input.length * 0.75\n    const data = new Uint8Array(byteLength)\n\n    let a: number\n    let b: number\n    let c: number\n    let d: number\n    let p = 0\n\n    for (let i = 0; i < input.length; i += 4) {\n        a = lookup[input.charCodeAt(i)]\n        b = lookup[input.charCodeAt(i + 1)]\n        c = lookup[input.charCodeAt(i + 2)]\n        d = lookup[input.charCodeAt(i + 3)]\n\n        data[p++] = (a << 2) | (b >> 4)\n        data[p++] = ((b & 15) << 4) | (c >> 2)\n        data[p++] = ((c & 3) << 6) | (d & 63)\n    }\n\n    return data\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {Checksum256, Checksum256Type, TypeAlias, UInt8, Variant} from '@greymass/eosio'\n\n/** Chain ID aliases. */\nexport enum ChainName {\n    UNKNOWN = 0,\n    EOS = 1,\n    TELOS = 2,\n    JUNGLE = 3,\n    KYLIN = 4,\n    WORBLI = 5,\n    BOS = 6,\n    MEETONE = 7,\n    INSIGHTS = 8,\n    BEOS = 9,\n    WAX = 10,\n    PROTON = 11,\n    FIO = 12,\n}\n\nexport type ChainIdType = ChainId | ChainName | Checksum256Type\n\n@TypeAlias('chain_id')\nexport class ChainId extends Checksum256 {\n    static from<T extends typeof Checksum256>(this: T, value: ChainIdType): InstanceType<T> {\n        if (value instanceof this) {\n            return value as InstanceType<T>\n        }\n        if (typeof value === 'number') {\n            value = ChainIdLookup.get(value) as Checksum256Type\n            if (!value) {\n                throw new Error('Unknown chain id alias')\n            }\n        }\n        return super.from(value) as InstanceType<T>\n    }\n\n    get chainVariant(): ChainIdVariant {\n        const name = this.chainName\n        if (name !== ChainName.UNKNOWN) {\n            return ChainIdVariant.from(['chain_alias', name])\n        }\n        return ChainIdVariant.from(this)\n    }\n\n    get chainName(): ChainName {\n        const cid = this.hexString\n        for (const [n, id] of ChainIdLookup) {\n            if (id === cid) {\n                return n\n            }\n        }\n        return ChainName.UNKNOWN\n    }\n}\n\n@TypeAlias('chain_alias')\nexport class ChainAlias extends UInt8 {\n    value!: ChainName\n}\n\n@Variant.type('variant_id', [ChainAlias, ChainId])\nexport class ChainIdVariant extends Variant {\n    value!: ChainId | ChainAlias\n\n    get chainId(): ChainId {\n        if (this.value instanceof ChainId) {\n            return this.value\n        }\n        return ChainId.from(this.value.value)\n    }\n}\n\nconst ChainIdLookup = new Map<ChainName, Checksum256Type>([\n    [ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'],\n    [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'],\n    [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'],\n    [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'],\n    [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'],\n    [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'],\n    [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'],\n    [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'],\n    [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'],\n    [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'],\n    [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'],\n    [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c'],\n])\n","/** SigningRequest ABI and typedefs. */\n\nimport {\n    Action,\n    Bytes,\n    Name,\n    PermissionLevel,\n    Signature,\n    Struct,\n    Transaction,\n    TypeAlias,\n    UInt8,\n    Variant,\n} from '@greymass/eosio'\n\nimport {ChainIdVariant} from './chain-id'\n\n@TypeAlias('account_name')\nexport class AccountName extends Name {}\n\n@TypeAlias('permission_name')\nexport class PermissionName extends Name {}\n\n@Struct.type('identity')\nexport class IdentityV2 extends Struct {\n    @Struct.field(PermissionLevel, {optional: true}) permission?: PermissionLevel\n}\n\n@Struct.type('identity')\nexport class IdentityV3 extends Struct {\n    @Struct.field('name') scope!: Name\n    @Struct.field(PermissionLevel, {optional: true}) permission?: PermissionLevel\n}\n\n@Variant.type('variant_req', [Action, {type: Action, array: true}, Transaction, IdentityV2])\nexport class RequestVariantV2 extends Variant {\n    value!: Action | Action[] | Transaction | IdentityV2\n}\n\n@Variant.type('variant_req', [Action, {type: Action, array: true}, Transaction, IdentityV3])\nexport class RequestVariantV3 extends Variant {\n    value!: Action | Action[] | Transaction | IdentityV3\n}\n\n@TypeAlias('request_flags')\nexport class RequestFlags extends UInt8 {\n    static broadcast = 1 << 0\n    static background = 1 << 1\n\n    get broadcast() {\n        return (this.value & RequestFlags.broadcast) !== 0\n    }\n    set broadcast(enabled: boolean) {\n        this.setFlag(RequestFlags.broadcast, enabled)\n    }\n\n    get background() {\n        return (this.value & RequestFlags.background) !== 0\n    }\n    set background(enabled: boolean) {\n        this.setFlag(RequestFlags.background, enabled)\n    }\n\n    private setFlag(flag: number, enabled: boolean) {\n        if (enabled) {\n            this.value |= flag\n        } else {\n            this.value &= ~flag\n        }\n    }\n}\n\n@Struct.type('info_pair')\nexport class InfoPair extends Struct {\n    @Struct.field('string') key!: string\n    @Struct.field('bytes') value!: Bytes\n}\n\n@Struct.type('signing_request')\nexport class RequestDataV2 extends Struct {\n    @Struct.field(ChainIdVariant) chain_id!: ChainIdVariant\n    @Struct.field(RequestVariantV2) req!: RequestVariantV2\n    @Struct.field(RequestFlags) flags!: RequestFlags\n    @Struct.field('string') callback!: string\n    @Struct.field(InfoPair, {array: true}) info!: InfoPair[]\n}\n\n@Struct.type('signing_request')\nexport class RequestDataV3 extends Struct {\n    @Struct.field(ChainIdVariant) chain_id!: ChainIdVariant\n    @Struct.field(RequestVariantV3) req!: RequestVariantV3\n    @Struct.field(RequestFlags) flags!: RequestFlags\n    @Struct.field('string') callback!: string\n    @Struct.field(InfoPair, {array: true}) info!: InfoPair[]\n}\n\n@Struct.type('request_signature')\nexport class RequestSignature extends Struct {\n    @Struct.field('name') signer!: Name\n    @Struct.field('signature') signature!: Signature\n}\n","/**\n * EOSIO Signing Request (ESR).\n */\n\nimport {\n    ABI,\n    ABIDecoder,\n    ABIDef,\n    ABIEncoder,\n    ABISerializable,\n    ABISerializableType,\n    Action,\n    AnyAction,\n    AnyTransaction,\n    Bytes,\n    BytesType,\n    Checksum256,\n    Name,\n    NameType,\n    PermissionLevel,\n    PermissionLevelType,\n    Serializer,\n    Signature,\n    SignatureType,\n    TimePointSec,\n    TimePointType,\n    Transaction,\n    TransactionExtension,\n    UInt16,\n    UInt16Type,\n    UInt32,\n    UInt32Type,\n    UInt8,\n    VarUInt,\n} from '@greymass/eosio'\n\nimport * as base64u from './base64u'\nimport {ChainAlias, ChainId, ChainIdType, ChainIdVariant, ChainName} from './chain-id'\nimport {\n    IdentityV2,\n    IdentityV3,\n    InfoPair,\n    RequestDataV2,\n    RequestDataV3,\n    RequestFlags,\n    RequestSignature,\n} from './abi'\n\n/** Current supported protocol version, backwards compatible with version 2. */\nexport const ProtocolVersion = 3\n\n/** Interface that should be implemented by abi providers. */\nexport interface AbiProvider {\n    /**\n     * Return a promise that resolves to an abi object for the given account name,\n     * e.g. the result of a rpc call to chain/get_abi.\n     */\n    getAbi: (account: Name) => Promise<ABIDef>\n}\n\n/** Interface that should be implemented by zlib implementations. */\nexport interface ZlibProvider {\n    /** Deflate data w/o adding zlib header. */\n    deflateRaw: (data: Uint8Array) => Uint8Array\n    /** Inflate data w/o requiring zlib header. */\n    inflateRaw: (data: Uint8Array) => Uint8Array\n}\n\n/** Interface that should be implemented by signature providers. */\nexport interface SignatureProvider {\n    /** Sign 32-byte message and return signer name and signature string. */\n    sign: (message: Checksum256) => {signer: NameType; signature: SignatureType}\n}\n\n/**\n * The callback payload sent to background callbacks.\n */\nexport interface CallbackPayload {\n    /** The first signature. */\n    sig: string\n    /** Transaction ID as HEX-encoded string. */\n    tx: string\n    /** Block number hint (only present if transaction was broadcast). */\n    bn?: string\n    /** Signer authority, aka account name. */\n    sa: string\n    /** Signer permission, e.g. \"active\". */\n    sp: string\n    /** Reference block num used when resolving request. */\n    rbn: string\n    /** Reference block id used when resolving request. */\n    rid: string\n    /** The originating signing request packed as a uri string. */\n    req: string\n    /** Expiration time used when resolving request. */\n    ex: string\n    /** All signatures 0-indexed as `sig0`, `sig1`, etc. */\n    [sig0: string]: string | undefined\n}\n\n/**\n * Context used to resolve a callback.\n * Compatible with the JSON response from a `push_transaction` call.\n */\nexport interface ResolvedCallback {\n    /** The URL to hit. */\n    url: string\n    /**\n     * Whether to run the request in the background. For a https url this\n     * means POST in the background instead of a GET redirect.\n     */\n    background: boolean\n    /**\n     * The callback payload as a object that should be encoded to JSON\n     * and POSTed to background callbacks.\n     */\n    payload: CallbackPayload\n}\n\n/**\n * Context used to resolve a transaction.\n * Compatible with the JSON response from a `get_block` call.\n */\nexport interface TransactionContext {\n    /** Timestamp expiration will be derived from. */\n    timestamp?: TimePointType\n    /**\n     * How many seconds in the future to set expiration when deriving from timestamp.\n     * Defaults to 60 seconds if unset.\n     */\n    expire_seconds?: UInt32Type\n    /** Block number ref_block_num will be derived from. */\n    block_num?: UInt32Type\n    /** Reference block number, takes precedence over block_num if both is set. */\n    ref_block_num?: UInt16Type\n    /** Reference block prefix. */\n    ref_block_prefix?: UInt32Type\n    /** Expiration timestamp, takes precedence over timestamp and expire_seconds if set. */\n    expiration?: TimePointType\n    /** Chain ID to resolve for, required for multi-chain requests. */\n    chainId?: ChainIdType\n}\n\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\nexport const PlaceholderName = Name.from('............1') // aka uint64(1)\n\n/** Placeholder that will resolve to signer permission name. */\nexport const PlaceholderPermission = Name.from('............2') // aka uint64(2)\n\nexport const PlaceholderAuth = PermissionLevel.from({\n    actor: PlaceholderName,\n    permission: PlaceholderPermission,\n})\n\nexport interface ResolvedAction {\n    /** The account (a.k.a. contract) to run action on. */\n    account: Name\n    /** The name of the action. */\n    name: Name\n    /** The permissions authorizing the action. */\n    authorization: PermissionLevel[]\n    /** The decoded action data. */\n    data: Record<string, ABISerializable>\n}\n\nexport interface ResolvedTransaction {\n    /** The time at which a transaction expires. */\n    expiration: TimePointSec\n    /** *Specifies a block num in the last 2^16 blocks. */\n    ref_block_num: UInt16\n    /** Specifies the lower 32 bits of the block id. */\n    ref_block_prefix: UInt32\n    /** Upper limit on total network bandwidth (in 8 byte words) billed for this transaction. */\n    max_net_usage_words: VarUInt\n    /** Upper limit on the total CPU time billed for this transaction. */\n    max_cpu_usage_ms: UInt8\n    /** Number of seconds to delay this transaction for during which it may be canceled. */\n    delay_sec: VarUInt\n    /** The context free actions in the transaction. */\n    context_free_actions: ResolvedAction[]\n    /** The actions in the transaction. */\n    actions: ResolvedAction[]\n    /** Transaction extensions. */\n    transaction_extensions: TransactionExtension[]\n}\n\nexport type CallbackType = string | {url: string; background: boolean}\n\ninterface SigningRequestCommonArguments {\n    /**\n     * Chain ID to use, can be set to `null` for a multi-chain request.\n     * Defaults to EOS if omitted.\n     */\n    chainId?: ChainIdType | null\n    /**\n     * Chain IDs to constrain a multi-chain request to.\n     * Only considered if `chainId` is explicitly set to `null.\n     */\n    chainIds?: ChainIdType[]\n    /** Optional metadata to pass along with the request. */\n    info?: {[key: string]: Bytes | ABISerializable}\n}\n\nexport interface SigningRequestCreateArguments extends SigningRequestCommonArguments {\n    /** Single action to create request with. */\n    action?: AnyAction\n    /** Multiple actions to create request with. */\n    actions?: AnyAction[]\n    /**\n     * Full or partial transaction to create request with.\n     * If TAPoS info is omitted it will be filled in when resolving the request.\n     */\n    transaction?: Partial<AnyTransaction>\n    /** Create an identity request. */\n    identity?: {\n        scope?: NameType\n        permission?: PermissionLevelType\n    }\n    /** Whether wallet should broadcast tx, defaults to true. */\n    broadcast?: boolean\n    /**\n     * Optional callback URL the signer should hit after\n     * broadcasting or signing. Passing a string means background = false.\n     */\n    callback?: CallbackType\n}\n\nexport interface SigningRequestCreateIdentityArguments extends SigningRequestCommonArguments {\n    /**\n     * Callback where the identity should be delivered.\n     */\n    callback: CallbackType\n    /**\n     * Requested account name of identity.\n     * Defaults to placeholder (any identity) if omitted.\n     */\n    account?: NameType\n    /**\n     * Requested account permission.\n     * Defaults to placeholder (any permission) if omitted.\n     */\n    permission?: NameType\n    /**\n     * Scope for the request.\n     */\n    scope?: NameType\n}\n\nexport interface SigningRequestEncodingOptions {\n    /** Optional zlib, if provided the request will be compressed when encoding. */\n    zlib?: ZlibProvider\n    /** Abi provider, required if the arguments contain un-encoded actions. */\n    abiProvider?: AbiProvider\n    /** Optional signature provider, will be used to create a request signature if provided. */\n    signatureProvider?: SignatureProvider\n}\n\nexport type AbiMap = Map<string, ABI>\n\nexport class SigningRequest {\n    /** Return the identity ABI for given version. */\n    private static identityAbi(version: number) {\n        const abi = Serializer.synthesize(this.identityType(version))\n        abi.actions = [{name: 'identity', type: 'identity', ricardian_contract: ''}]\n        return abi\n    }\n\n    /** Return the ABISerializableType identity type for given version. */\n    private static identityType(version: number): typeof IdentityV2 | typeof IdentityV3 {\n        return version === 2 ? IdentityV2 : IdentityV3\n    }\n\n    /** Return the ABISerializableType storage type for given version. */\n    private static storageType(version: number): typeof RequestDataV3 | typeof RequestDataV2 {\n        return version === 2 ? RequestDataV2 : RequestDataV3\n    }\n\n    /** Create a new signing request. */\n    public static async create(\n        args: SigningRequestCreateArguments,\n        options: SigningRequestEncodingOptions = {}\n    ) {\n        let actions: AnyAction[]\n        if (args.action) {\n            actions = [args.action]\n        } else if (args.actions) {\n            actions = args.actions\n        } else if (args.transaction) {\n            actions = args.transaction.actions || []\n        } else {\n            actions = []\n        }\n        const requiredAbis = actions\n            .filter(\n                (action) =>\n                    !Bytes.isBytes(action.data) &&\n                    (action.data.constructor as any).abiName === undefined\n            )\n            .map((action) => Name.from(action.account))\n        const abis: Record<string, ABIDef> = {}\n        if (requiredAbis.length > 0) {\n            const provider = options.abiProvider\n            if (!provider) {\n                throw new Error('Missing abi provider')\n            }\n            const accountAbis = await Promise.all(\n                requiredAbis.map((account) => provider.getAbi(account))\n            )\n            for (const [idx, abi] of accountAbis.entries()) {\n                abis[requiredAbis[idx].toString()] = abi\n            }\n        }\n        return this.createSync(args, options, abis)\n    }\n\n    /**\n     * Synchronously create a new signing request.\n     * @throws If an un-encoded action with no abi def is encountered.\n     */\n    public static createSync(\n        args: SigningRequestCreateArguments,\n        options: SigningRequestEncodingOptions = {},\n        abis: Record<string, ABIDef> = {}\n    ) {\n        let version = 2\n        const data: any = {}\n        const encode = (action: AnyAction) => encodeAction(action, abis)\n\n        // multi-chain requests requires version 3\n        if (args.chainId === null) {\n            version = 3\n        }\n\n        // set the request data\n        if (args.identity !== undefined) {\n            if (args.identity.scope) {\n                version = 3\n            }\n            data.req = ['identity', this.identityType(version).from(args.identity)]\n        } else if (args.action && !args.actions && !args.transaction) {\n            data.req = ['action', encode(args.action)]\n        } else if (args.actions && !args.action && !args.transaction) {\n            if (args.actions.length === 1) {\n                data.req = ['action', encode(args.actions[0])]\n            } else {\n                data.req = ['action[]', args.actions.map(encode)]\n            }\n        } else if (args.transaction && !args.action && !args.actions) {\n            const tx = args.transaction\n            // set default values if missing\n            if (tx.expiration === undefined) {\n                tx.expiration = '1970-01-01T00:00:00.000'\n            }\n            if (tx.ref_block_num === undefined) {\n                tx.ref_block_num = 0\n            }\n            if (tx.ref_block_prefix === undefined) {\n                tx.ref_block_prefix = 0\n            }\n            if (tx.context_free_actions === undefined) {\n                tx.context_free_actions = []\n            }\n            if (tx.transaction_extensions === undefined) {\n                tx.transaction_extensions = []\n            }\n            if (tx.delay_sec === undefined) {\n                tx.delay_sec = 0\n            }\n            if (tx.max_cpu_usage_ms === undefined) {\n                tx.max_cpu_usage_ms = 0\n            }\n            if (tx.max_net_usage_words === undefined) {\n                tx.max_net_usage_words = 0\n            }\n            if (tx.actions === undefined) {\n                tx.actions = []\n            }\n            if (tx.context_free_actions === undefined) {\n                tx.context_free_actions = []\n            }\n            // encode actions if needed\n            tx.actions = tx.actions.map(encode)\n            data.req = ['transaction', tx]\n        } else {\n            throw new TypeError(\n                'Invalid arguments: Must have exactly one of action, actions or transaction'\n            )\n        }\n\n        // set the chain id\n        if (args.chainId === null) {\n            data.chain_id = ChainIdVariant.from(['chain_alias', 0])\n        } else {\n            data.chain_id = ChainId.from(args.chainId || ChainName.EOS).chainVariant\n        }\n\n        // request flags and callback\n        const flags = RequestFlags.from(0)\n        let callback = ''\n        flags.broadcast = args.broadcast !== undefined ? args.broadcast : data.req[0] !== 'identity'\n        if (typeof args.callback === 'string') {\n            callback = args.callback\n        } else if (typeof args.callback === 'object') {\n            callback = args.callback.url\n            flags.background = args.callback.background || false\n        }\n        data.flags = flags\n        data.callback = callback\n\n        // info pairs\n        data.info = []\n        if (typeof args.info === 'object') {\n            for (const key in args.info) {\n                const isOwn = Object.prototype.hasOwnProperty.call(args.info, key)\n                if (isOwn) {\n                    let value = args.info[key]\n                    if (!(value instanceof Bytes)) {\n                        value = Serializer.encode({object: value})\n                    }\n                    data.info.push({key, value})\n                }\n            }\n        }\n        if (args.chainIds && args.chainId === null) {\n            const ids = args.chainIds.map((id) => ChainId.from(id).chainVariant)\n            data.info.push({\n                key: 'chain_ids',\n                value: Serializer.encode({object: ids, type: {type: ChainIdVariant, array: true}}),\n            })\n        }\n\n        const req = new SigningRequest(\n            version,\n            this.storageType(version).from(data),\n            options.zlib,\n            options.abiProvider\n        )\n\n        // sign the request if given a signature provider\n        if (options.signatureProvider) {\n            req.sign(options.signatureProvider)\n        }\n\n        return req\n    }\n\n    /** Creates an identity request. */\n    public static identity(\n        args: SigningRequestCreateIdentityArguments,\n        options: SigningRequestEncodingOptions = {}\n    ) {\n        let permission: PermissionLevelType | undefined = {\n            actor: args.account || PlaceholderName,\n            permission: args.permission || PlaceholderPermission,\n        }\n        if (\n            permission.actor === PlaceholderName &&\n            permission.permission === PlaceholderPermission\n        ) {\n            permission = undefined\n        }\n        return this.createSync(\n            {\n                ...args,\n                identity: {\n                    permission,\n                    scope: args.scope,\n                },\n                broadcast: false,\n            },\n            options\n        )\n    }\n\n    /**\n     * Create a request from a chain id and serialized transaction.\n     * @param chainId The chain id where the transaction is valid.\n     * @param serializedTransaction The serialized transaction.\n     * @param options Creation options.\n     */\n    public static fromTransaction(\n        chainId: ChainIdType,\n        serializedTransaction: BytesType,\n        options: SigningRequestEncodingOptions = {}\n    ) {\n        const id = ChainId.from(chainId)\n        serializedTransaction = Bytes.from(serializedTransaction)\n\n        const encoder = new ABIEncoder()\n        encoder.writeByte(2) // header\n        encoder.writeArray(Serializer.encode({object: id.chainVariant}).array)\n        encoder.writeByte(2) // transaction variant\n        encoder.writeArray(Bytes.from(serializedTransaction).array)\n        encoder.writeByte(RequestFlags.broadcast)\n        encoder.writeByte(0) // callback\n        encoder.writeByte(0) // info\n\n        return SigningRequest.fromData(encoder.getData(), options)\n    }\n\n    /** Creates a signing request from encoded `esr:` uri string. */\n    public static from(uri: string, options: SigningRequestEncodingOptions = {}) {\n        if (typeof uri !== 'string') {\n            throw new Error('Invalid request uri')\n        }\n        const [scheme, path] = uri.split(':')\n        if (scheme !== 'esr' && scheme !== 'web+esr') {\n            throw new Error('Invalid scheme')\n        }\n        const data = base64u.decode(path.startsWith('//') ? path.slice(2) : path)\n        return SigningRequest.fromData(data, options)\n    }\n\n    public static fromData(data: BytesType, options: SigningRequestEncodingOptions = {}) {\n        data = Bytes.from(data)\n        const header = data.array[0]\n        const version = header & ~(1 << 7)\n        if (version !== 2 && version !== 3) {\n            throw new Error('Unsupported protocol version')\n        }\n        let payload = data.droppingFirst(1)\n        if ((header & (1 << 7)) !== 0) {\n            if (!options.zlib) {\n                throw new Error('Compressed URI needs zlib')\n            }\n            payload = Bytes.from(options.zlib.inflateRaw(payload.array))\n        }\n        const decoder = new ABIDecoder(payload.array)\n        const req = Serializer.decode({data: decoder, type: this.storageType(version)})\n        let sig: RequestSignature | undefined\n        if (decoder.canRead()) {\n            sig = Serializer.decode({data: decoder, type: RequestSignature}) as RequestSignature\n        }\n        return new SigningRequest(version, req, options.zlib, options.abiProvider, sig)\n    }\n\n    /** The signing request version. */\n    public version: number\n\n    /** The raw signing request data. */\n    public data: RequestDataV2 | RequestDataV3\n\n    /** The request signature. */\n    public signature?: RequestSignature\n\n    private zlib?: ZlibProvider\n    private abiProvider?: AbiProvider\n\n    /**\n     * Create a new signing request.\n     * Normally not used directly, see the `create` and `from` class methods.\n     */\n    constructor(\n        version: number,\n        data: RequestDataV2 | RequestDataV3,\n        zlib?: ZlibProvider,\n        abiProvider?: AbiProvider,\n        signature?: RequestSignature\n    ) {\n        if (data.flags.broadcast && data.req.variantName === 'identity') {\n            throw new Error('Invalid request (identity request cannot be broadcast)')\n        }\n        this.version = version\n        this.data = data\n        this.zlib = zlib\n        this.abiProvider = abiProvider\n        this.signature = signature\n    }\n\n    /**\n     * Sign the request, mutating.\n     * @param signatureProvider The signature provider that provides a signature for the signer.\n     */\n    public sign(signatureProvider: SignatureProvider) {\n        const message = this.getSignatureDigest()\n        this.signature = RequestSignature.from(signatureProvider.sign(message))\n    }\n\n    /**\n     * Get the signature digest for this request.\n     */\n    public getSignatureDigest() {\n        // protocol version + utf8 \"request\"\n        const prefix = [this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74]\n        return new Bytes().appending(prefix).appending(this.getData()).sha256Digest\n    }\n\n    /**\n     * Set the signature data for this request, mutating.\n     * @param signer Account name of signer.\n     * @param signature The signature string.\n     */\n    public setSignature(signer: string, signature: string) {\n        this.signature = RequestSignature.from({signer, signature})\n    }\n\n    /**\n     * Set the request callback, mutating.\n     * @param url Where the callback should be sent.\n     * @param background Whether the callback should be sent in the background.\n     */\n    public setCallback(url: string, background: boolean) {\n        this.data.callback = url\n        this.data.flags.background = background\n    }\n\n    /**\n     * Set broadcast flag.\n     * @param broadcast Whether the transaction should be broadcast by receiver.\n     */\n    public setBroadcast(broadcast: boolean) {\n        this.data.flags.broadcast = broadcast\n    }\n\n    /**\n     * Encode this request into an `esr:` uri.\n     * @argument compress Whether to compress the request data using zlib,\n     *                    defaults to true if omitted and zlib is present;\n     *                    otherwise false.\n     * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n     *                   Defaults to true.\n     * @returns An esr uri string.\n     */\n    public encode(compress?: boolean, slashes?: boolean): string {\n        const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined\n        if (shouldCompress && this.zlib === undefined) {\n            throw new Error('Need zlib to compress')\n        }\n        let header = this.version\n        const data = this.getData()\n        const sigData = this.getSignatureData()\n        let array = new Uint8Array(data.byteLength + sigData.byteLength)\n        array.set(data, 0)\n        array.set(sigData, data.byteLength)\n        if (shouldCompress) {\n            const deflated = this.zlib!.deflateRaw(array)\n            if (array.byteLength > deflated.byteLength) {\n                header |= 1 << 7\n                array = deflated\n            }\n        }\n        const out = new Uint8Array(1 + array.byteLength)\n        out[0] = header\n        out.set(array, 1)\n        let scheme = 'esr:'\n        if (slashes !== false) {\n            scheme += '//'\n        }\n        return scheme + base64u.encode(out)\n    }\n\n    /** Get the request data without header or signature. */\n    public getData(): Uint8Array {\n        return Serializer.encode({object: this.data}).array\n    }\n\n    /** Get signature data, returns an empty array if request is not signed. */\n    public getSignatureData(): Uint8Array {\n        if (!this.signature) {\n            return new Uint8Array(0)\n        }\n        return Serializer.encode({object: this.signature}).array\n    }\n\n    /** ABI definitions required to resolve request. */\n    public getRequiredAbis() {\n        return this.getRawActions()\n            .filter((action) => !isIdentity(action))\n            .map((action) => action.account)\n            .filter((value, index, self) => self.indexOf(value) === index)\n    }\n\n    /** Whether TaPoS values are required to resolve request. */\n    public requiresTapos() {\n        const tx = this.getRawTransaction()\n        return !this.isIdentity() && !hasTapos(tx)\n    }\n\n    /** Resolve required ABI definitions. */\n    public async fetchAbis(abiProvider?: AbiProvider): Promise<AbiMap> {\n        const required = this.getRequiredAbis()\n        if (required.length > 0) {\n            const provider = abiProvider || this.abiProvider\n            if (!provider) {\n                throw new Error('Missing ABI provider')\n            }\n            const abis = new Map<string, any>()\n            await Promise.all(\n                required.map(async (account) => {\n                    abis.set(account.toString(), ABI.from(await provider.getAbi(account)))\n                })\n            )\n            return abis\n        } else {\n            return new Map()\n        }\n    }\n\n    /**\n     * Decode raw actions actions to object representations.\n     * @param abis ABI defenitions required to decode all actions.\n     * @param signer Placeholders in actions will be resolved to signer if set.\n     */\n    public resolveActions(abis: AbiMap, signer?: PermissionLevelType): ResolvedAction[] {\n        return this.getRawActions().map((rawAction) => {\n            let abi: ABI\n            if (isIdentity(rawAction)) {\n                abi = (this.constructor as typeof SigningRequest).identityAbi(this.version)\n            } else {\n                const rawAbi = abis.get(rawAction.account.toString())\n                if (!rawAbi) {\n                    throw new Error(`Missing ABI definition for ${rawAction.account}`)\n                }\n                abi = ABI.from(rawAbi)\n            }\n            const type = abi.getActionType(rawAction.name)\n            if (!type) {\n                throw new Error(\n                    `Missing type for action ${rawAction.account}:${rawAction.name} in ABI`\n                )\n            }\n            let data = rawAction.decodeData(abi) as Record<string, ABISerializable>\n            let authorization = rawAction.authorization\n            if (signer) {\n                const signerPerm = PermissionLevel.from(signer)\n                const resolve = (value: any): any => {\n                    if (value instanceof Name) {\n                        if (value.equals(PlaceholderName)) {\n                            return signerPerm.actor\n                        } else if (value.equals(PlaceholderPermission)) {\n                            return signerPerm.permission\n                        } else {\n                            return value\n                        }\n                    } else if (Array.isArray(value)) {\n                        return value.map(resolve)\n                    } else if (typeof value === 'object' && value !== null) {\n                        for (const key of Object.keys(value)) {\n                            value[key] = resolve(value[key])\n                        }\n                        return value\n                    } else {\n                        return value\n                    }\n                }\n                data = resolve(data)\n                authorization = authorization.map((auth) => {\n                    let {actor, permission} = auth\n                    if (actor.equals(PlaceholderName)) {\n                        actor = signerPerm.actor\n                    }\n                    if (permission.equals(PlaceholderPermission)) {\n                        permission = signerPerm.permission\n                    }\n                    // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n                    if (permission.equals(PlaceholderName)) {\n                        permission = signerPerm.permission\n                    }\n                    return PermissionLevel.from({actor, permission})\n                })\n            }\n            return {\n                ...rawAction,\n                authorization,\n                data,\n            }\n        })\n    }\n\n    public resolveTransaction(\n        abis: AbiMap,\n        signer: PermissionLevelType,\n        ctx: TransactionContext = {}\n    ) {\n        const tx = this.getRawTransaction()\n        if (!this.isIdentity() && !hasTapos(tx)) {\n            if (\n                ctx.expiration !== undefined &&\n                ctx.ref_block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined\n            ) {\n                tx.expiration = TimePointSec.from(ctx.expiration)\n                tx.ref_block_num = UInt16.from(ctx.ref_block_num)\n                tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix)\n            } else if (\n                ctx.block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined &&\n                ctx.timestamp !== undefined\n            ) {\n                tx.expiration = expirationTime(ctx.timestamp, ctx.expire_seconds)\n                tx.ref_block_num = UInt16.from(ctx.block_num)\n                tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix)\n            } else {\n                throw new Error(\n                    'Invalid transaction context, need either a reference block or explicit TaPoS values'\n                )\n            }\n        } else if (this.isIdentity() && this.version > 2) {\n            // From ESR version 3 all identity requests have expiration\n            tx.expiration = ctx.expiration\n                ? TimePointSec.from(ctx.expiration)\n                : expirationTime(ctx.timestamp, ctx.expire_seconds)\n        }\n        const actions = this.resolveActions(abis, signer)\n        // TODO: resolve context free actions\n        const context_free_actions = (tx.context_free_actions as unknown) as ResolvedAction[]\n        return {...tx, context_free_actions, actions} as ResolvedTransaction\n    }\n\n    public resolve(abis: AbiMap, signer: PermissionLevelType, ctx: TransactionContext = {}) {\n        const tx = this.resolveTransaction(abis, signer, ctx)\n        const actions = tx.actions.map((action) => {\n            let abi: ABI | undefined\n            if (isIdentity(action)) {\n                abi = (this.constructor as typeof SigningRequest).identityAbi(this.version)\n            } else {\n                abi = abis.get(action.account.toString())\n            }\n            if (!abi) {\n                throw new Error(`Missing ABI definition for ${action.account}`)\n            }\n            const type = abi.getActionType(action.name)!\n            const data = Serializer.encode({object: action.data, type, abi})\n            return Action.from({...action, data})\n        })\n        const transaction = Transaction.from({...tx, actions})\n        let chainId: ChainId\n        if (this.isMultiChain()) {\n            if (!ctx.chainId) {\n                throw new Error('Missing chosen chain ID for multi-chain request')\n            }\n            chainId = ChainId.from(ctx.chainId)\n            const ids = this.getChainIds()\n            if (ids && !ids.some((id) => chainId.equals(id))) {\n                throw new Error('Trying to resolve for chain ID not defined in request')\n            }\n        } else {\n            chainId = this.getChainId()\n        }\n        return new ResolvedSigningRequest(\n            this,\n            PermissionLevel.from(signer),\n            transaction,\n            tx,\n            chainId\n        )\n    }\n\n    /**\n     * Get the id of the chain where this request is valid.\n     * @returns The 32-byte chain id as hex encoded string.\n     */\n    public getChainId(): ChainId {\n        return this.data.chain_id.chainId\n    }\n\n    /**\n     * Chain IDs this request is valid for, only valid for multi chain requests. Value of `null` when `isMultiChain` is true denotes any chain.\n     */\n    public getChainIds(): ChainId[] | null {\n        if (!this.isMultiChain()) {\n            return null\n        }\n        const ids = this.getInfoKey('chain_ids', {type: ChainIdVariant, array: true}) as\n            | ChainIdVariant[]\n            | undefined\n        if (ids) {\n            return ids.map((id) => id.chainId)\n        }\n        return null\n    }\n\n    /**\n     * Set chain IDs this request is valid for, only considered for multi chain requests.\n     */\n    public setChainIds(ids: ChainIdType[]) {\n        const value = ids.map((id) => ChainId.from(id).chainVariant)\n        this.setInfoKey('chain_ids', value, {type: ChainIdVariant, array: true})\n    }\n\n    /**\n     * True if chainId is set to chain alias `0` which indicates that the request is valid for any chain.\n     */\n    public isMultiChain(): boolean {\n        return (\n            this.data.chain_id.variantIdx === 0 &&\n            (this.data.chain_id.value as ChainAlias).value === ChainName.UNKNOWN\n        )\n    }\n\n    /** Return the actions in this request with action data encoded. */\n    public getRawActions(): Action[] {\n        const req = this.data.req\n        switch (req.variantName) {\n            case 'action':\n                return [req.value as Action]\n            case 'action[]':\n                return req.value as Action[]\n            case 'identity': {\n                if (this.version === 2) {\n                    const id = req.value as IdentityV2\n                    let data: BytesType = '0101000000000000000200000000000000' // placeholder permission\n                    let authorization: PermissionLevelType[] = [PlaceholderAuth]\n                    if (id.permission) {\n                        data = Serializer.encode({object: id})\n                        authorization = [id.permission]\n                    }\n                    return [\n                        Action.from({\n                            account: '',\n                            name: 'identity',\n                            authorization,\n                            data,\n                        }),\n                    ]\n                } else {\n                    // eslint-disable-next-line prefer-const\n                    let {scope, permission} = req.value as IdentityV3\n                    if (!permission) {\n                        permission = PlaceholderAuth\n                    }\n                    const data = Serializer.encode({object: {scope, permission}, type: IdentityV3})\n                    return [\n                        Action.from({\n                            account: '',\n                            name: 'identity',\n                            authorization: [permission],\n                            data,\n                        }),\n                    ]\n                }\n            }\n            case 'transaction':\n                return (req.value as Transaction).actions\n            default:\n                throw new Error('Invalid signing request data')\n        }\n    }\n\n    /** Unresolved transaction. */\n    public getRawTransaction(): Transaction {\n        const req = this.data.req\n        switch (req.variantName) {\n            case 'transaction':\n                return Transaction.from({...(req.value as Transaction)})\n            case 'action':\n            case 'action[]':\n            case 'identity':\n                return Transaction.from({\n                    actions: this.getRawActions(),\n                    context_free_actions: [],\n                    transaction_extensions: [],\n                    expiration: '1970-01-01T00:00:00.000',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_cpu_usage_ms: 0,\n                    max_net_usage_words: 0,\n                    delay_sec: 0,\n                })\n            default:\n                throw new Error('Invalid signing request data')\n        }\n    }\n\n    /** Whether the request is an identity request. */\n    public isIdentity(): boolean {\n        return this.data.req.variantName === 'identity'\n    }\n\n    /** Whether the request should be broadcast by signer. */\n    public shouldBroadcast(): boolean {\n        if (this.isIdentity()) {\n            return false\n        }\n        return this.data.flags.broadcast\n    }\n\n    /**\n     * Present if the request is an identity request and requests a specific account.\n     * @note This returns `nil` unless a specific identity has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    public getIdentity(): Name | null {\n        if (!this.isIdentity()) {\n            return null\n        }\n        const id = this.data.req.value as IdentityV2\n        if (id.permission && !id.permission.actor.equals(PlaceholderName)) {\n            return id.permission.actor\n        }\n        return null\n    }\n\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    public getIdentityPermission(): Name | null {\n        if (!this.isIdentity()) {\n            return null\n        }\n        const id = this.data.req.value as IdentityV2\n        if (id.permission && !id.permission.permission.equals(PlaceholderPermission)) {\n            return id.permission.permission\n        }\n        return null\n    }\n\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    public getIdentityScope(): Name | null {\n        if (!this.isIdentity() || this.version <= 2) {\n            return null\n        }\n        const id = this.data.req.value as IdentityV3\n        return id.scope\n    }\n\n    /** Get raw info dict */\n    public getRawInfo(): {[key: string]: Bytes} {\n        const rv: {[key: string]: Bytes} = {}\n        for (const {key, value} of this.data.info) {\n            rv[key] = value\n        }\n        return rv\n    }\n\n    public getRawInfoKey(key: string) {\n        const pair = this.data.info.find((pair) => pair.key === key)\n        if (pair) {\n            return pair.value\n        }\n    }\n\n    public setRawInfoKey(key: string, value: BytesType) {\n        let pair = this.data.info.find((pair) => pair.key === key)\n        if (!pair) {\n            pair = InfoPair.from({key, value})\n            this.data.info.push(pair)\n        } else {\n            pair.value = Bytes.from(value)\n        }\n    }\n\n    /** Set a metadata key. */\n    public setInfoKey(key: string, object: any, type?: ABISerializableType) {\n        this.setRawInfoKey(key, Serializer.encode({object, type}))\n    }\n\n    /** Get a metadata key. */\n    public getInfoKey<T extends ABISerializable>(key: string, type: ABISerializableType) {\n        const data = this.getRawInfoKey(key)\n        if (data) {\n            return Serializer.decode({data, type}) as T\n        }\n    }\n\n    /** Return a deep copy of this request. */\n    public clone(): SigningRequest {\n        let signature: RequestSignature | undefined\n        if (this.signature) {\n            signature = RequestSignature.from(JSON.parse(JSON.stringify(this.signature)))\n        }\n        const RequestData = (this.constructor as typeof SigningRequest).storageType(this.version)\n        const data = RequestData.from(JSON.parse(JSON.stringify(this.data)))\n        return new SigningRequest(this.version, data, this.zlib, this.abiProvider, signature)\n    }\n\n    // Convenience methods.\n\n    public toString() {\n        return this.encode()\n    }\n\n    public toJSON() {\n        return this.encode()\n    }\n}\n\nexport class ResolvedSigningRequest {\n    /** Recreate a resolved request from a callback payload. */\n    static async fromPayload(\n        payload: CallbackPayload,\n        options: SigningRequestEncodingOptions = {}\n    ): Promise<ResolvedSigningRequest> {\n        const request = SigningRequest.from(payload.req, options)\n        const abis = await request.fetchAbis()\n        return request.resolve(\n            abis,\n            {actor: payload.sa, permission: payload.sp},\n            {\n                ref_block_num: payload.rbn,\n                ref_block_prefix: payload.rid,\n                expiration: payload.ex,\n                chainId: payload.cid,\n            }\n        )\n    }\n\n    /** The request that created the transaction. */\n    public readonly request: SigningRequest\n    /** Expected signer of transaction. */\n    public readonly signer: PermissionLevel\n    /** Transaction object with action data encoded. */\n    public readonly transaction: Transaction\n    /** Transaction object with action data decoded. */\n    public readonly resolvedTransaction: ResolvedTransaction\n    /** Id of chain where the request was resolved. */\n    public readonly chainId: ChainId\n\n    constructor(\n        request: SigningRequest,\n        signer: PermissionLevel,\n        transaction: Transaction,\n        resolvedTransaction: ResolvedTransaction,\n        chainId: ChainId\n    ) {\n        this.request = request\n        this.signer = signer\n        this.transaction = transaction\n        this.resolvedTransaction = resolvedTransaction\n        this.chainId = chainId\n    }\n\n    public get serializedTransaction(): Uint8Array {\n        return Serializer.encode({object: this.transaction}).array\n    }\n\n    public get signingDigest(): Checksum256 {\n        return this.transaction.signingDigest(this.chainId)\n    }\n\n    public getCallback(\n        signatures: SignatureType[],\n        blockNum?: UInt32Type\n    ): ResolvedCallback | null {\n        const {callback, flags} = this.request.data\n        if (!callback || callback.length === 0) {\n            return null\n        }\n        if (!signatures || signatures.length === 0) {\n            throw new Error('Must have at least one signature to resolve callback')\n        }\n        const sigs = signatures.map((sig) => Signature.from(sig))\n        const payload: CallbackPayload = {\n            sig: String(sigs[0]),\n            tx: String(this.transaction.id),\n            rbn: String(this.transaction.ref_block_num),\n            rid: String(this.transaction.ref_block_prefix),\n            ex: String(this.transaction.expiration),\n            req: this.request.encode(),\n            sa: String(this.signer.actor),\n            sp: String(this.signer.permission),\n            cid: String(this.chainId),\n        }\n        for (const [n, sig] of sigs.slice(1).entries()) {\n            payload[`sig${n}`] = String(sig)\n        }\n        if (blockNum) {\n            payload.bn = String(UInt32.from(blockNum))\n        }\n        const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {\n            return payload[m] || ''\n        })\n        return {\n            background: flags.background,\n            payload,\n            url,\n        }\n    }\n}\n\nfunction encodeAction(action: AnyAction, abis: Record<string, ABIDef>): Action {\n    if (Bytes.isBytes(action.data) || (action.data.constructor as any).abiName !== undefined) {\n        return Action.from(action)\n    }\n    const abi = abis[String(Name.from(action.account))]\n    if (!abi) {\n        throw new Error(`Missing abi for ${action.account}`)\n    }\n    return Action.from(action, abi)\n}\n\nfunction isIdentity(action: AnyAction) {\n    const account = Name.from(action.account)\n    const name = Name.from(action.name)\n    return account.rawValue.equals(0) && name.equals('identity')\n}\n\nfunction hasTapos(tx: Transaction) {\n    return !(\n        tx.expiration.value.value === 0 &&\n        tx.ref_block_num.value === 0 &&\n        tx.ref_block_prefix.value === 0\n    )\n}\n\nfunction expirationTime(timestamp?: TimePointType, expireSeconds: UInt32Type = 60) {\n    const ts = TimePointSec.from(timestamp || new Date())\n    const exp = UInt32.from(expireSeconds)\n    return TimePointSec.fromMilliseconds(ts.toMilliseconds() + exp.value * 1000)\n}\n"],"names":["charset","lookup","Uint8Array","i","charCodeAt","__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","ChainName","ChainId","Checksum256","[object Object]","value","ChainIdLookup","get","Error","from","chainVariant","name","this","chainName","ChainIdVariant","UNKNOWN","cid","hexString","n","id","TypeAlias","ChainAlias","UInt8","Variant","chainId","type","Map","EOS","TELOS","JUNGLE","KYLIN","WORBLI","BOS","MEETONE","INSIGHTS","BEOS","WAX","PROTON","FIO","AccountName","Name","PermissionName","IdentityV2","Struct","field","PermissionLevel","optional","IdentityV3","RequestVariantV2","Action","array","Transaction","RequestVariantV3","RequestFlags","broadcast","RequestFlags_1","enabled","setFlag","background","flag","InfoPair","RequestDataV2","RequestDataV3","RequestSignature","ProtocolVersion","PlaceholderName","PlaceholderPermission","PlaceholderAuth","actor","permission","SigningRequest","constructor","version","data","zlib","abiProvider","signature","flags","req","variantName","abi","Serializer","synthesize","identityType","actions","ricardian_contract","args","options","action","transaction","requiredAbis","filter","Bytes","isBytes","undefined","abiName","map","account","abis","provider","accountAbis","Promise","all","getAbi","idx","entries","toString","createSync","encode","String","encodeAction","identity","scope","TypeError","tx","expiration","ref_block_num","ref_block_prefix","context_free_actions","transaction_extensions","delay_sec","max_cpu_usage_ms","max_net_usage_words","chain_id","callback","url","info","prototype","hasOwnProperty","call","object","push","chainIds","ids","storageType","signatureProvider","sign","serializedTransaction","encoder","ABIEncoder","writeByte","writeArray","fromData","getData","uri","scheme","path","split","input","a","b","p","base64u","startsWith","slice","header","payload","droppingFirst","inflateRaw","decoder","ABIDecoder","decode","sig","canRead","message","getSignatureDigest","prefix","appending","sha256Digest","setSignature","signer","setCallback","setBroadcast","compress","slashes","shouldCompress","sigData","getSignatureData","byteLength","set","deflated","deflateRaw","out","byteRemainder","mainLength","parts","chunk","join","getRequiredAbis","getRawActions","isIdentity","index","self","indexOf","requiresTapos","getRawTransaction","hasTapos","required","async","ABI","resolveActions","rawAction","identityAbi","rawAbi","getActionType","decodeData","authorization","signerPerm","resolve","equals","Array","isArray","keys","auth","resolveTransaction","ctx","TimePointSec","expirationTime","timestamp","expire_seconds","UInt16","UInt32","block_num","isMultiChain","getChainIds","some","getChainId","ResolvedSigningRequest","getInfoKey","setChainIds","setInfoKey","variantIdx","shouldBroadcast","getIdentity","getIdentityPermission","getIdentityScope","getRawInfo","rv","getRawInfoKey","pair","find","setRawInfoKey","clone","JSON","parse","stringify","toJSON","request","resolvedTransaction","fetchAbis","sa","sp","rbn","rid","ex","signingDigest","getCallback","signatures","blockNum","sigs","Signature","bn","replace","_1","_2","m","rawValue","expireSeconds","ts","Date","exp","fromMilliseconds","toMilliseconds"],"mappings":"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"}