{"version":3,"file":"index.umd.js","sources":["../src/base64u.ts","../src/abi.ts","../src/signing-request.ts"],"sourcesContent":["/**\n * Base64u - URL-Safe Base64 variant no padding.\n * Based on https://gist.github.com/jonleighton/958841\n */\n\nconst charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'\nconst lookup = new Uint8Array(256)\nfor (let i = 0; i < 64; i++) {\n    lookup[charset.charCodeAt(i)] = i\n}\n\nexport function encode(data: Uint8Array): string {\n    const byteLength = data.byteLength\n    const byteRemainder = byteLength % 3\n    const mainLength = byteLength - byteRemainder\n\n    const parts: string[] = []\n\n    let a: number\n    let b: number\n    let c: number\n    let d: number\n    let chunk: number\n\n    // Main loop deals with bytes in chunks of 3\n    for (let i = 0; i < mainLength; i += 3) {\n        // Combine the three bytes into a single integer\n        chunk = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2]\n\n        // Use bitmasks to extract 6-bit segments from the triplet\n        a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18\n        b = (chunk & 258048) >> 12 // 258048   = (2^6 - 1) << 12\n        c = (chunk & 4032) >> 6 // 4032     = (2^6 - 1) << 6\n        d = chunk & 63 // 63       =  2^6 - 1\n\n        // Convert the raw binary segments to the appropriate ASCII encoding\n        parts.push(charset[a] + charset[b] + charset[c] + charset[d])\n    }\n\n    // Deal with the remaining bytes\n    if (byteRemainder === 1) {\n        chunk = data[mainLength]\n\n        a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2\n\n        // Set the 4 least significant bits to zero\n        b = (chunk & 3) << 4 // 3   = 2^2 - 1\n\n        parts.push(charset[a] + charset[b])\n    } else if (byteRemainder === 2) {\n        chunk = (data[mainLength] << 8) | data[mainLength + 1]\n\n        a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10\n        b = (chunk & 1008) >> 4 // 1008  = (2^6 - 1) << 4\n\n        // Set the 2 least significant bits to zero\n        c = (chunk & 15) << 2 // 15    = 2^4 - 1\n\n        parts.push(charset[a] + charset[b] + charset[c])\n    }\n\n    return parts.join('')\n}\n\nexport function decode(input: string): Uint8Array {\n    const byteLength = input.length * 0.75\n    const data = new Uint8Array(byteLength)\n\n    let a: number\n    let b: number\n    let c: number\n    let d: number\n    let p: number = 0\n\n    for (let i = 0; i < input.length; i += 4) {\n        a = lookup[input.charCodeAt(i)]\n        b = lookup[input.charCodeAt(i + 1)]\n        c = lookup[input.charCodeAt(i + 2)]\n        d = lookup[input.charCodeAt(i + 3)]\n\n        data[p++] = (a << 2) | (b >> 4)\n        data[p++] = ((b & 15) << 4) | (c >> 2)\n        data[p++] = ((c & 3) << 6) | (d & 63)\n    }\n\n    return data\n}\n","/** SigningRequest ABI and typedefs. */\n\nexport type AccountName = string /*name*/\nexport type ActionName = string /*name*/\nexport type PermissionName = string /*name*/\nexport type ChainAlias = number /*uint8*/\nexport type ChainId = string /*checksum256*/\nexport type VariantId = ['chain_alias', ChainAlias] | ['chain_id', ChainId]\nexport type VariantReq =\n    | ['action', Action]\n    | ['action[]', Action[]]\n    | ['transaction', Transaction]\n    | ['identity', Identity]\n\nexport interface PermissionLevel {\n    actor: AccountName\n    permission: PermissionName\n}\n\nexport type RequestFlags = number\nexport const RequestFlagsNone = 0\nexport const RequestFlagsBroadcast = 1 << 0\nexport const RequestFlagsBackground = 1 << 1\n\nexport interface Action {\n    account: AccountName\n    name: ActionName\n    authorization: PermissionLevel[]\n    data: string | {[key: string]: any}\n}\n\nexport interface Extension {\n    type: number /*uint16*/\n    data: string /*bytes*/\n}\n\nexport interface TransactionHeader {\n    expiration: string /*time_point_sec*/\n    ref_block_num: number /*uint16*/\n    ref_block_prefix: number /*uint32*/\n    max_net_usage_words: number /*varuint32*/\n    max_cpu_usage_ms: number /*uint8*/\n    delay_sec: number /*varuint32*/\n}\n\nexport interface Transaction extends TransactionHeader {\n    context_free_actions: Action[]\n    actions: Action[]\n    transaction_extensions: Extension[]\n}\n\nexport interface SigningRequest {\n    chain_id: VariantId\n    req: VariantReq\n    flags: RequestFlags\n    callback: string\n    info: InfoPair[]\n}\n\nexport interface InfoPair {\n    key: string\n    value: Uint8Array | string /*bytes*/\n}\n\nexport interface Identity {\n    permission: PermissionLevel | undefined | null\n}\n\nexport interface RequestSignature {\n    signer: AccountName\n    signature: string\n}\n\nexport const data = {\n    version: 'eosio::abi/1.1',\n    types: [\n        {\n            new_type_name: 'account_name',\n            type: 'name',\n        },\n        {\n            new_type_name: 'action_name',\n            type: 'name',\n        },\n        {\n            new_type_name: 'permission_name',\n            type: 'name',\n        },\n        {\n            new_type_name: 'chain_alias',\n            type: 'uint8',\n        },\n        {\n            new_type_name: 'chain_id',\n            type: 'checksum256',\n        },\n        {\n            new_type_name: 'request_flags',\n            type: 'uint8',\n        },\n    ],\n    structs: [\n        {\n            name: 'permission_level',\n            fields: [\n                {\n                    name: 'actor',\n                    type: 'account_name',\n                },\n                {\n                    name: 'permission',\n                    type: 'permission_name',\n                },\n            ],\n        },\n        {\n            name: 'action',\n            fields: [\n                {\n                    name: 'account',\n                    type: 'account_name',\n                },\n                {\n                    name: 'name',\n                    type: 'action_name',\n                },\n                {\n                    name: 'authorization',\n                    type: 'permission_level[]',\n                },\n                {\n                    name: 'data',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'extension',\n            fields: [\n                {\n                    name: 'type',\n                    type: 'uint16',\n                },\n                {\n                    name: 'data',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'transaction_header',\n            fields: [\n                {\n                    name: 'expiration',\n                    type: 'time_point_sec',\n                },\n                {\n                    name: 'ref_block_num',\n                    type: 'uint16',\n                },\n                {\n                    name: 'ref_block_prefix',\n                    type: 'uint32',\n                },\n                {\n                    name: 'max_net_usage_words',\n                    type: 'varuint32',\n                },\n                {\n                    name: 'max_cpu_usage_ms',\n                    type: 'uint8',\n                },\n                {\n                    name: 'delay_sec',\n                    type: 'varuint32',\n                },\n            ],\n        },\n        {\n            name: 'transaction',\n            base: 'transaction_header',\n            fields: [\n                {\n                    name: 'context_free_actions',\n                    type: 'action[]',\n                },\n                {\n                    name: 'actions',\n                    type: 'action[]',\n                },\n                {\n                    name: 'transaction_extensions',\n                    type: 'extension[]',\n                },\n            ],\n        },\n        {\n            name: 'info_pair',\n            fields: [\n                {\n                    name: 'key',\n                    type: 'string',\n                },\n                {\n                    name: 'value',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'signing_request',\n            fields: [\n                {\n                    name: 'chain_id',\n                    type: 'variant_id',\n                },\n                {\n                    name: 'req',\n                    type: 'variant_req',\n                },\n                {\n                    name: 'flags',\n                    type: 'request_flags',\n                },\n                {\n                    name: 'callback',\n                    type: 'string',\n                },\n                {\n                    name: 'info',\n                    type: 'info_pair[]',\n                },\n            ],\n        },\n        {\n            name: 'identity',\n            fields: [\n                {\n                    name: 'permission',\n                    type: 'permission_level?',\n                },\n            ],\n        },\n        {\n            name: 'request_signature',\n            fields: [\n                {\n                    name: 'signer',\n                    type: 'name',\n                },\n                {\n                    name: 'signature',\n                    type: 'signature',\n                },\n            ],\n        },\n    ],\n    variants: [\n        {\n            name: 'variant_id',\n            types: ['chain_alias', 'chain_id'],\n        },\n        {\n            name: 'variant_req',\n            types: ['action', 'action[]', 'transaction', 'identity'],\n        },\n    ],\n    actions: [\n        {\n            name: 'identity',\n            type: 'identity',\n        },\n    ],\n}\n","/**\n * EOSIO Signing Request (ESR).\n */\n\nimport {Serialize} from 'eosjs'\nimport sha256 from 'fast-sha256'\n\nimport * as abi from './abi'\nimport * as base64u from './base64u'\n\nconst ProtocolVersion = 2\n\nconst AbiTypes = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), abi.data as any)\n\n/** Interface that should be implemented by abi providers. */\nexport interface AbiProvider {\n    /**\n     * Return a promise that resolves to an abi object for the given account name,\n     * e.g. the result of a rpc call to chain/get_abi.\n     */\n    getAbi: (account: string) => Promise<any>\n}\n\n/** Interface that should be implemented by zlib implementations. */\nexport interface ZlibProvider {\n    /** Deflate data w/o adding zlib header. */\n    deflateRaw: (data: Uint8Array) => Uint8Array\n    /** Inflate data w/o requiring zlib header. */\n    inflateRaw: (data: Uint8Array) => Uint8Array\n}\n\n/** Interface that should be implemented by signature providers. */\nexport interface SignatureProvider {\n    /** Sign 32-byte hex-encoded message and return signer name and signature string. */\n    sign: (message: string) => {signer: string; signature: string}\n}\n\n/**\n * The callback payload sent to background callbacks.\n */\nexport interface CallbackPayload {\n    /** The first signature. */\n    sig: string\n    /** Transaction ID as HEX-encoded string. */\n    tx: string\n    /** Block number hint (only present if transaction was broadcast). */\n    bn?: string\n    /** Signer authority, aka account name. */\n    sa: string\n    /** Signer permission, e.g. \"active\". */\n    sp: string\n    /** Reference block num used when resolving request. */\n    rbn: string\n    /** Reference block id used when resolving request. */\n    rid: string\n    /** The originating signing request packed as a uri string. */\n    req: string\n    /** Expiration time used when resolving request. */\n    ex: string\n    /** All signatures 0-indexed as `sig0`, `sig1`, etc. */\n    [sig0: string]: string | undefined\n}\n\n/**\n * Context used to resolve a callback.\n * Compatible with the JSON response from a `push_transaction` call.\n */\nexport interface ResolvedCallback {\n    /** The URL to hit. */\n    url: string\n    /**\n     * Whether to run the request in the background. For a https url this\n     * means POST in the background instead of a GET redirect.\n     */\n    background: boolean\n    /**\n     * The callback payload as a object that should be encoded to JSON\n     * and POSTed to background callbacks.\n     */\n    payload: CallbackPayload\n}\n\n/**\n * Context used to resolve a transaction.\n * Compatible with the JSON response from a `get_block` call.\n */\nexport interface TransactionContext {\n    /** Timestamp expiration will be derived from. */\n    timestamp?: string\n    /**\n     * How many seconds in the future to set expiration when deriving from timestamp.\n     * Defaults to 60 seconds if unset.\n     */\n    expire_seconds?: number\n    /** Block number ref_block_num will be derived from. */\n    block_num?: number\n    /** Reference block number, takes precedence over block_num if both is set. */\n    ref_block_num?: number\n    /** Reference block prefix. */\n    ref_block_prefix?: number\n    /** Expiration timestamp, takes precedence over timestamp and expire_seconds if set. */\n    expiration?: string\n}\n\n/** Chain ID aliases. */\nexport enum ChainName {\n    UNKNOWN = 0, // reserved\n    EOS = 1,\n    TELOS = 2,\n    JUNGLE = 3,\n    KYLIN = 4,\n    WORBLI = 5,\n    BOS = 6,\n    MEETONE = 7,\n    INSIGHTS = 8,\n    BEOS = 9,\n    WAX = 10,\n    PROTON = 11,\n    FIO = 12,\n}\n\nconst ChainIdLookup = new Map<abi.ChainAlias, abi.ChainId>([\n    [ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'],\n    [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'],\n    [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'],\n    [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'],\n    [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'],\n    [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'],\n    [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'],\n    [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'],\n    [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'],\n    [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'],\n    [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'],\n    [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c'],\n])\n\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\nexport const PlaceholderName = '............1' // aka uint64(1)\n\n/** Placeholder that will resolve to signer permission name. */\nexport const PlaceholderPermission = '............2' // aka uint64(2)\n\nexport const PlaceholderAuth: abi.PermissionLevel = {\n    actor: PlaceholderName,\n    permission: PlaceholderPermission,\n}\n\nexport type CallbackType = string | {url: string; background: boolean}\n\nexport interface SigningRequestCreateArguments {\n    /** Single action to create request with. */\n    action?: abi.Action\n    /** Multiple actions to create request with. */\n    actions?: abi.Action[]\n    /**\n     * Full or partial transaction to create request with.\n     * If TAPoS info is omitted it will be filled in when resolving the request.\n     */\n    transaction?: {actions: abi.Action[]; [key: string]: any}\n    /** Create an identity request. */\n    identity?: abi.Identity\n    /** Chain to use, defaults to EOS main-net if omitted. */\n    chainId?: string | number\n    /** Whether wallet should broadcast tx, defaults to true. */\n    broadcast?: boolean\n    /**\n     * Optional callback URL the signer should hit after\n     * broadcasting or signing. Passing a string means background = false.\n     */\n    callback?: CallbackType\n    /** Optional metadata to pass along with the request. */\n    info?: {[key: string]: string | Uint8Array}\n}\n\nexport interface SigningRequestCreateIdentityArguments {\n    /**\n     * Callback where the identity should be delivered.\n     */\n    callback: CallbackType\n    /** Chain to use, defaults to EOS if omitted. */\n    chainId?: string | number\n    /**\n     * Requested account name of identity.\n     * Defaults to placeholder (any identity) if omitted.\n     */\n    account?: string\n    /**\n     * Requested account permission.\n     * Defaults to placeholder (any permission) if omitted.\n     */\n    permission?: string\n    /** Optional metadata to pass along with the request. */\n    info?: {[key: string]: string | Uint8Array}\n}\n\nexport interface SigningRequestEncodingOptions {\n    /** UTF-8 text encoder, required when using node.js. */\n    textEncoder?: any\n    /** UTF-8 text decoder, required when using node.js. */\n    textDecoder?: any\n    /** Optional zlib, if provided the request will be compressed when encoding. */\n    zlib?: ZlibProvider\n    /** Abi provider, required if the arguments contain un-encoded actions. */\n    abiProvider?: AbiProvider\n    /** Optional signature provider, will be used to create a request signature if provided. */\n    signatureProvider?: SignatureProvider\n}\n\nexport type AbiMap = Map<string, any>\n\nexport class SigningRequest {\n    public static type = AbiTypes.get('signing_request')!\n    public static idType = AbiTypes.get('identity')!\n    public static transactionType = AbiTypes.get('transaction')!\n\n    /** Create a new signing request. */\n    public static async create(\n        args: SigningRequestCreateArguments,\n        options: SigningRequestEncodingOptions = {}\n    ) {\n        const textEncoder = options.textEncoder || new TextEncoder()\n        const textDecoder = options.textDecoder || new TextDecoder()\n        const data: any = {}\n\n        const serialize = (action: abi.Action) => {\n            return serializeAction(action, textEncoder, textDecoder, options.abiProvider)\n        }\n\n        // set the request data\n        if (args.identity !== undefined) {\n            data.req = ['identity', args.identity]\n        } else if (args.action && !args.actions && !args.transaction) {\n            data.req = ['action', await serialize(args.action)]\n        } else if (args.actions && !args.action && !args.transaction) {\n            if (args.actions.length === 1) {\n                data.req = ['action', await serialize(args.actions[0])]\n            } else {\n                data.req = ['action[]', await Promise.all(args.actions.map(serialize))]\n            }\n        } else if (args.transaction && !args.action && !args.actions) {\n            const tx = args.transaction\n            // set default values if missing\n            if (tx.expiration === undefined) {\n                tx.expiration = '1970-01-01T00:00:00.000'\n            }\n            if (tx.ref_block_num === undefined) {\n                tx.ref_block_num = 0\n            }\n            if (tx.ref_block_prefix === undefined) {\n                tx.ref_block_prefix = 0\n            }\n            if (tx.context_free_actions === undefined) {\n                tx.context_free_actions = []\n            }\n            if (tx.transaction_extensions === undefined) {\n                tx.transaction_extensions = []\n            }\n            if (tx.delay_sec === undefined) {\n                tx.delay_sec = 0\n            }\n            if (tx.max_cpu_usage_ms === undefined) {\n                tx.max_cpu_usage_ms = 0\n            }\n            if (tx.max_net_usage_words === undefined) {\n                tx.max_net_usage_words = 0\n            }\n            // encode actions if needed\n            tx.actions = await Promise.all(tx.actions.map(serialize))\n            data.req = ['transaction', tx]\n        } else {\n            throw new TypeError(\n                'Invalid arguments: Must have exactly one of action, actions or transaction'\n            )\n        }\n\n        // set the chain id\n        data.chain_id = variantId(args.chainId)\n        data.flags = abi.RequestFlagsNone\n\n        const broadcast = args.broadcast !== undefined ? args.broadcast : true\n        if (broadcast) {\n            data.flags |= abi.RequestFlagsBroadcast\n        }\n        if (typeof args.callback === 'string') {\n            data.callback = args.callback\n        } else if (typeof args.callback === 'object') {\n            data.callback = args.callback.url\n            if (args.callback.background) {\n                data.flags |= abi.RequestFlagsBackground\n            }\n        } else {\n            data.callback = ''\n        }\n\n        data.info = []\n        if (typeof args.info === 'object') {\n            for (const key in args.info) {\n                if (args.info.hasOwnProperty(key)) {\n                    let value = args.info[key]\n                    if (typeof key !== 'string') {\n                        throw new Error('Invalid info dict, keys must be strings')\n                    }\n                    if (typeof value === 'string') {\n                        value = textEncoder.encode(value)\n                    }\n                    data.info.push({key, value})\n                }\n            }\n        }\n\n        const req = new SigningRequest(\n            ProtocolVersion,\n            data,\n            textEncoder,\n            textDecoder,\n            options.zlib,\n            options.abiProvider\n        )\n\n        // sign the request if given a signature provider\n        if (options.signatureProvider) {\n            req.sign(options.signatureProvider)\n        }\n\n        return req\n    }\n\n    /** Creates an identity request. */\n    public static identity(\n        args: SigningRequestCreateIdentityArguments,\n        options: SigningRequestEncodingOptions = {}\n    ) {\n        let permission: abi.PermissionLevel | null = {\n            actor: args.account || PlaceholderName,\n            permission: args.permission || PlaceholderPermission,\n        }\n        if (\n            permission.actor === PlaceholderName &&\n            permission.permission === PlaceholderPermission\n        ) {\n            permission = null\n        }\n        return this.create(\n            {\n                identity: {\n                    permission,\n                },\n                broadcast: false,\n                callback: args.callback,\n                info: args.info,\n            },\n            options\n        )\n    }\n\n    /**\n     * Create a request from a chain id and serialized transaction.\n     * @param chainId The chain id where the transaction is valid.\n     * @param serializedTransaction The serialized transaction.\n     * @param options Creation options.\n     */\n    public static fromTransaction(\n        chainId: Uint8Array | string,\n        serializedTransaction: Uint8Array | string,\n        options: SigningRequestEncodingOptions = {}\n    ) {\n        if (typeof chainId !== 'string') {\n            chainId = Serialize.arrayToHex(chainId)\n        }\n        if (typeof serializedTransaction === 'string') {\n            serializedTransaction = Serialize.hexToUint8Array(serializedTransaction)\n        }\n        let buf = new Serialize.SerialBuffer({\n            textDecoder: options.textDecoder,\n            textEncoder: options.textEncoder,\n        })\n        buf.push(2) // header\n        const id = variantId(chainId)\n        if (id[0] === 'chain_alias') {\n            buf.push(0)\n            buf.push(id[1])\n        } else {\n            buf.push(1)\n            buf.pushArray(Serialize.hexToUint8Array(id[1]))\n        }\n        buf.push(2) // transaction variant\n        buf.pushArray(serializedTransaction)\n        buf.push(abi.RequestFlagsBroadcast) // flags\n        buf.push(0) // callback\n        buf.push(0) // info\n        return SigningRequest.fromData(buf.asUint8Array(), options)\n    }\n\n    /** Creates a signing request from encoded `esr:` uri string. */\n    public static from(uri: string, options: SigningRequestEncodingOptions = {}) {\n        if (typeof uri !== 'string') {\n            throw new Error('Invalid request uri')\n        }\n        const [scheme, path] = uri.split(':')\n        if (scheme !== 'esr' && scheme !== 'web+esr') {\n            throw new Error('Invalid scheme')\n        }\n        const data = base64u.decode(path.startsWith('//') ? path.slice(2) : path)\n        return SigningRequest.fromData(data, options)\n    }\n\n    public static fromData(data: Uint8Array, options: SigningRequestEncodingOptions = {}) {\n        const header = data[0]\n        const version = header & ~(1 << 7)\n        if (version !== ProtocolVersion) {\n            throw new Error('Unsupported protocol version')\n        }\n        let array = data.slice(1)\n        if ((header & (1 << 7)) !== 0) {\n            if (!options.zlib) {\n                throw new Error('Compressed URI needs zlib')\n            }\n            array = options.zlib.inflateRaw(array)\n        }\n        const textEncoder = options.textEncoder || new TextEncoder()\n        const textDecoder = options.textDecoder || new TextDecoder()\n        const buffer = new Serialize.SerialBuffer({\n            textEncoder,\n            textDecoder,\n            array,\n        })\n        const req = SigningRequest.type.deserialize(buffer)\n        let signature: abi.RequestSignature | undefined\n        if (buffer.haveReadData()) {\n            const type = AbiTypes.get('request_signature')!\n            signature = type.deserialize(buffer)\n        }\n        return new SigningRequest(\n            version,\n            req,\n            textEncoder,\n            textDecoder,\n            options.zlib,\n            options.abiProvider,\n            signature\n        )\n    }\n\n    /** The signing request version. */\n    public version: number\n\n    /** The raw signing request data. */\n    public data: abi.SigningRequest\n\n    /** The request signature. */\n    public signature?: abi.RequestSignature\n\n    private textEncoder: TextEncoder\n    private textDecoder: TextDecoder\n    private zlib?: ZlibProvider\n    private abiProvider?: AbiProvider\n\n    /**\n     * Create a new signing request.\n     * Normally not used directly, see the `create` and `from` class methods.\n     */\n    constructor(\n        version: number,\n        data: abi.SigningRequest,\n        textEncoder: TextEncoder,\n        textDecoder: TextDecoder,\n        zlib?: ZlibProvider,\n        abiProvider?: AbiProvider,\n        signature?: abi.RequestSignature\n    ) {\n        if ((data.flags & abi.RequestFlagsBroadcast) !== 0 && data.req[0] === 'identity') {\n            throw new Error('Invalid request (identity request cannot be broadcast)')\n        }\n        if ((data.flags & abi.RequestFlagsBroadcast) === 0 && data.callback.length === 0) {\n            throw new Error('Invalid request (nothing to do, no broadcast or callback set)')\n        }\n        this.version = version\n        this.data = data\n        this.textEncoder = textEncoder\n        this.textDecoder = textDecoder\n        this.zlib = zlib\n        this.abiProvider = abiProvider\n        this.signature = signature\n    }\n\n    /**\n     * Sign the request, mutating.\n     * @param signatureProvider The signature provider that provides a signature for the signer.\n     */\n    public sign(signatureProvider: SignatureProvider) {\n        const message = this.getSignatureDigest()\n        this.signature = signatureProvider.sign(Serialize.arrayToHex(message))\n    }\n\n    /**\n     * Get the signature digest for this request.\n     */\n    public getSignatureDigest() {\n        const buffer = new Serialize.SerialBuffer({\n            textEncoder: this.textEncoder,\n            textDecoder: this.textDecoder,\n        })\n        // protocol version + utf8 \"request\"\n        buffer.pushArray([this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74])\n        buffer.pushArray(this.getData())\n        return sha256(buffer.asUint8Array())\n    }\n\n    /**\n     * Set the signature data for this request, mutating.\n     * @param signer Account name of signer.\n     * @param signature The signature string.\n     */\n    public setSignature(signer: string, signature: string) {\n        this.signature = {signer, signature}\n    }\n\n    /**\n     * Set the request callback, mutating.\n     * @param url Where the callback should be sent.\n     * @param background Whether the callback should be sent in the background.\n     */\n    public setCallback(url: string, background: boolean) {\n        this.data.callback = url\n        if (background) {\n            this.data.flags |= abi.RequestFlagsBackground\n        } else {\n            this.data.flags &= ~abi.RequestFlagsBackground\n        }\n    }\n\n    /**\n     * Set broadcast flag.\n     * @param broadcast Whether the transaction should be broadcast by receiver.\n     */\n    public setBroadcast(broadcast: boolean) {\n        if (broadcast) {\n            this.data.flags |= abi.RequestFlagsBroadcast\n        } else {\n            this.data.flags &= ~abi.RequestFlagsBroadcast\n        }\n    }\n\n    /**\n     * Encode this request into an `esr:` uri.\n     * @argument compress Whether to compress the request data using zlib,\n     *                    defaults to true if omitted and zlib is present;\n     *                    otherwise false.\n     * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n     *                   Defaults to true.\n     * @returns An esr uri string.\n     */\n    public encode(compress?: boolean, slashes?: boolean): string {\n        const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined\n        if (shouldCompress && this.zlib === undefined) {\n            throw new Error('Need zlib to compress')\n        }\n        let header = this.version\n        const data = this.getData()\n        const sigData = this.getSignatureData()\n        let array = new Uint8Array(data.byteLength + sigData.byteLength)\n        array.set(data, 0)\n        array.set(sigData, data.byteLength)\n        if (shouldCompress) {\n            const deflated = this.zlib!.deflateRaw(array)\n            if (array.byteLength > deflated.byteLength) {\n                header |= 1 << 7\n                array = deflated\n            }\n        }\n        const out = new Uint8Array(1 + array.byteLength)\n        out[0] = header\n        out.set(array, 1)\n        let scheme = 'esr:'\n        if (slashes !== false) {\n            scheme += '//'\n        }\n        return scheme + base64u.encode(out)\n    }\n\n    /** Get the request data without header or signature. */\n    public getData(): Uint8Array {\n        const buffer = new Serialize.SerialBuffer({\n            textEncoder: this.textEncoder,\n            textDecoder: this.textDecoder,\n        })\n        SigningRequest.type.serialize(buffer, this.data)\n        return buffer.asUint8Array()\n    }\n\n    /** Get signature data, returns an empty array if request is not signed. */\n    public getSignatureData(): Uint8Array {\n        if (!this.signature) {\n            return new Uint8Array(0)\n        }\n        const buffer = new Serialize.SerialBuffer({\n            textEncoder: this.textEncoder,\n            textDecoder: this.textDecoder,\n        })\n        const type = AbiTypes.get('request_signature')!\n        type.serialize(buffer, this.signature)\n        return buffer.asUint8Array()\n    }\n\n    /** ABI definitions required to resolve request. */\n    public getRequiredAbis() {\n        return this.getRawActions()\n            .filter((action) => !isIdentity(action))\n            .map((action) => action.account)\n            .filter((value, index, self) => self.indexOf(value) === index)\n    }\n\n    /** Whether TaPoS values are required to resolve request. */\n    public requiresTapos() {\n        let tx = this.getRawTransaction()\n        return !this.isIdentity() && !hasTapos(tx)\n    }\n\n    /** Resolve required ABI definitions. */\n    public async fetchAbis(abiProvider?: AbiProvider): Promise<AbiMap> {\n        const provider = abiProvider || this.abiProvider\n        if (!provider) {\n            throw new Error('Missing ABI provider')\n        }\n        const abis = new Map<string, any>()\n        await Promise.all(\n            this.getRequiredAbis().map(async (account) => {\n                abis.set(account, await provider.getAbi(account))\n            })\n        )\n        return abis\n    }\n\n    /**\n     * Decode raw actions actions to object representations.\n     * @param abis ABI defenitions required to decode all actions.\n     * @param signer Placeholders in actions will be resolved to signer if set.\n     */\n    public resolveActions(abis: AbiMap, signer?: abi.PermissionLevel): abi.Action[] {\n        return this.getRawActions().map((rawAction) => {\n            let contractAbi: any | undefined\n            if (isIdentity(rawAction)) {\n                contractAbi = abi.data\n            } else {\n                contractAbi = abis.get(rawAction.account)\n            }\n            if (!contractAbi) {\n                throw new Error(`Missing ABI definition for ${rawAction.account}`)\n            }\n            const contract = getContract(contractAbi)\n            if (signer) {\n                // hook into eosjs name decoder and return the signing account if we encounter the placeholder\n                // this is fine because getContract re-creates the initial types each time\n                contract.types.get('name')!.deserialize = (buffer: Serialize.SerialBuffer) => {\n                    const name = buffer.getName()\n                    if (name === PlaceholderName) {\n                        return signer.actor\n                    } else if (name === PlaceholderPermission) {\n                        return signer.permission\n                    } else {\n                        return name\n                    }\n                }\n            }\n            const action = Serialize.deserializeAction(\n                contract,\n                rawAction.account,\n                rawAction.name,\n                rawAction.authorization,\n                rawAction.data as any,\n                this.textEncoder,\n                this.textDecoder\n            )\n            if (signer) {\n                action.authorization = action.authorization.map((auth) => {\n                    let {actor, permission} = auth\n                    if (actor === PlaceholderName) {\n                        actor = signer.actor\n                    }\n                    if (permission === PlaceholderPermission) {\n                        permission = signer.permission\n                    }\n                    // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n                    if (permission === PlaceholderName) {\n                        permission = signer.permission\n                    }\n                    return {actor, permission}\n                })\n            }\n            return action\n        })\n    }\n\n    public resolveTransaction(\n        abis: AbiMap,\n        signer: abi.PermissionLevel,\n        ctx: TransactionContext = {}\n    ): abi.Transaction {\n        let tx = this.getRawTransaction()\n        if (!this.isIdentity() && !hasTapos(tx)) {\n            if (\n                ctx.expiration !== undefined &&\n                ctx.ref_block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined\n            ) {\n                tx.expiration = ctx.expiration\n                tx.ref_block_num = ctx.ref_block_num\n                tx.ref_block_prefix = ctx.ref_block_prefix\n            } else if (\n                ctx.block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined &&\n                ctx.timestamp !== undefined\n            ) {\n                const header = Serialize.transactionHeader(\n                    ctx as any,\n                    ctx.expire_seconds !== undefined ? ctx.expire_seconds : 60\n                )\n                tx.expiration = header.expiration\n                tx.ref_block_num = header.ref_block_num\n                tx.ref_block_prefix = header.ref_block_prefix\n            } else {\n                throw new Error(\n                    'Invalid transaction context, need either a reference block or explicit TAPoS values'\n                )\n            }\n        }\n        const actions = this.resolveActions(abis, signer)\n        return {...tx, actions}\n    }\n\n    public resolve(abis: AbiMap, signer: abi.PermissionLevel, ctx: TransactionContext = {}) {\n        const transaction = this.resolveTransaction(abis, signer, ctx)\n        const buf = new Serialize.SerialBuffer({\n            textDecoder: this.textDecoder,\n            textEncoder: this.textEncoder,\n        })\n        const actions = transaction.actions.map((action) => {\n            let contractAbi: any\n            if (isIdentity(action)) {\n                contractAbi = abi.data\n            } else {\n                contractAbi = abis.get(action.account)\n            }\n            if (!contractAbi) {\n                throw new Error(`Missing ABI definition for ${action.account}`)\n            }\n            const contract = getContract(contractAbi)\n            const {textDecoder, textEncoder} = this\n            return Serialize.serializeAction(\n                contract,\n                action.account,\n                action.name,\n                action.authorization,\n                action.data,\n                textEncoder,\n                textDecoder\n            )\n        })\n        SigningRequest.transactionType.serialize(buf, {\n            ...transaction,\n            actions,\n        })\n        const serializedTransaction = buf.asUint8Array()\n        return new ResolvedSigningRequest(this, signer, transaction, serializedTransaction)\n    }\n\n    /**\n     * Get the id of the chain where this request is valid.\n     * @returns The 32-byte chain id as hex encoded string.\n     */\n    public getChainId(): abi.ChainId {\n        const id = this.data.chain_id\n        switch (id[0]) {\n            case 'chain_id':\n                return id[1]\n            case 'chain_alias':\n                if (ChainIdLookup.has(id[1])) {\n                    return ChainIdLookup.get(id[1])!\n                } else {\n                    throw new Error('Unknown chain id alias')\n                }\n            default:\n                throw new Error('Invalid signing request data')\n        }\n    }\n\n    /** Return the actions in this request with action data encoded. */\n    public getRawActions() {\n        const req = this.data.req\n        switch (req[0]) {\n            case 'action':\n                return [req[1]]\n            case 'action[]':\n                return req[1]\n            case 'identity':\n                let data: string = '0101000000000000000200000000000000' // placeholder permission\n                let authorization: abi.PermissionLevel[] = [PlaceholderAuth]\n                if (req[1].permission) {\n                    let buf = new Serialize.SerialBuffer({\n                        textDecoder: this.textDecoder,\n                        textEncoder: this.textEncoder,\n                    })\n                    SigningRequest.idType.serialize(buf, req[1])\n                    data = Serialize.arrayToHex(buf.asUint8Array())\n                    authorization = [req[1].permission]\n                }\n                return [\n                    {\n                        account: '',\n                        name: 'identity',\n                        authorization,\n                        data,\n                    },\n                ]\n            case 'transaction':\n                return req[1].actions\n            default:\n                throw new Error('Invalid signing request data')\n        }\n    }\n\n    /** Unresolved transaction. */\n    public getRawTransaction(): abi.Transaction {\n        const req = this.data.req\n        switch (req[0]) {\n            case 'transaction':\n                return req[1]\n            case 'action':\n            case 'action[]':\n            case 'identity':\n                return {\n                    actions: this.getRawActions(),\n                    context_free_actions: [],\n                    transaction_extensions: [],\n                    expiration: '1970-01-01T00:00:00.000',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_cpu_usage_ms: 0,\n                    max_net_usage_words: 0,\n                    delay_sec: 0,\n                }\n            default:\n                throw new Error('Invalid signing request data')\n        }\n    }\n\n    /** Whether the request is an identity request. */\n    public isIdentity(): boolean {\n        return this.data.req[0] === 'identity'\n    }\n\n    /** Whether the request should be broadcast by signer. */\n    public shouldBroadcast(): boolean {\n        if (this.isIdentity()) {\n            return false\n        }\n        return (this.data.flags & abi.RequestFlagsBroadcast) !== 0\n    }\n\n    /**\n     * Present if the request is an identity request and requests a specific account.\n     * @note This returns `nil` unless a specific identity has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    public getIdentity(): string | null {\n        if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n            const {actor} = this.data.req[1].permission\n            return actor === PlaceholderName ? null : actor\n        }\n        return null\n    }\n\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    public getIdentityPermission(): string | null {\n        if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n            const {permission} = this.data.req[1].permission\n            return permission === PlaceholderName ? null : permission\n        }\n        return null\n    }\n\n    /** Get raw info dict */\n    public getRawInfo(): {[key: string]: Uint8Array} {\n        let rv: {[key: string]: Uint8Array} = {}\n        for (const {key, value} of this.data.info) {\n            rv[key] = typeof value === 'string' ? Serialize.hexToUint8Array(value) : value\n        }\n        return rv\n    }\n\n    /** Get metadata values as strings. */\n    public getInfo(): {[key: string]: string} {\n        let rv: {[key: string]: string} = {}\n        let raw = this.getRawInfo()\n        for (const key of Object.keys(raw)) {\n            rv[key] = this.textDecoder.decode(raw[key])\n        }\n        return rv\n    }\n\n    /** Set a metadata key. */\n    public setInfoKey(key: string, value: string | boolean) {\n        let pair = this.data.info.find((pair) => {\n            return pair.key === key\n        })\n        let encodedValue: Uint8Array\n        switch (typeof value) {\n            case 'string':\n                encodedValue = this.textEncoder.encode(value)\n                break\n            case 'boolean':\n                encodedValue = new Uint8Array([value ? 1 : 0])\n                break\n            default:\n                throw new TypeError('Invalid value type, expected string or boolean.')\n        }\n        if (!pair) {\n            pair = {key, value: encodedValue}\n            this.data.info.push(pair)\n        } else {\n            pair.value = encodedValue\n        }\n    }\n\n    /** Return a deep copy of this request. */\n    public clone(): SigningRequest {\n        let signature: abi.RequestSignature | undefined\n        if (this.signature) {\n            signature = JSON.parse(JSON.stringify(this.signature))\n        }\n        const data = JSON.stringify(this.data, (key, value) => {\n            if (value instanceof Uint8Array) {\n                return Array.from(value)\n            }\n            return value\n        })\n        return new SigningRequest(\n            this.version,\n            JSON.parse(data),\n            this.textEncoder,\n            this.textDecoder,\n            this.zlib,\n            this.abiProvider,\n            signature\n        )\n    }\n\n    // Convenience methods.\n\n    public toString() {\n        return this.encode()\n    }\n\n    public toJSON() {\n        return this.encode()\n    }\n}\n\nexport class ResolvedSigningRequest {\n    /** Recreate a resolved request from a callback payload. */\n    static async fromPayload(\n        payload: CallbackPayload,\n        options: SigningRequestEncodingOptions = {}\n    ): Promise<ResolvedSigningRequest> {\n        const request = SigningRequest.from(payload.req, options)\n        const abis = await request.fetchAbis()\n        return request.resolve(\n            abis,\n            {actor: payload.sa, permission: payload.sp},\n            {\n                ref_block_num: Number(payload.rbn),\n                ref_block_prefix: Number(payload.rid),\n                expiration: payload.ex,\n            }\n        )\n    }\n\n    public readonly request: SigningRequest\n    public readonly signer: abi.PermissionLevel\n    public readonly transaction: abi.Transaction\n    public readonly serializedTransaction: Uint8Array\n\n    constructor(\n        request: SigningRequest,\n        signer: abi.PermissionLevel,\n        transaction: abi.Transaction,\n        serializedTransaction: Uint8Array\n    ) {\n        this.request = request\n        this.signer = signer\n        this.transaction = transaction\n        this.serializedTransaction = serializedTransaction\n    }\n\n    public getTransactionId(): string {\n        return Serialize.arrayToHex(sha256(this.serializedTransaction))\n    }\n\n    public getCallback(signatures: string[], blockNum?: number): ResolvedCallback | null {\n        const {callback, flags} = this.request.data\n        if (!callback || callback.length === 0) {\n            return null\n        }\n        if (!signatures || signatures.length === 0) {\n            throw new Error('Must have at least one signature to resolve callback')\n        }\n        const payload: CallbackPayload = {\n            sig: signatures[0],\n            tx: this.getTransactionId(),\n            rbn: String(this.transaction.ref_block_num),\n            rid: String(this.transaction.ref_block_prefix),\n            ex: this.transaction.expiration,\n            req: this.request.encode(),\n            sa: this.signer.actor,\n            sp: this.signer.permission,\n        }\n        for (const [n, sig] of signatures.slice(1).entries()) {\n            payload[`sig${n}`] = sig\n        }\n        if (blockNum) {\n            payload.bn = String(blockNum)\n        }\n        const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {\n            return payload[m] || ''\n        })\n        return {\n            background: (flags & abi.RequestFlagsBackground) !== 0,\n            payload,\n            url,\n        }\n    }\n}\n\n/** Internal helper that creates a contract representation from an abi for the eosjs serializer. */\nfunction getContract(contractAbi: any): Serialize.Contract {\n    const types = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), contractAbi)\n    const actions = new Map<string, Serialize.Type>()\n    for (const {name, type} of contractAbi.actions) {\n        actions.set(name, Serialize.getType(types, type))\n    }\n    return {types, actions}\n}\n\nasync function serializeAction(\n    action: abi.Action,\n    textEncoder: TextEncoder,\n    textDecoder: TextDecoder,\n    abiProvider?: AbiProvider\n) {\n    if (typeof action.data === 'string') {\n        return action\n    }\n    let contractAbi: any\n    if (isIdentity(action)) {\n        contractAbi = abi.data\n    } else if (abiProvider) {\n        contractAbi = await abiProvider.getAbi(action.account)\n    } else {\n        throw new Error('Missing abi provider')\n    }\n    const contract = getContract(contractAbi)\n    return Serialize.serializeAction(\n        contract,\n        action.account,\n        action.name,\n        action.authorization,\n        action.data,\n        textEncoder,\n        textDecoder\n    )\n}\n\nfunction variantId(chainId?: abi.ChainId | abi.ChainAlias): abi.VariantId {\n    if (!chainId) {\n        chainId = ChainName.EOS\n    }\n    if (typeof chainId === 'number') {\n        return ['chain_alias', chainId]\n    } else {\n        // resolve known chain id's to their aliases\n        const name = idToName(chainId)\n        if (name !== ChainName.UNKNOWN) {\n            return ['chain_alias', name]\n        }\n        return ['chain_id', chainId]\n    }\n}\n\nfunction isIdentity(action: abi.Action) {\n    return action.account === '' && action.name === 'identity'\n}\n\nfunction hasTapos(tx: abi.Transaction) {\n    return !(\n        tx.expiration === '1970-01-01T00:00:00.000' &&\n        tx.ref_block_num === 0 &&\n        tx.ref_block_prefix === 0\n    )\n}\n\n/** Resolve a chain id to a chain name alias, returns UNKNOWN (0x00) if the chain id has no alias. */\nexport function idToName(chainId: abi.ChainId): ChainName {\n    chainId = chainId.toLowerCase()\n    for (const [n, id] of ChainIdLookup) {\n        if (id === chainId) {\n            n\n        }\n    }\n    return ChainName.UNKNOWN\n}\n\n/** Resolve a chain name alias to a chain id. */\nexport function nameToId(chainName: ChainName): abi.ChainId {\n    return (\n        ChainIdLookup.get(chainName) ||\n        '0000000000000000000000000000000000000000000000000000000000000000'\n    )\n}\n"],"names":["data","version","types","new_type_name","type","structs","name","fields","base","variants","actions","charset","lookup","Uint8Array","i","charCodeAt","ChainName","serializeAction","action","textEncoder","textDecoder","abiProvider","contractAbi","contract","getContract","Serialize","account","authorization","isIdentity","getAbi","Error","abi","AbiTypes","getTypesFromAbi","createInitialTypes","ChainIdLookup","Map","EOS","TELOS","JUNGLE","KYLIN","WORBLI","BOS","MEETONE","INSIGHTS","BEOS","WAX","PROTON","FIO","PlaceholderAuth","actor","permission","SigningRequest","zlib","signature","flags","req","callback","length","this","create","args","options","chain_id","variantId","chainId","undefined","broadcast","url","background","info","key","hasOwnProperty","value","encode","push","signatureProvider","sign","TextEncoder","TextDecoder","serialize","identity","transaction","TypeError","tx","expiration","ref_block_num","ref_block_prefix","context_free_actions","transaction_extensions","delay_sec","max_cpu_usage_ms","max_net_usage_words","Promise","all","map","fromTransaction","serializedTransaction","arrayToHex","hexToUint8Array","buf","SerialBuffer","id","pushArray","fromData","asUint8Array","from","uri","split","scheme","path","input","a","b","c","d","p","base64u","startsWith","slice","header","array","inflateRaw","buffer","deserialize","haveReadData","get","message","getSignatureDigest","getData","sha256","setSignature","signer","setCallback","setBroadcast","compress","slashes","shouldCompress","sigData","getSignatureData","byteLength","set","deflated","deflateRaw","out","chunk","byteRemainder","mainLength","parts","join","getRequiredAbis","getRawActions","filter","index","self","indexOf","requiresTapos","getRawTransaction","hasTapos","fetchAbis","provider","abis","_set2","resolveActions","rawAction","getName","deserializeAction","_this3","auth","resolveTransaction","ctx","block_num","timestamp","transactionHeader","expire_seconds","resolve","_this4","transactionType","ResolvedSigningRequest","getChainId","has","idType","shouldBroadcast","getIdentity","getIdentityPermission","getRawInfo","rv","getInfo","raw","Object","keys","decode","setInfoKey","encodedValue","pair","find","clone","JSON","parse","stringify","Array","toString","toJSON","request","fromPayload","payload","sa","sp","Number","rbn","rid","ex","getTransactionId","getCallback","signatures","blockNum","sig","String","entries","bn","replace","_1","_2","m","getType","idToName","UNKNOWN","toLowerCase","chainName"],"mappings":"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"}