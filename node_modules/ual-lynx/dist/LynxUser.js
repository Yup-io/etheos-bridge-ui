"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LynxUser = void 0;
const universal_authenticator_library_1 = require("universal-authenticator-library");
const UALLynxError_1 = require("./UALLynxError");
class LynxUser extends universal_authenticator_library_1.User {
    constructor(chain, accountObj) {
        super();
        this.keys = [];
        this.chainId = '';
        this.account = accountObj.account;
        if (chain && chain.chainId) {
            this.chainId = chain.chainId;
        }
    }
    signTransaction(transaction, 
    // tslint:disable-next-line:variable-name
    _config) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                result = yield window.lynxMobile.transact(transaction);
                return {
                    wasBroadcast: true,
                    transactionId: result.transaction_id,
                    transaction: result,
                };
            }
            catch (e) {
                throw new UALLynxError_1.UALLynxError('Unable to sign the given transaction', universal_authenticator_library_1.UALErrorType.Signing, e);
            }
        });
    }
    signArbitrary(_, data, helpText) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return window.lynxMobile.requestArbitrarySignature({ data, whatFor: helpText });
            }
            catch (e) {
                throw new UALLynxError_1.UALLynxError('Unable to sign arbitrary string', universal_authenticator_library_1.UALErrorType.Signing, e);
            }
        });
    }
    verifyKeyOwnership(_) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Lynx does not currently support verifyKeyOwnership');
        });
    }
    getAccountName() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.account.account_name;
        });
    }
    getChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chainId;
        });
    }
    getKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.keys.length === 0) {
                this.account.permissions.forEach((perm) => {
                    if (perm.perm_name === 'active') {
                        perm.required_auth.keys.forEach((key) => {
                            this.keys.push(key.key);
                        });
                    }
                });
            }
            return this.keys;
        });
    }
}
exports.LynxUser = LynxUser;
